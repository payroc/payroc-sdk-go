// Code generated by Fern. DO NOT EDIT.

package payroccloud

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	retrieveSignaturesRequestFieldSignatureId = big.NewInt(1 << 0)
)

type RetrieveSignaturesRequest struct {
	// Unique identifier that we assigned to the signature.
	SignatureId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RetrieveSignaturesRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSignatureId sets the SignatureId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveSignaturesRequest) SetSignatureId(signatureId string) {
	r.SignatureId = signatureId
	r.require(retrieveSignaturesRequestFieldSignatureId)
}

var (
	retrieveSignaturesResponseFieldSignatureId          = big.NewInt(1 << 0)
	retrieveSignaturesResponseFieldProcessingTerminalId = big.NewInt(1 << 1)
	retrieveSignaturesResponseFieldCreatedOn            = big.NewInt(1 << 2)
	retrieveSignaturesResponseFieldContentType          = big.NewInt(1 << 3)
	retrieveSignaturesResponseFieldSignature            = big.NewInt(1 << 4)
)

type RetrieveSignaturesResponse struct {
	// Unique identifier that we assigned to the signature.
	SignatureId *string `json:"signatureId,omitempty" url:"signatureId,omitempty"`
	// Unique identifier of the terminal that the signature is linked to.
	ProcessingTerminalId *string `json:"processingTerminalId,omitempty" url:"processingTerminalId,omitempty"`
	// Date that the device captured the signature. The format of this value is **YYYY-MM-DD**.
	CreatedOn *time.Time `json:"createdOn,omitempty" url:"createdOn,omitempty" format:"date"`
	// MIME type that indicates the format of the image file.
	ContentType *string `json:"contentType,omitempty" url:"contentType,omitempty"`
	// Image data for the signature. Our gateway returns the signature as a Base64-encoded value.
	Signature *string `json:"signature,omitempty" url:"signature,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveSignaturesResponse) GetSignatureId() *string {
	if r == nil {
		return nil
	}
	return r.SignatureId
}

func (r *RetrieveSignaturesResponse) GetProcessingTerminalId() *string {
	if r == nil {
		return nil
	}
	return r.ProcessingTerminalId
}

func (r *RetrieveSignaturesResponse) GetCreatedOn() *time.Time {
	if r == nil {
		return nil
	}
	return r.CreatedOn
}

func (r *RetrieveSignaturesResponse) GetContentType() *string {
	if r == nil {
		return nil
	}
	return r.ContentType
}

func (r *RetrieveSignaturesResponse) GetSignature() *string {
	if r == nil {
		return nil
	}
	return r.Signature
}

func (r *RetrieveSignaturesResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveSignaturesResponse) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSignatureId sets the SignatureId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveSignaturesResponse) SetSignatureId(signatureId *string) {
	r.SignatureId = signatureId
	r.require(retrieveSignaturesResponseFieldSignatureId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveSignaturesResponse) SetProcessingTerminalId(processingTerminalId *string) {
	r.ProcessingTerminalId = processingTerminalId
	r.require(retrieveSignaturesResponseFieldProcessingTerminalId)
}

// SetCreatedOn sets the CreatedOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveSignaturesResponse) SetCreatedOn(createdOn *time.Time) {
	r.CreatedOn = createdOn
	r.require(retrieveSignaturesResponseFieldCreatedOn)
}

// SetContentType sets the ContentType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveSignaturesResponse) SetContentType(contentType *string) {
	r.ContentType = contentType
	r.require(retrieveSignaturesResponseFieldContentType)
}

// SetSignature sets the Signature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveSignaturesResponse) SetSignature(signature *string) {
	r.Signature = signature
	r.require(retrieveSignaturesResponseFieldSignature)
}

func (r *RetrieveSignaturesResponse) UnmarshalJSON(data []byte) error {
	type embed RetrieveSignaturesResponse
	var unmarshaler = struct {
		embed
		CreatedOn *internal.Date `json:"createdOn,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RetrieveSignaturesResponse(unmarshaler.embed)
	r.CreatedOn = unmarshaler.CreatedOn.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveSignaturesResponse) MarshalJSON() ([]byte, error) {
	type embed RetrieveSignaturesResponse
	var marshaler = struct {
		embed
		CreatedOn *internal.Date `json:"createdOn,omitempty"`
	}{
		embed:     embed(*r),
		CreatedOn: internal.NewOptionalDate(r.CreatedOn),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrieveSignaturesResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
