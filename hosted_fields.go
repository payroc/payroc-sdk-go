// Code generated by Fern. DO NOT EDIT.

package payroc

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	hostedFieldsCreateSessionRequestFieldIdempotencyKey       = big.NewInt(1 << 0)
	hostedFieldsCreateSessionRequestFieldProcessingTerminalId = big.NewInt(1 << 1)
	hostedFieldsCreateSessionRequestFieldLibVersion           = big.NewInt(1 << 2)
	hostedFieldsCreateSessionRequestFieldScenario             = big.NewInt(1 << 3)
	hostedFieldsCreateSessionRequestFieldSecureTokenId        = big.NewInt(1 << 4)
)

type HostedFieldsCreateSessionRequest struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"-" url:"-"`
	// Version of the Hosted Fields JavaScript library that you are using.
	//
	// The current production version is `1.6.0.172441`.
	LibVersion string `json:"libVersion" url:"-"`
	// Indicates if a merchant wants to take a payment or tokenize a customer's payment details:
	//
	// - `payment` - The merchant wants to run a sale or run a sale and tokenize in the same transaction.
	// - `tokenization` - The merchant wants to save the customer's payment details to take a payment later or to update a customer's payment details that they've already saved.
	Scenario HostedFieldsCreateSessionRequestScenario `json:"scenario" url:"-"`
	// Unique identifier that represents a customer's payment details.
	//
	// If a merchant wants to update a customer's payment details that are linked to a secure token, include the secureTokenId in your request.
	SecureTokenId *string `json:"secureTokenId,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (h *HostedFieldsCreateSessionRequest) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionRequest) SetIdempotencyKey(idempotencyKey string) {
	h.IdempotencyKey = idempotencyKey
	h.require(hostedFieldsCreateSessionRequestFieldIdempotencyKey)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionRequest) SetProcessingTerminalId(processingTerminalId string) {
	h.ProcessingTerminalId = processingTerminalId
	h.require(hostedFieldsCreateSessionRequestFieldProcessingTerminalId)
}

// SetLibVersion sets the LibVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionRequest) SetLibVersion(libVersion string) {
	h.LibVersion = libVersion
	h.require(hostedFieldsCreateSessionRequestFieldLibVersion)
}

// SetScenario sets the Scenario field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionRequest) SetScenario(scenario HostedFieldsCreateSessionRequestScenario) {
	h.Scenario = scenario
	h.require(hostedFieldsCreateSessionRequestFieldScenario)
}

// SetSecureTokenId sets the SecureTokenId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionRequest) SetSecureTokenId(secureTokenId *string) {
	h.SecureTokenId = secureTokenId
	h.require(hostedFieldsCreateSessionRequestFieldSecureTokenId)
}

func (h *HostedFieldsCreateSessionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HostedFieldsCreateSessionRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*h = HostedFieldsCreateSessionRequest(body)
	return nil
}

func (h *HostedFieldsCreateSessionRequest) MarshalJSON() ([]byte, error) {
	type embed HostedFieldsCreateSessionRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	hostedFieldsCreateSessionResponseFieldProcessingTerminalId = big.NewInt(1 << 0)
	hostedFieldsCreateSessionResponseFieldToken                = big.NewInt(1 << 1)
	hostedFieldsCreateSessionResponseFieldExpiresAt            = big.NewInt(1 << 2)
)

type HostedFieldsCreateSessionResponse struct {
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Token that our gateway assigned to the Hosted Fields session.
	//
	// Include this session token in the config file for Hosted Fields.
	//
	// The session token expires after 10 minutes.
	Token string `json:"token" url:"token"`
	// Date and time that the token expires. We return this value in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	ExpiresAt *time.Time `json:"expiresAt,omitempty" url:"expiresAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HostedFieldsCreateSessionResponse) GetProcessingTerminalId() string {
	if h == nil {
		return ""
	}
	return h.ProcessingTerminalId
}

func (h *HostedFieldsCreateSessionResponse) GetToken() string {
	if h == nil {
		return ""
	}
	return h.Token
}

func (h *HostedFieldsCreateSessionResponse) GetExpiresAt() *time.Time {
	if h == nil {
		return nil
	}
	return h.ExpiresAt
}

func (h *HostedFieldsCreateSessionResponse) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HostedFieldsCreateSessionResponse) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionResponse) SetProcessingTerminalId(processingTerminalId string) {
	h.ProcessingTerminalId = processingTerminalId
	h.require(hostedFieldsCreateSessionResponseFieldProcessingTerminalId)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionResponse) SetToken(token string) {
	h.Token = token
	h.require(hostedFieldsCreateSessionResponseFieldToken)
}

// SetExpiresAt sets the ExpiresAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostedFieldsCreateSessionResponse) SetExpiresAt(expiresAt *time.Time) {
	h.ExpiresAt = expiresAt
	h.require(hostedFieldsCreateSessionResponseFieldExpiresAt)
}

func (h *HostedFieldsCreateSessionResponse) UnmarshalJSON(data []byte) error {
	type embed HostedFieldsCreateSessionResponse
	var unmarshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed: embed(*h),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*h = HostedFieldsCreateSessionResponse(unmarshaler.embed)
	h.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HostedFieldsCreateSessionResponse) MarshalJSON() ([]byte, error) {
	type embed HostedFieldsCreateSessionResponse
	var marshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed:     embed(*h),
		ExpiresAt: internal.NewOptionalDateTime(h.ExpiresAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HostedFieldsCreateSessionResponse) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Indicates if a merchant wants to take a payment or tokenize a customer's payment details:
//
// - `payment` - The merchant wants to run a sale or run a sale and tokenize in the same transaction.
// - `tokenization` - The merchant wants to save the customer's payment details to take a payment later or to update a customer's payment details that they've already saved.
type HostedFieldsCreateSessionRequestScenario string

const (
	HostedFieldsCreateSessionRequestScenarioPayment      HostedFieldsCreateSessionRequestScenario = "payment"
	HostedFieldsCreateSessionRequestScenarioTokenization HostedFieldsCreateSessionRequestScenario = "tokenization"
)

func NewHostedFieldsCreateSessionRequestScenarioFromString(s string) (HostedFieldsCreateSessionRequestScenario, error) {
	switch s {
	case "payment":
		return HostedFieldsCreateSessionRequestScenarioPayment, nil
	case "tokenization":
		return HostedFieldsCreateSessionRequestScenarioTokenization, nil
	}
	var t HostedFieldsCreateSessionRequestScenario
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HostedFieldsCreateSessionRequestScenario) Ptr() *HostedFieldsCreateSessionRequestScenario {
	return &h
}
