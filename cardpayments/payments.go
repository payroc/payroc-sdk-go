// Code generated by Fern. DO NOT EDIT.

package cardpayments

import (
	json "encoding/json"
	fmt "fmt"
	papisdkgo "github.com/payroc/payroc-sdk-go"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	paymentAdjustmentFieldIdempotencyKey = big.NewInt(1 << 0)
	paymentAdjustmentFieldPaymentId      = big.NewInt(1 << 1)
	paymentAdjustmentFieldOperator       = big.NewInt(1 << 2)
	paymentAdjustmentFieldAdjustments    = big.NewInt(1 << 3)
)

type PaymentAdjustment struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier of the payment that the merchant wants to retrieve.
	PaymentId string `json:"-" url:"-"`
	// Operator who adjusted the payment.
	Operator *string `json:"operator,omitempty" url:"-"`
	// Array of polymorphic objects which contain information about adjustments to a payment.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`order` - Tip information.
	// -	`status` - Status of the transaction.
	// -	`customer` - Customer's contact information and shipping address.
	// -	`signature` - Customer's signature.
	Adjustments []*PaymentAdjustmentAdjustmentsItem `json:"adjustments" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PaymentAdjustment) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentAdjustment) SetIdempotencyKey(idempotencyKey string) {
	p.IdempotencyKey = idempotencyKey
	p.require(paymentAdjustmentFieldIdempotencyKey)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentAdjustment) SetPaymentId(paymentId string) {
	p.PaymentId = paymentId
	p.require(paymentAdjustmentFieldPaymentId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentAdjustment) SetOperator(operator *string) {
	p.Operator = operator
	p.require(paymentAdjustmentFieldOperator)
}

// SetAdjustments sets the Adjustments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentAdjustment) SetAdjustments(adjustments []*PaymentAdjustmentAdjustmentsItem) {
	p.Adjustments = adjustments
	p.require(paymentAdjustmentFieldAdjustments)
}

func (p *PaymentAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentAdjustment
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*p = PaymentAdjustment(body)
	return nil
}

func (p *PaymentAdjustment) MarshalJSON() ([]byte, error) {
	type embed PaymentAdjustment
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	paymentCaptureFieldIdempotencyKey       = big.NewInt(1 << 0)
	paymentCaptureFieldPaymentId            = big.NewInt(1 << 1)
	paymentCaptureFieldProcessingTerminalId = big.NewInt(1 << 2)
	paymentCaptureFieldOperator             = big.NewInt(1 << 3)
	paymentCaptureFieldAmount               = big.NewInt(1 << 4)
	paymentCaptureFieldBreakdown            = big.NewInt(1 << 5)
)

type PaymentCapture struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier of the payment that the merchant wants to retrieve.
	PaymentId string `json:"-" url:"-"`
	// Unique identifier that our gateway assigned to the terminal.
	ProcessingTerminalId *string `json:"processingTerminalId,omitempty" url:"-"`
	// Operator who captured the payment.
	Operator *string `json:"operator,omitempty" url:"-"`
	// Amount that the merchant wants to capture. The value is in the currency's lowest denomination, for example, cents.
	// **Note:** If the merchant does not send an amount, we capture the total amount of the transaction.
	Amount    *int64                              `json:"amount,omitempty" url:"-"`
	Breakdown *papisdkgo.ItemizedBreakdownRequest `json:"breakdown,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PaymentCapture) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentCapture) SetIdempotencyKey(idempotencyKey string) {
	p.IdempotencyKey = idempotencyKey
	p.require(paymentCaptureFieldIdempotencyKey)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentCapture) SetPaymentId(paymentId string) {
	p.PaymentId = paymentId
	p.require(paymentCaptureFieldPaymentId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentCapture) SetProcessingTerminalId(processingTerminalId *string) {
	p.ProcessingTerminalId = processingTerminalId
	p.require(paymentCaptureFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentCapture) SetOperator(operator *string) {
	p.Operator = operator
	p.require(paymentCaptureFieldOperator)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentCapture) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentCaptureFieldAmount)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentCapture) SetBreakdown(breakdown *papisdkgo.ItemizedBreakdownRequest) {
	p.Breakdown = breakdown
	p.require(paymentCaptureFieldBreakdown)
}

func (p *PaymentCapture) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCapture
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*p = PaymentCapture(body)
	return nil
}

func (p *PaymentCapture) MarshalJSON() ([]byte, error) {
	type embed PaymentCapture
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	paymentRequestFieldIdempotencyKey       = big.NewInt(1 << 0)
	paymentRequestFieldChannel              = big.NewInt(1 << 1)
	paymentRequestFieldProcessingTerminalId = big.NewInt(1 << 2)
	paymentRequestFieldOperator             = big.NewInt(1 << 3)
	paymentRequestFieldOrder                = big.NewInt(1 << 4)
	paymentRequestFieldCustomer             = big.NewInt(1 << 5)
	paymentRequestFieldIpAddress            = big.NewInt(1 << 6)
	paymentRequestFieldPaymentMethod        = big.NewInt(1 << 7)
	paymentRequestFieldThreeDSecure         = big.NewInt(1 << 8)
	paymentRequestFieldCredentialOnFile     = big.NewInt(1 << 9)
	paymentRequestFieldOfflineProcessing    = big.NewInt(1 << 10)
	paymentRequestFieldAutoCapture          = big.NewInt(1 << 11)
	paymentRequestFieldProcessAsSale        = big.NewInt(1 << 12)
	paymentRequestFieldCustomFields         = big.NewInt(1 << 13)
)

type PaymentRequest struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Channel that the merchant used to receive the payment details.
	Channel PaymentRequestChannel `json:"channel" url:"-"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"-"`
	// Operator who ran the transaction.
	Operator  *string                        `json:"operator,omitempty" url:"-"`
	Order     *papisdkgo.PaymentOrderRequest `json:"order" url:"-"`
	Customer  *papisdkgo.Customer            `json:"customer,omitempty" url:"-"`
	IpAddress *papisdkgo.IpAddress           `json:"ipAddress,omitempty" url:"-"`
	// Polymorphic object that contains payment details.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`card` - Payment card details
	// -	`secureToken` - Secure token details
	// -	`digitalWallet` - Digital wallet details
	// -	`singleUseToken` - Single-use token details
	PaymentMethod *PaymentRequestPaymentMethod `json:"paymentMethod" url:"-"`
	// Polymorphic object that contains authentication information from 3-D Secure.
	//
	// The value of the serviceProvider parameter determines which variant you should use:
	// -	`gateway` - Use our gateway to run a 3-D Secure check.
	// -	`thirdParty` - Use a third party to run a 3-D Secure check.
	ThreeDSecure      *PaymentRequestThreeDSecure        `json:"threeDSecure,omitempty" url:"-"`
	CredentialOnFile  *papisdkgo.SchemasCredentialOnFile `json:"credentialOnFile,omitempty" url:"-"`
	OfflineProcessing *papisdkgo.OfflineProcessing       `json:"offlineProcessing,omitempty" url:"-"`
	// Indicates if we should automatically capture the payment amount.
	//
	// - `true` - Run a sale and automatically capture the transaction.
	// - `false`- Run a pre-authorization and capture the transaction later.
	//
	// **Note:** If you send `false` and the terminal doesn't support pre-authorization, we set the transaction's status to pending. The merchant must capture the transaction to take payment from the customer.
	AutoCapture *bool `json:"autoCapture,omitempty" url:"-"`
	// Indicates if we should immediately settle the sale transaction. The merchant cannot adjust the transaction if we immediately settle it.
	// **Note:** If the value for **processAsSale** is `true`, the gateway ignores the value in **autoCapture**.
	ProcessAsSale *bool `json:"processAsSale,omitempty" url:"-"`
	// Array of customField objects.
	CustomFields []*papisdkgo.CustomField `json:"customFields,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PaymentRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetIdempotencyKey(idempotencyKey string) {
	p.IdempotencyKey = idempotencyKey
	p.require(paymentRequestFieldIdempotencyKey)
}

// SetChannel sets the Channel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetChannel(channel PaymentRequestChannel) {
	p.Channel = channel
	p.require(paymentRequestFieldChannel)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetProcessingTerminalId(processingTerminalId string) {
	p.ProcessingTerminalId = processingTerminalId
	p.require(paymentRequestFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetOperator(operator *string) {
	p.Operator = operator
	p.require(paymentRequestFieldOperator)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetOrder(order *papisdkgo.PaymentOrderRequest) {
	p.Order = order
	p.require(paymentRequestFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetCustomer(customer *papisdkgo.Customer) {
	p.Customer = customer
	p.require(paymentRequestFieldCustomer)
}

// SetIpAddress sets the IpAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetIpAddress(ipAddress *papisdkgo.IpAddress) {
	p.IpAddress = ipAddress
	p.require(paymentRequestFieldIpAddress)
}

// SetPaymentMethod sets the PaymentMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetPaymentMethod(paymentMethod *PaymentRequestPaymentMethod) {
	p.PaymentMethod = paymentMethod
	p.require(paymentRequestFieldPaymentMethod)
}

// SetThreeDSecure sets the ThreeDSecure field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetThreeDSecure(threeDSecure *PaymentRequestThreeDSecure) {
	p.ThreeDSecure = threeDSecure
	p.require(paymentRequestFieldThreeDSecure)
}

// SetCredentialOnFile sets the CredentialOnFile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetCredentialOnFile(credentialOnFile *papisdkgo.SchemasCredentialOnFile) {
	p.CredentialOnFile = credentialOnFile
	p.require(paymentRequestFieldCredentialOnFile)
}

// SetOfflineProcessing sets the OfflineProcessing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetOfflineProcessing(offlineProcessing *papisdkgo.OfflineProcessing) {
	p.OfflineProcessing = offlineProcessing
	p.require(paymentRequestFieldOfflineProcessing)
}

// SetAutoCapture sets the AutoCapture field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetAutoCapture(autoCapture *bool) {
	p.AutoCapture = autoCapture
	p.require(paymentRequestFieldAutoCapture)
}

// SetProcessAsSale sets the ProcessAsSale field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetProcessAsSale(processAsSale *bool) {
	p.ProcessAsSale = processAsSale
	p.require(paymentRequestFieldProcessAsSale)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentRequest) SetCustomFields(customFields []*papisdkgo.CustomField) {
	p.CustomFields = customFields
	p.require(paymentRequestFieldCustomFields)
}

func (p *PaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*p = PaymentRequest(body)
	return nil
}

func (p *PaymentRequest) MarshalJSON() ([]byte, error) {
	type embed PaymentRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	listPaymentsRequestFieldProcessingTerminalId = big.NewInt(1 << 0)
	listPaymentsRequestFieldOrderId              = big.NewInt(1 << 1)
	listPaymentsRequestFieldOperator             = big.NewInt(1 << 2)
	listPaymentsRequestFieldCardholderName       = big.NewInt(1 << 3)
	listPaymentsRequestFieldFirst6               = big.NewInt(1 << 4)
	listPaymentsRequestFieldLast4                = big.NewInt(1 << 5)
	listPaymentsRequestFieldTender               = big.NewInt(1 << 6)
	listPaymentsRequestFieldTipMode              = big.NewInt(1 << 7)
	listPaymentsRequestFieldType                 = big.NewInt(1 << 8)
	listPaymentsRequestFieldStatus               = big.NewInt(1 << 9)
	listPaymentsRequestFieldDateFrom             = big.NewInt(1 << 10)
	listPaymentsRequestFieldDateTo               = big.NewInt(1 << 11)
	listPaymentsRequestFieldSettlementState      = big.NewInt(1 << 12)
	listPaymentsRequestFieldSettlementDate       = big.NewInt(1 << 13)
	listPaymentsRequestFieldPaymentLinkId        = big.NewInt(1 << 14)
	listPaymentsRequestFieldBefore               = big.NewInt(1 << 15)
	listPaymentsRequestFieldAfter                = big.NewInt(1 << 16)
	listPaymentsRequestFieldLimit                = big.NewInt(1 << 17)
)

type ListPaymentsRequest struct {
	// Filter by terminal ID.
	ProcessingTerminalId *string `json:"-" url:"processingTerminalId,omitempty"`
	// Filter payments by order ID.
	OrderId *string `json:"-" url:"orderId,omitempty"`
	// Filter payments by operator.
	Operator *string `json:"-" url:"operator,omitempty"`
	// Filter payments by the cardholder’s name.
	CardholderName *string `json:"-" url:"cardholderName,omitempty"`
	// Filter payments by the first six digits of the card number that the customer used in the transaction.
	First6 *string `json:"-" url:"first6,omitempty"`
	// Filter payments by the last four digits of the card number that the customer used in the transaction.
	Last4 *string `json:"-" url:"last4,omitempty"`
	// Filter by tender type.
	Tender *ListPaymentsRequestTender `json:"-" url:"tender,omitempty"`
	// Filter payments by tip.
	TipMode []*ListPaymentsRequestTipModeItem `json:"-" url:"tipMode,omitempty"`
	// Filter payments by transaction type.
	Type []*ListPaymentsRequestTypeItem `json:"-" url:"type,omitempty"`
	// Filter payments by the status of the transaction.
	Status []*ListPaymentsRequestStatusItem `json:"-" url:"status,omitempty"`
	// Filter by payments that the processor processed after a specific date. The date format follows the ISO 8601 standard.
	DateFrom *time.Time `json:"-" url:"dateFrom,omitempty"`
	// Filter by payments that the processer processed before a specific date. The date format follows the ISO 8601 standard.
	DateTo *time.Time `json:"-" url:"dateTo,omitempty"`
	// Filter payments by the settlement status of the transaction.
	SettlementState *ListPaymentsRequestSettlementState `json:"-" url:"settlementState,omitempty"`
	// Filter by payments that the processor settled on a specific date in the format **YYYY-MM-DD**.
	SettlementDate *time.Time `json:"-" url:"settlementDate,omitempty" format:"date"`
	// Unique identifier that our gateway assigned to the payment link.
	PaymentLinkId *string `json:"-" url:"paymentLinkId,omitempty"`
	// Return the previous page of results before the value that you specify.
	//
	// You can’t send the before parameter in the same request as the after parameter.
	Before *string `json:"-" url:"before,omitempty"`
	// Return the next page of results after the value that you specify.
	//
	// You can’t send the after parameter in the same request as the before parameter.
	After *string `json:"-" url:"after,omitempty"`
	// Limit the maximum number of results that we return for each page.
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListPaymentsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetProcessingTerminalId(processingTerminalId *string) {
	l.ProcessingTerminalId = processingTerminalId
	l.require(listPaymentsRequestFieldProcessingTerminalId)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetOrderId(orderId *string) {
	l.OrderId = orderId
	l.require(listPaymentsRequestFieldOrderId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetOperator(operator *string) {
	l.Operator = operator
	l.require(listPaymentsRequestFieldOperator)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetCardholderName(cardholderName *string) {
	l.CardholderName = cardholderName
	l.require(listPaymentsRequestFieldCardholderName)
}

// SetFirst6 sets the First6 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetFirst6(first6 *string) {
	l.First6 = first6
	l.require(listPaymentsRequestFieldFirst6)
}

// SetLast4 sets the Last4 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetLast4(last4 *string) {
	l.Last4 = last4
	l.require(listPaymentsRequestFieldLast4)
}

// SetTender sets the Tender field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetTender(tender *ListPaymentsRequestTender) {
	l.Tender = tender
	l.require(listPaymentsRequestFieldTender)
}

// SetTipMode sets the TipMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetTipMode(tipMode []*ListPaymentsRequestTipModeItem) {
	l.TipMode = tipMode
	l.require(listPaymentsRequestFieldTipMode)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetType(type_ []*ListPaymentsRequestTypeItem) {
	l.Type = type_
	l.require(listPaymentsRequestFieldType)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetStatus(status []*ListPaymentsRequestStatusItem) {
	l.Status = status
	l.require(listPaymentsRequestFieldStatus)
}

// SetDateFrom sets the DateFrom field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetDateFrom(dateFrom *time.Time) {
	l.DateFrom = dateFrom
	l.require(listPaymentsRequestFieldDateFrom)
}

// SetDateTo sets the DateTo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetDateTo(dateTo *time.Time) {
	l.DateTo = dateTo
	l.require(listPaymentsRequestFieldDateTo)
}

// SetSettlementState sets the SettlementState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetSettlementState(settlementState *ListPaymentsRequestSettlementState) {
	l.SettlementState = settlementState
	l.require(listPaymentsRequestFieldSettlementState)
}

// SetSettlementDate sets the SettlementDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetSettlementDate(settlementDate *time.Time) {
	l.SettlementDate = settlementDate
	l.require(listPaymentsRequestFieldSettlementDate)
}

// SetPaymentLinkId sets the PaymentLinkId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetPaymentLinkId(paymentLinkId *string) {
	l.PaymentLinkId = paymentLinkId
	l.require(listPaymentsRequestFieldPaymentLinkId)
}

// SetBefore sets the Before field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetBefore(before *string) {
	l.Before = before
	l.require(listPaymentsRequestFieldBefore)
}

// SetAfter sets the After field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetAfter(after *string) {
	l.After = after
	l.require(listPaymentsRequestFieldAfter)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listPaymentsRequestFieldLimit)
}

var (
	retrievePaymentsRequestFieldPaymentId = big.NewInt(1 << 0)
)

type RetrievePaymentsRequest struct {
	// Unique identifier of the payment that the merchant wants to retrieve.
	PaymentId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RetrievePaymentsRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievePaymentsRequest) SetPaymentId(paymentId string) {
	r.PaymentId = paymentId
	r.require(retrievePaymentsRequestFieldPaymentId)
}

type ListPaymentsRequestSettlementState string

const (
	ListPaymentsRequestSettlementStateSettled   ListPaymentsRequestSettlementState = "settled"
	ListPaymentsRequestSettlementStateUnsettled ListPaymentsRequestSettlementState = "unsettled"
)

func NewListPaymentsRequestSettlementStateFromString(s string) (ListPaymentsRequestSettlementState, error) {
	switch s {
	case "settled":
		return ListPaymentsRequestSettlementStateSettled, nil
	case "unsettled":
		return ListPaymentsRequestSettlementStateUnsettled, nil
	}
	var t ListPaymentsRequestSettlementState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestSettlementState) Ptr() *ListPaymentsRequestSettlementState {
	return &l
}

type ListPaymentsRequestStatusItem string

const (
	ListPaymentsRequestStatusItemReady    ListPaymentsRequestStatusItem = "ready"
	ListPaymentsRequestStatusItemPending  ListPaymentsRequestStatusItem = "pending"
	ListPaymentsRequestStatusItemDeclined ListPaymentsRequestStatusItem = "declined"
	ListPaymentsRequestStatusItemComplete ListPaymentsRequestStatusItem = "complete"
	ListPaymentsRequestStatusItemReferral ListPaymentsRequestStatusItem = "referral"
	ListPaymentsRequestStatusItemPickup   ListPaymentsRequestStatusItem = "pickup"
	ListPaymentsRequestStatusItemReversal ListPaymentsRequestStatusItem = "reversal"
	ListPaymentsRequestStatusItemAdmin    ListPaymentsRequestStatusItem = "admin"
	ListPaymentsRequestStatusItemExpired  ListPaymentsRequestStatusItem = "expired"
	ListPaymentsRequestStatusItemAccepted ListPaymentsRequestStatusItem = "accepted"
)

func NewListPaymentsRequestStatusItemFromString(s string) (ListPaymentsRequestStatusItem, error) {
	switch s {
	case "ready":
		return ListPaymentsRequestStatusItemReady, nil
	case "pending":
		return ListPaymentsRequestStatusItemPending, nil
	case "declined":
		return ListPaymentsRequestStatusItemDeclined, nil
	case "complete":
		return ListPaymentsRequestStatusItemComplete, nil
	case "referral":
		return ListPaymentsRequestStatusItemReferral, nil
	case "pickup":
		return ListPaymentsRequestStatusItemPickup, nil
	case "reversal":
		return ListPaymentsRequestStatusItemReversal, nil
	case "admin":
		return ListPaymentsRequestStatusItemAdmin, nil
	case "expired":
		return ListPaymentsRequestStatusItemExpired, nil
	case "accepted":
		return ListPaymentsRequestStatusItemAccepted, nil
	}
	var t ListPaymentsRequestStatusItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestStatusItem) Ptr() *ListPaymentsRequestStatusItem {
	return &l
}

type ListPaymentsRequestTender string

const (
	ListPaymentsRequestTenderEbt         ListPaymentsRequestTender = "ebt"
	ListPaymentsRequestTenderCreditDebit ListPaymentsRequestTender = "creditDebit"
)

func NewListPaymentsRequestTenderFromString(s string) (ListPaymentsRequestTender, error) {
	switch s {
	case "ebt":
		return ListPaymentsRequestTenderEbt, nil
	case "creditDebit":
		return ListPaymentsRequestTenderCreditDebit, nil
	}
	var t ListPaymentsRequestTender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestTender) Ptr() *ListPaymentsRequestTender {
	return &l
}

type ListPaymentsRequestTipModeItem string

const (
	ListPaymentsRequestTipModeItemNoTip    ListPaymentsRequestTipModeItem = "noTip"
	ListPaymentsRequestTipModeItemPrompted ListPaymentsRequestTipModeItem = "prompted"
	ListPaymentsRequestTipModeItemAdjusted ListPaymentsRequestTipModeItem = "adjusted"
)

func NewListPaymentsRequestTipModeItemFromString(s string) (ListPaymentsRequestTipModeItem, error) {
	switch s {
	case "noTip":
		return ListPaymentsRequestTipModeItemNoTip, nil
	case "prompted":
		return ListPaymentsRequestTipModeItemPrompted, nil
	case "adjusted":
		return ListPaymentsRequestTipModeItemAdjusted, nil
	}
	var t ListPaymentsRequestTipModeItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestTipModeItem) Ptr() *ListPaymentsRequestTipModeItem {
	return &l
}

type ListPaymentsRequestTypeItem string

const (
	ListPaymentsRequestTypeItemSale                       ListPaymentsRequestTypeItem = "sale"
	ListPaymentsRequestTypeItemPreAuthorization           ListPaymentsRequestTypeItem = "preAuthorization"
	ListPaymentsRequestTypeItemPreAuthorizationCompletion ListPaymentsRequestTypeItem = "preAuthorizationCompletion"
)

func NewListPaymentsRequestTypeItemFromString(s string) (ListPaymentsRequestTypeItem, error) {
	switch s {
	case "sale":
		return ListPaymentsRequestTypeItemSale, nil
	case "preAuthorization":
		return ListPaymentsRequestTypeItemPreAuthorization, nil
	case "preAuthorizationCompletion":
		return ListPaymentsRequestTypeItemPreAuthorizationCompletion, nil
	}
	var t ListPaymentsRequestTypeItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestTypeItem) Ptr() *ListPaymentsRequestTypeItem {
	return &l
}

type PaymentAdjustmentAdjustmentsItem struct {
	Type      string
	Order     *papisdkgo.OrderAdjustment
	Status    *papisdkgo.StatusAdjustment
	Customer  *papisdkgo.CustomerAdjustment
	Signature *papisdkgo.SignatureAdjustment
}

func (p *PaymentAdjustmentAdjustmentsItem) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentAdjustmentAdjustmentsItem) GetOrder() *papisdkgo.OrderAdjustment {
	if p == nil {
		return nil
	}
	return p.Order
}

func (p *PaymentAdjustmentAdjustmentsItem) GetStatus() *papisdkgo.StatusAdjustment {
	if p == nil {
		return nil
	}
	return p.Status
}

func (p *PaymentAdjustmentAdjustmentsItem) GetCustomer() *papisdkgo.CustomerAdjustment {
	if p == nil {
		return nil
	}
	return p.Customer
}

func (p *PaymentAdjustmentAdjustmentsItem) GetSignature() *papisdkgo.SignatureAdjustment {
	if p == nil {
		return nil
	}
	return p.Signature
}

func (p *PaymentAdjustmentAdjustmentsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "order":
		value := new(papisdkgo.OrderAdjustment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Order = value
	case "status":
		value := new(papisdkgo.StatusAdjustment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Status = value
	case "customer":
		value := new(papisdkgo.CustomerAdjustment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Customer = value
	case "signature":
		value := new(papisdkgo.SignatureAdjustment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Signature = value
	}
	return nil
}

func (p PaymentAdjustmentAdjustmentsItem) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Order != nil {
		return internal.MarshalJSONWithExtraProperty(p.Order, "type", "order")
	}
	if p.Status != nil {
		return internal.MarshalJSONWithExtraProperty(p.Status, "type", "status")
	}
	if p.Customer != nil {
		return internal.MarshalJSONWithExtraProperty(p.Customer, "type", "customer")
	}
	if p.Signature != nil {
		return internal.MarshalJSONWithExtraProperty(p.Signature, "type", "signature")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentAdjustmentAdjustmentsItemVisitor interface {
	VisitOrder(*papisdkgo.OrderAdjustment) error
	VisitStatus(*papisdkgo.StatusAdjustment) error
	VisitCustomer(*papisdkgo.CustomerAdjustment) error
	VisitSignature(*papisdkgo.SignatureAdjustment) error
}

func (p *PaymentAdjustmentAdjustmentsItem) Accept(visitor PaymentAdjustmentAdjustmentsItemVisitor) error {
	if p.Order != nil {
		return visitor.VisitOrder(p.Order)
	}
	if p.Status != nil {
		return visitor.VisitStatus(p.Status)
	}
	if p.Customer != nil {
		return visitor.VisitCustomer(p.Customer)
	}
	if p.Signature != nil {
		return visitor.VisitSignature(p.Signature)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentAdjustmentAdjustmentsItem) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Order != nil {
		fields = append(fields, "order")
	}
	if p.Status != nil {
		fields = append(fields, "status")
	}
	if p.Customer != nil {
		fields = append(fields, "customer")
	}
	if p.Signature != nil {
		fields = append(fields, "signature")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

// Channel that the merchant used to receive the payment details.
type PaymentRequestChannel string

const (
	PaymentRequestChannelPos  PaymentRequestChannel = "pos"
	PaymentRequestChannelWeb  PaymentRequestChannel = "web"
	PaymentRequestChannelMoto PaymentRequestChannel = "moto"
)

func NewPaymentRequestChannelFromString(s string) (PaymentRequestChannel, error) {
	switch s {
	case "pos":
		return PaymentRequestChannelPos, nil
	case "web":
		return PaymentRequestChannelWeb, nil
	case "moto":
		return PaymentRequestChannelMoto, nil
	}
	var t PaymentRequestChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentRequestChannel) Ptr() *PaymentRequestChannel {
	return &p
}

// Polymorphic object that contains payment details.
//
// The value of the type parameter determines which variant you should use:
// -	`card` - Payment card details
// -	`secureToken` - Secure token details
// -	`digitalWallet` - Digital wallet details
// -	`singleUseToken` - Single-use token details
type PaymentRequestPaymentMethod struct {
	Type           string
	Card           *papisdkgo.CardPayload
	SecureToken    *papisdkgo.SecureTokenPayload
	DigitalWallet  *papisdkgo.DigitalWalletPayload
	SingleUseToken *papisdkgo.SingleUseTokenPayload
}

func (p *PaymentRequestPaymentMethod) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentRequestPaymentMethod) GetCard() *papisdkgo.CardPayload {
	if p == nil {
		return nil
	}
	return p.Card
}

func (p *PaymentRequestPaymentMethod) GetSecureToken() *papisdkgo.SecureTokenPayload {
	if p == nil {
		return nil
	}
	return p.SecureToken
}

func (p *PaymentRequestPaymentMethod) GetDigitalWallet() *papisdkgo.DigitalWalletPayload {
	if p == nil {
		return nil
	}
	return p.DigitalWallet
}

func (p *PaymentRequestPaymentMethod) GetSingleUseToken() *papisdkgo.SingleUseTokenPayload {
	if p == nil {
		return nil
	}
	return p.SingleUseToken
}

func (p *PaymentRequestPaymentMethod) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "card":
		value := new(papisdkgo.CardPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Card = value
	case "secureToken":
		value := new(papisdkgo.SecureTokenPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SecureToken = value
	case "digitalWallet":
		value := new(papisdkgo.DigitalWalletPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.DigitalWallet = value
	case "singleUseToken":
		value := new(papisdkgo.SingleUseTokenPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SingleUseToken = value
	}
	return nil
}

func (p PaymentRequestPaymentMethod) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Card != nil {
		return internal.MarshalJSONWithExtraProperty(p.Card, "type", "card")
	}
	if p.SecureToken != nil {
		return internal.MarshalJSONWithExtraProperty(p.SecureToken, "type", "secureToken")
	}
	if p.DigitalWallet != nil {
		return internal.MarshalJSONWithExtraProperty(p.DigitalWallet, "type", "digitalWallet")
	}
	if p.SingleUseToken != nil {
		return internal.MarshalJSONWithExtraProperty(p.SingleUseToken, "type", "singleUseToken")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentRequestPaymentMethodVisitor interface {
	VisitCard(*papisdkgo.CardPayload) error
	VisitSecureToken(*papisdkgo.SecureTokenPayload) error
	VisitDigitalWallet(*papisdkgo.DigitalWalletPayload) error
	VisitSingleUseToken(*papisdkgo.SingleUseTokenPayload) error
}

func (p *PaymentRequestPaymentMethod) Accept(visitor PaymentRequestPaymentMethodVisitor) error {
	if p.Card != nil {
		return visitor.VisitCard(p.Card)
	}
	if p.SecureToken != nil {
		return visitor.VisitSecureToken(p.SecureToken)
	}
	if p.DigitalWallet != nil {
		return visitor.VisitDigitalWallet(p.DigitalWallet)
	}
	if p.SingleUseToken != nil {
		return visitor.VisitSingleUseToken(p.SingleUseToken)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentRequestPaymentMethod) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Card != nil {
		fields = append(fields, "card")
	}
	if p.SecureToken != nil {
		fields = append(fields, "secureToken")
	}
	if p.DigitalWallet != nil {
		fields = append(fields, "digitalWallet")
	}
	if p.SingleUseToken != nil {
		fields = append(fields, "singleUseToken")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

// Polymorphic object that contains authentication information from 3-D Secure.
//
// The value of the serviceProvider parameter determines which variant you should use:
// -	`gateway` - Use our gateway to run a 3-D Secure check.
// -	`thirdParty` - Use a third party to run a 3-D Secure check.
type PaymentRequestThreeDSecure struct {
	ServiceProvider string
	Gateway         *papisdkgo.GatewayThreeDSecure
	ThirdParty      *papisdkgo.ThirdPartyThreeDSecure
}

func (p *PaymentRequestThreeDSecure) GetServiceProvider() string {
	if p == nil {
		return ""
	}
	return p.ServiceProvider
}

func (p *PaymentRequestThreeDSecure) GetGateway() *papisdkgo.GatewayThreeDSecure {
	if p == nil {
		return nil
	}
	return p.Gateway
}

func (p *PaymentRequestThreeDSecure) GetThirdParty() *papisdkgo.ThirdPartyThreeDSecure {
	if p == nil {
		return nil
	}
	return p.ThirdParty
}

func (p *PaymentRequestThreeDSecure) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ServiceProvider string `json:"serviceProvider"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.ServiceProvider = unmarshaler.ServiceProvider
	if unmarshaler.ServiceProvider == "" {
		return fmt.Errorf("%T did not include discriminant serviceProvider", p)
	}
	switch unmarshaler.ServiceProvider {
	case "gateway":
		value := new(papisdkgo.GatewayThreeDSecure)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Gateway = value
	case "thirdParty":
		value := new(papisdkgo.ThirdPartyThreeDSecure)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ThirdParty = value
	}
	return nil
}

func (p PaymentRequestThreeDSecure) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Gateway != nil {
		return internal.MarshalJSONWithExtraProperty(p.Gateway, "serviceProvider", "gateway")
	}
	if p.ThirdParty != nil {
		return internal.MarshalJSONWithExtraProperty(p.ThirdParty, "serviceProvider", "thirdParty")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentRequestThreeDSecureVisitor interface {
	VisitGateway(*papisdkgo.GatewayThreeDSecure) error
	VisitThirdParty(*papisdkgo.ThirdPartyThreeDSecure) error
}

func (p *PaymentRequestThreeDSecure) Accept(visitor PaymentRequestThreeDSecureVisitor) error {
	if p.Gateway != nil {
		return visitor.VisitGateway(p.Gateway)
	}
	if p.ThirdParty != nil {
		return visitor.VisitThirdParty(p.ThirdParty)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentRequestThreeDSecure) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Gateway != nil {
		fields = append(fields, "gateway")
	}
	if p.ThirdParty != nil {
		fields = append(fields, "thirdParty")
	}
	if len(fields) == 0 {
		if p.ServiceProvider != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.ServiceProvider)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.ServiceProvider != "" {
		field := fields[0]
		if p.ServiceProvider != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.ServiceProvider,
				p,
			)
		}
	}
	return nil
}
