// Code generated by Fern. DO NOT EDIT.

package cardpayments

import (
	json "encoding/json"
	fmt "fmt"
	papisdkgo "github.com/payroc/payroc-sdk-go"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	refundAdjustmentFieldIdempotencyKey = big.NewInt(1 << 0)
	refundAdjustmentFieldRefundId       = big.NewInt(1 << 1)
	refundAdjustmentFieldOperator       = big.NewInt(1 << 2)
	refundAdjustmentFieldAdjustments    = big.NewInt(1 << 3)
)

type RefundAdjustment struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that our gateway assigned to the refund.
	RefundId string `json:"-" url:"-"`
	// Operator who requested the adjustment to the refund.
	Operator *string `json:"operator,omitempty" url:"-"`
	// Array of objects that contain information about the adjustments to the refund.
	Adjustments []*RefundAdjustmentAdjustmentsItem `json:"adjustments,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RefundAdjustment) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundAdjustment) SetIdempotencyKey(idempotencyKey string) {
	r.IdempotencyKey = idempotencyKey
	r.require(refundAdjustmentFieldIdempotencyKey)
}

// SetRefundId sets the RefundId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundAdjustment) SetRefundId(refundId string) {
	r.RefundId = refundId
	r.require(refundAdjustmentFieldRefundId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundAdjustment) SetOperator(operator *string) {
	r.Operator = operator
	r.require(refundAdjustmentFieldOperator)
}

// SetAdjustments sets the Adjustments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundAdjustment) SetAdjustments(adjustments []*RefundAdjustmentAdjustmentsItem) {
	r.Adjustments = adjustments
	r.require(refundAdjustmentFieldAdjustments)
}

var (
	referencedRefundFieldIdempotencyKey = big.NewInt(1 << 0)
	referencedRefundFieldPaymentId      = big.NewInt(1 << 1)
	referencedRefundFieldOperator       = big.NewInt(1 << 2)
	referencedRefundFieldAmount         = big.NewInt(1 << 3)
	referencedRefundFieldDescription    = big.NewInt(1 << 4)
)

type ReferencedRefund struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier of the payment that the merchant wants to retrieve.
	PaymentId string `json:"-" url:"-"`
	// Operator who refunded the payment.
	Operator *string `json:"operator,omitempty" url:"-"`
	// Amount of the payment that the merchant wants to refund. The value is in the currency’s lowest denomination, for example, cents.
	Amount int64 `json:"amount" url:"-"`
	// Reason for the refund.
	Description string `json:"description" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *ReferencedRefund) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReferencedRefund) SetIdempotencyKey(idempotencyKey string) {
	r.IdempotencyKey = idempotencyKey
	r.require(referencedRefundFieldIdempotencyKey)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReferencedRefund) SetPaymentId(paymentId string) {
	r.PaymentId = paymentId
	r.require(referencedRefundFieldPaymentId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReferencedRefund) SetOperator(operator *string) {
	r.Operator = operator
	r.require(referencedRefundFieldOperator)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReferencedRefund) SetAmount(amount int64) {
	r.Amount = amount
	r.require(referencedRefundFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReferencedRefund) SetDescription(description string) {
	r.Description = description
	r.require(referencedRefundFieldDescription)
}

var (
	unreferencedRefundFieldIdempotencyKey       = big.NewInt(1 << 0)
	unreferencedRefundFieldChannel              = big.NewInt(1 << 1)
	unreferencedRefundFieldProcessingTerminalId = big.NewInt(1 << 2)
	unreferencedRefundFieldOperator             = big.NewInt(1 << 3)
	unreferencedRefundFieldOrder                = big.NewInt(1 << 4)
	unreferencedRefundFieldCustomer             = big.NewInt(1 << 5)
	unreferencedRefundFieldIpAddress            = big.NewInt(1 << 6)
	unreferencedRefundFieldRefundMethod         = big.NewInt(1 << 7)
	unreferencedRefundFieldCustomFields         = big.NewInt(1 << 8)
)

type UnreferencedRefund struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Channel that the merchant used to request the refund.
	Channel UnreferencedRefundChannel `json:"channel" url:"-"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"-"`
	// Operator who initiated the request.
	Operator  *string                `json:"operator,omitempty" url:"-"`
	Order     *papisdkgo.RefundOrder `json:"order,omitempty" url:"-"`
	Customer  *papisdkgo.Customer    `json:"customer,omitempty" url:"-"`
	IpAddress *papisdkgo.IpAddress   `json:"ipAddress,omitempty" url:"-"`
	// Object that contains information about how the merchant refunds the customer.
	RefundMethod *UnreferencedRefundRefundMethod `json:"refundMethod,omitempty" url:"-"`
	// Array of customField objects.
	CustomFields []*papisdkgo.CustomField `json:"customFields,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UnreferencedRefund) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetIdempotencyKey(idempotencyKey string) {
	u.IdempotencyKey = idempotencyKey
	u.require(unreferencedRefundFieldIdempotencyKey)
}

// SetChannel sets the Channel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetChannel(channel UnreferencedRefundChannel) {
	u.Channel = channel
	u.require(unreferencedRefundFieldChannel)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetProcessingTerminalId(processingTerminalId string) {
	u.ProcessingTerminalId = processingTerminalId
	u.require(unreferencedRefundFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetOperator(operator *string) {
	u.Operator = operator
	u.require(unreferencedRefundFieldOperator)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetOrder(order *papisdkgo.RefundOrder) {
	u.Order = order
	u.require(unreferencedRefundFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetCustomer(customer *papisdkgo.Customer) {
	u.Customer = customer
	u.require(unreferencedRefundFieldCustomer)
}

// SetIpAddress sets the IpAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetIpAddress(ipAddress *papisdkgo.IpAddress) {
	u.IpAddress = ipAddress
	u.require(unreferencedRefundFieldIpAddress)
}

// SetRefundMethod sets the RefundMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetRefundMethod(refundMethod *UnreferencedRefundRefundMethod) {
	u.RefundMethod = refundMethod
	u.require(unreferencedRefundFieldRefundMethod)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UnreferencedRefund) SetCustomFields(customFields []*papisdkgo.CustomField) {
	u.CustomFields = customFields
	u.require(unreferencedRefundFieldCustomFields)
}

var (
	listRefundsRequestFieldProcessingTerminalId = big.NewInt(1 << 0)
	listRefundsRequestFieldOrderId              = big.NewInt(1 << 1)
	listRefundsRequestFieldOperator             = big.NewInt(1 << 2)
	listRefundsRequestFieldCardholderName       = big.NewInt(1 << 3)
	listRefundsRequestFieldFirst6               = big.NewInt(1 << 4)
	listRefundsRequestFieldLast4                = big.NewInt(1 << 5)
	listRefundsRequestFieldTender               = big.NewInt(1 << 6)
	listRefundsRequestFieldStatus               = big.NewInt(1 << 7)
	listRefundsRequestFieldDateFrom             = big.NewInt(1 << 8)
	listRefundsRequestFieldDateTo               = big.NewInt(1 << 9)
	listRefundsRequestFieldSettlementState      = big.NewInt(1 << 10)
	listRefundsRequestFieldSettlementDate       = big.NewInt(1 << 11)
	listRefundsRequestFieldBefore               = big.NewInt(1 << 12)
	listRefundsRequestFieldAfter                = big.NewInt(1 << 13)
	listRefundsRequestFieldLimit                = big.NewInt(1 << 14)
)

type ListRefundsRequest struct {
	// Filter by terminal ID.
	ProcessingTerminalId *string `json:"-" url:"processingTerminalId,omitempty"`
	// Filter refunds by the unique identifier that the merchant assigned to the order.
	OrderId *string `json:"-" url:"orderId,omitempty"`
	// Filter refunds by the operator who initiated the request.
	Operator *string `json:"-" url:"operator,omitempty"`
	// Filter refunds by cardholder name.
	CardholderName *string `json:"-" url:"cardholderName,omitempty"`
	// Filter refunds by the first six digits of the card number.
	First6 *string `json:"-" url:"first6,omitempty"`
	// Filter refunds by the last four digits of the card number.
	Last4 *string `json:"-" url:"last4,omitempty"`
	// Filter by tender type.
	Tender *ListRefundsRequestTender `json:"-" url:"tender,omitempty"`
	// Filter refunds by the current status of the refund.
	Status []*ListRefundsRequestStatusItem `json:"-" url:"status,omitempty"`
	// Filter by refunds processed after a specific date. The date format follows the ISO 8601 standard.
	DateFrom *time.Time `json:"-" url:"dateFrom,omitempty"`
	// Filter by refunds processed before a specific date. The date format follows the ISO 8601 standard.
	DateTo *time.Time `json:"-" url:"dateTo,omitempty"`
	// Status of the settlement.
	SettlementState *ListRefundsRequestSettlementState `json:"-" url:"settlementState,omitempty"`
	// Date the transaction was settled.
	SettlementDate *time.Time `json:"-" url:"settlementDate,omitempty" format:"date"`
	// Return the previous page of results before the value that you specify.
	//
	// You can’t send the before parameter in the same request as the after parameter.
	Before *string `json:"-" url:"before,omitempty"`
	// Return the next page of results after the value that you specify.
	//
	// You can’t send the after parameter in the same request as the before parameter.
	After *string `json:"-" url:"after,omitempty"`
	// Limit the maximum number of results that we return for each page.
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListRefundsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetProcessingTerminalId(processingTerminalId *string) {
	l.ProcessingTerminalId = processingTerminalId
	l.require(listRefundsRequestFieldProcessingTerminalId)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetOrderId(orderId *string) {
	l.OrderId = orderId
	l.require(listRefundsRequestFieldOrderId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetOperator(operator *string) {
	l.Operator = operator
	l.require(listRefundsRequestFieldOperator)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetCardholderName(cardholderName *string) {
	l.CardholderName = cardholderName
	l.require(listRefundsRequestFieldCardholderName)
}

// SetFirst6 sets the First6 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetFirst6(first6 *string) {
	l.First6 = first6
	l.require(listRefundsRequestFieldFirst6)
}

// SetLast4 sets the Last4 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetLast4(last4 *string) {
	l.Last4 = last4
	l.require(listRefundsRequestFieldLast4)
}

// SetTender sets the Tender field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetTender(tender *ListRefundsRequestTender) {
	l.Tender = tender
	l.require(listRefundsRequestFieldTender)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetStatus(status []*ListRefundsRequestStatusItem) {
	l.Status = status
	l.require(listRefundsRequestFieldStatus)
}

// SetDateFrom sets the DateFrom field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetDateFrom(dateFrom *time.Time) {
	l.DateFrom = dateFrom
	l.require(listRefundsRequestFieldDateFrom)
}

// SetDateTo sets the DateTo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetDateTo(dateTo *time.Time) {
	l.DateTo = dateTo
	l.require(listRefundsRequestFieldDateTo)
}

// SetSettlementState sets the SettlementState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetSettlementState(settlementState *ListRefundsRequestSettlementState) {
	l.SettlementState = settlementState
	l.require(listRefundsRequestFieldSettlementState)
}

// SetSettlementDate sets the SettlementDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetSettlementDate(settlementDate *time.Time) {
	l.SettlementDate = settlementDate
	l.require(listRefundsRequestFieldSettlementDate)
}

// SetBefore sets the Before field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetBefore(before *string) {
	l.Before = before
	l.require(listRefundsRequestFieldBefore)
}

// SetAfter sets the After field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetAfter(after *string) {
	l.After = after
	l.require(listRefundsRequestFieldAfter)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListRefundsRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listRefundsRequestFieldLimit)
}

var (
	retrieveRefundsRequestFieldRefundId = big.NewInt(1 << 0)
)

type RetrieveRefundsRequest struct {
	// Unique identifier that our gateway assigned to the refund.
	RefundId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RetrieveRefundsRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRefundId sets the RefundId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrieveRefundsRequest) SetRefundId(refundId string) {
	r.RefundId = refundId
	r.require(retrieveRefundsRequestFieldRefundId)
}

var (
	paymentReversalFieldIdempotencyKey = big.NewInt(1 << 0)
	paymentReversalFieldPaymentId      = big.NewInt(1 << 1)
	paymentReversalFieldOperator       = big.NewInt(1 << 2)
	paymentReversalFieldAmount         = big.NewInt(1 << 3)
)

type PaymentReversal struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier of the payment that the merchant wants to retrieve.
	PaymentId string `json:"-" url:"-"`
	// Operator who reversed the payment.
	Operator *string `json:"operator,omitempty" url:"-"`
	// Amount of the payment that the merchant wants to reverse. The value is in the currency’s lowest denomination, for example, cents.
	// **Note:** If the merchant doesn’t send an amount, we reverse the total amount of the transaction.
	Amount *int64 `json:"amount,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PaymentReversal) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentReversal) SetIdempotencyKey(idempotencyKey string) {
	p.IdempotencyKey = idempotencyKey
	p.require(paymentReversalFieldIdempotencyKey)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentReversal) SetPaymentId(paymentId string) {
	p.PaymentId = paymentId
	p.require(paymentReversalFieldPaymentId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentReversal) SetOperator(operator *string) {
	p.Operator = operator
	p.require(paymentReversalFieldOperator)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentReversal) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentReversalFieldAmount)
}

var (
	reverseRefundRefundsRequestFieldIdempotencyKey = big.NewInt(1 << 0)
	reverseRefundRefundsRequestFieldRefundId       = big.NewInt(1 << 1)
)

type ReverseRefundRefundsRequest struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that our gateway assigned to the refund.
	RefundId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *ReverseRefundRefundsRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReverseRefundRefundsRequest) SetIdempotencyKey(idempotencyKey string) {
	r.IdempotencyKey = idempotencyKey
	r.require(reverseRefundRefundsRequestFieldIdempotencyKey)
}

// SetRefundId sets the RefundId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ReverseRefundRefundsRequest) SetRefundId(refundId string) {
	r.RefundId = refundId
	r.require(reverseRefundRefundsRequestFieldRefundId)
}

type ListRefundsRequestSettlementState string

const (
	ListRefundsRequestSettlementStateSettled   ListRefundsRequestSettlementState = "settled"
	ListRefundsRequestSettlementStateUnsettled ListRefundsRequestSettlementState = "unsettled"
)

func NewListRefundsRequestSettlementStateFromString(s string) (ListRefundsRequestSettlementState, error) {
	switch s {
	case "settled":
		return ListRefundsRequestSettlementStateSettled, nil
	case "unsettled":
		return ListRefundsRequestSettlementStateUnsettled, nil
	}
	var t ListRefundsRequestSettlementState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListRefundsRequestSettlementState) Ptr() *ListRefundsRequestSettlementState {
	return &l
}

type ListRefundsRequestStatusItem string

const (
	ListRefundsRequestStatusItemReady    ListRefundsRequestStatusItem = "ready"
	ListRefundsRequestStatusItemPending  ListRefundsRequestStatusItem = "pending"
	ListRefundsRequestStatusItemDeclined ListRefundsRequestStatusItem = "declined"
	ListRefundsRequestStatusItemComplete ListRefundsRequestStatusItem = "complete"
	ListRefundsRequestStatusItemReferral ListRefundsRequestStatusItem = "referral"
	ListRefundsRequestStatusItemPickup   ListRefundsRequestStatusItem = "pickup"
	ListRefundsRequestStatusItemReversal ListRefundsRequestStatusItem = "reversal"
	ListRefundsRequestStatusItemAdmin    ListRefundsRequestStatusItem = "admin"
	ListRefundsRequestStatusItemExpired  ListRefundsRequestStatusItem = "expired"
	ListRefundsRequestStatusItemAccepted ListRefundsRequestStatusItem = "accepted"
)

func NewListRefundsRequestStatusItemFromString(s string) (ListRefundsRequestStatusItem, error) {
	switch s {
	case "ready":
		return ListRefundsRequestStatusItemReady, nil
	case "pending":
		return ListRefundsRequestStatusItemPending, nil
	case "declined":
		return ListRefundsRequestStatusItemDeclined, nil
	case "complete":
		return ListRefundsRequestStatusItemComplete, nil
	case "referral":
		return ListRefundsRequestStatusItemReferral, nil
	case "pickup":
		return ListRefundsRequestStatusItemPickup, nil
	case "reversal":
		return ListRefundsRequestStatusItemReversal, nil
	case "admin":
		return ListRefundsRequestStatusItemAdmin, nil
	case "expired":
		return ListRefundsRequestStatusItemExpired, nil
	case "accepted":
		return ListRefundsRequestStatusItemAccepted, nil
	}
	var t ListRefundsRequestStatusItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListRefundsRequestStatusItem) Ptr() *ListRefundsRequestStatusItem {
	return &l
}

type ListRefundsRequestTender string

const (
	ListRefundsRequestTenderEbt         ListRefundsRequestTender = "ebt"
	ListRefundsRequestTenderCreditDebit ListRefundsRequestTender = "creditDebit"
)

func NewListRefundsRequestTenderFromString(s string) (ListRefundsRequestTender, error) {
	switch s {
	case "ebt":
		return ListRefundsRequestTenderEbt, nil
	case "creditDebit":
		return ListRefundsRequestTenderCreditDebit, nil
	}
	var t ListRefundsRequestTender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListRefundsRequestTender) Ptr() *ListRefundsRequestTender {
	return &l
}

type RefundAdjustmentAdjustmentsItem struct {
	Type     string
	Status   *papisdkgo.StatusAdjustment
	Customer *papisdkgo.CustomerAdjustment
}

func (r *RefundAdjustmentAdjustmentsItem) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RefundAdjustmentAdjustmentsItem) GetStatus() *papisdkgo.StatusAdjustment {
	if r == nil {
		return nil
	}
	return r.Status
}

func (r *RefundAdjustmentAdjustmentsItem) GetCustomer() *papisdkgo.CustomerAdjustment {
	if r == nil {
		return nil
	}
	return r.Customer
}

func (r *RefundAdjustmentAdjustmentsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "status":
		value := new(papisdkgo.StatusAdjustment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Status = value
	case "customer":
		value := new(papisdkgo.CustomerAdjustment)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Customer = value
	}
	return nil
}

func (r RefundAdjustmentAdjustmentsItem) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Status != nil {
		return internal.MarshalJSONWithExtraProperty(r.Status, "type", "status")
	}
	if r.Customer != nil {
		return internal.MarshalJSONWithExtraProperty(r.Customer, "type", "customer")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RefundAdjustmentAdjustmentsItemVisitor interface {
	VisitStatus(*papisdkgo.StatusAdjustment) error
	VisitCustomer(*papisdkgo.CustomerAdjustment) error
}

func (r *RefundAdjustmentAdjustmentsItem) Accept(visitor RefundAdjustmentAdjustmentsItemVisitor) error {
	if r.Status != nil {
		return visitor.VisitStatus(r.Status)
	}
	if r.Customer != nil {
		return visitor.VisitCustomer(r.Customer)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *RefundAdjustmentAdjustmentsItem) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Status != nil {
		fields = append(fields, "status")
	}
	if r.Customer != nil {
		fields = append(fields, "customer")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}

// Channel that the merchant used to request the refund.
type UnreferencedRefundChannel string

const (
	UnreferencedRefundChannelPos  UnreferencedRefundChannel = "pos"
	UnreferencedRefundChannelMoto UnreferencedRefundChannel = "moto"
)

func NewUnreferencedRefundChannelFromString(s string) (UnreferencedRefundChannel, error) {
	switch s {
	case "pos":
		return UnreferencedRefundChannelPos, nil
	case "moto":
		return UnreferencedRefundChannelMoto, nil
	}
	var t UnreferencedRefundChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UnreferencedRefundChannel) Ptr() *UnreferencedRefundChannel {
	return &u
}

// Object that contains information about how the merchant refunds the customer.
type UnreferencedRefundRefundMethod struct {
	Type        string
	Card        *papisdkgo.CardPayload
	SecureToken *papisdkgo.SecureTokenPayload
}

func (u *UnreferencedRefundRefundMethod) GetType() string {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UnreferencedRefundRefundMethod) GetCard() *papisdkgo.CardPayload {
	if u == nil {
		return nil
	}
	return u.Card
}

func (u *UnreferencedRefundRefundMethod) GetSecureToken() *papisdkgo.SecureTokenPayload {
	if u == nil {
		return nil
	}
	return u.SecureToken
}

func (u *UnreferencedRefundRefundMethod) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	u.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", u)
	}
	switch unmarshaler.Type {
	case "card":
		value := new(papisdkgo.CardPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.Card = value
	case "secureToken":
		value := new(papisdkgo.SecureTokenPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		u.SecureToken = value
	}
	return nil
}

func (u UnreferencedRefundRefundMethod) MarshalJSON() ([]byte, error) {
	if err := u.validate(); err != nil {
		return nil, err
	}
	if u.Card != nil {
		return internal.MarshalJSONWithExtraProperty(u.Card, "type", "card")
	}
	if u.SecureToken != nil {
		return internal.MarshalJSONWithExtraProperty(u.SecureToken, "type", "secureToken")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", u)
}

type UnreferencedRefundRefundMethodVisitor interface {
	VisitCard(*papisdkgo.CardPayload) error
	VisitSecureToken(*papisdkgo.SecureTokenPayload) error
}

func (u *UnreferencedRefundRefundMethod) Accept(visitor UnreferencedRefundRefundMethodVisitor) error {
	if u.Card != nil {
		return visitor.VisitCard(u.Card)
	}
	if u.SecureToken != nil {
		return visitor.VisitSecureToken(u.SecureToken)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", u)
}

func (u *UnreferencedRefundRefundMethod) validate() error {
	if u == nil {
		return fmt.Errorf("type %T is nil", u)
	}
	var fields []string
	if u.Card != nil {
		fields = append(fields, "card")
	}
	if u.SecureToken != nil {
		fields = append(fields, "secureToken")
	}
	if len(fields) == 0 {
		if u.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", u, u.Type)
		}
		return fmt.Errorf("type %T is empty", u)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", u, fields)
	}
	if u.Type != "" {
		field := fields[0]
		if u.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				u,
				u.Type,
				u,
			)
		}
	}
	return nil
}
