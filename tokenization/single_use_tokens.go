// Code generated by Fern. DO NOT EDIT.

package tokenization

import (
	json "encoding/json"
	fmt "fmt"
	papisdkgo "github.com/payroc/payroc-sdk-go"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
)

var (
	singleUseTokenRequestFieldIdempotencyKey       = big.NewInt(1 << 0)
	singleUseTokenRequestFieldProcessingTerminalId = big.NewInt(1 << 1)
	singleUseTokenRequestFieldChannel              = big.NewInt(1 << 2)
	singleUseTokenRequestFieldOperator             = big.NewInt(1 << 3)
	singleUseTokenRequestFieldSource               = big.NewInt(1 << 4)
)

type SingleUseTokenRequest struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that our gateway assigned to the terminal.
	ProcessingTerminalId string `json:"-" url:"-"`
	// Channel that the merchant used to receive the payment details.
	Channel SingleUseTokenRequestChannel `json:"channel" url:"-"`
	// Operator who initiated the request.
	Operator *string `json:"operator,omitempty" url:"-"`
	// Polymorphic object that contains the payment method to tokenize.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`pad` - Pre-authorized debit (PAD) details
	// -	`card` - Payment card details
	Source *SingleUseTokenRequestSource `json:"source" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SingleUseTokenRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenRequest) SetIdempotencyKey(idempotencyKey string) {
	s.IdempotencyKey = idempotencyKey
	s.require(singleUseTokenRequestFieldIdempotencyKey)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenRequest) SetProcessingTerminalId(processingTerminalId string) {
	s.ProcessingTerminalId = processingTerminalId
	s.require(singleUseTokenRequestFieldProcessingTerminalId)
}

// SetChannel sets the Channel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenRequest) SetChannel(channel SingleUseTokenRequestChannel) {
	s.Channel = channel
	s.require(singleUseTokenRequestFieldChannel)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenRequest) SetOperator(operator *string) {
	s.Operator = operator
	s.require(singleUseTokenRequestFieldOperator)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenRequest) SetSource(source *SingleUseTokenRequestSource) {
	s.Source = source
	s.require(singleUseTokenRequestFieldSource)
}

func (s *SingleUseTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUseTokenRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*s = SingleUseTokenRequest(body)
	return nil
}

func (s *SingleUseTokenRequest) MarshalJSON() ([]byte, error) {
	type embed SingleUseTokenRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

// Channel that the merchant used to receive the payment details.
type SingleUseTokenRequestChannel string

const (
	SingleUseTokenRequestChannelPos  SingleUseTokenRequestChannel = "pos"
	SingleUseTokenRequestChannelWeb  SingleUseTokenRequestChannel = "web"
	SingleUseTokenRequestChannelMoto SingleUseTokenRequestChannel = "moto"
)

func NewSingleUseTokenRequestChannelFromString(s string) (SingleUseTokenRequestChannel, error) {
	switch s {
	case "pos":
		return SingleUseTokenRequestChannelPos, nil
	case "web":
		return SingleUseTokenRequestChannelWeb, nil
	case "moto":
		return SingleUseTokenRequestChannelMoto, nil
	}
	var t SingleUseTokenRequestChannel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleUseTokenRequestChannel) Ptr() *SingleUseTokenRequestChannel {
	return &s
}

// Polymorphic object that contains the payment method to tokenize.
//
// The value of the type parameter determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`pad` - Pre-authorized debit (PAD) details
// -	`card` - Payment card details
type SingleUseTokenRequestSource struct {
	Type string
	Ach  *papisdkgo.AchPayload
	Pad  *papisdkgo.PadPayload
	Card *papisdkgo.CardPayload
}

func (s *SingleUseTokenRequestSource) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SingleUseTokenRequestSource) GetAch() *papisdkgo.AchPayload {
	if s == nil {
		return nil
	}
	return s.Ach
}

func (s *SingleUseTokenRequestSource) GetPad() *papisdkgo.PadPayload {
	if s == nil {
		return nil
	}
	return s.Pad
}

func (s *SingleUseTokenRequestSource) GetCard() *papisdkgo.CardPayload {
	if s == nil {
		return nil
	}
	return s.Card
}

func (s *SingleUseTokenRequestSource) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(papisdkgo.AchPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Ach = value
	case "pad":
		value := new(papisdkgo.PadPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Pad = value
	case "card":
		value := new(papisdkgo.CardPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Card = value
	}
	return nil
}

func (s SingleUseTokenRequestSource) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(s.Ach, "type", "ach")
	}
	if s.Pad != nil {
		return internal.MarshalJSONWithExtraProperty(s.Pad, "type", "pad")
	}
	if s.Card != nil {
		return internal.MarshalJSONWithExtraProperty(s.Card, "type", "card")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleUseTokenRequestSourceVisitor interface {
	VisitAch(*papisdkgo.AchPayload) error
	VisitPad(*papisdkgo.PadPayload) error
	VisitCard(*papisdkgo.CardPayload) error
}

func (s *SingleUseTokenRequestSource) Accept(visitor SingleUseTokenRequestSourceVisitor) error {
	if s.Ach != nil {
		return visitor.VisitAch(s.Ach)
	}
	if s.Pad != nil {
		return visitor.VisitPad(s.Pad)
	}
	if s.Card != nil {
		return visitor.VisitCard(s.Card)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleUseTokenRequestSource) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Ach != nil {
		fields = append(fields, "ach")
	}
	if s.Pad != nil {
		fields = append(fields, "pad")
	}
	if s.Card != nil {
		fields = append(fields, "card")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}
