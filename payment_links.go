// Code generated by Fern. DO NOT EDIT.

package payroc

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	createPaymentLinksRequestFieldIdempotencyKey       = big.NewInt(1 << 0)
	createPaymentLinksRequestFieldProcessingTerminalId = big.NewInt(1 << 1)
)

type CreatePaymentLinksRequest struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string                         `json:"-" url:"-"`
	Body                 *CreatePaymentLinksRequestBody `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreatePaymentLinksRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreatePaymentLinksRequest) SetIdempotencyKey(idempotencyKey string) {
	c.IdempotencyKey = idempotencyKey
	c.require(createPaymentLinksRequestFieldIdempotencyKey)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreatePaymentLinksRequest) SetProcessingTerminalId(processingTerminalId string) {
	c.ProcessingTerminalId = processingTerminalId
	c.require(createPaymentLinksRequestFieldProcessingTerminalId)
}

func (c *CreatePaymentLinksRequest) UnmarshalJSON(data []byte) error {
	body := new(CreatePaymentLinksRequestBody)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	c.Body = body
	return nil
}

func (c *CreatePaymentLinksRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.Body)
}

var (
	deactivatePaymentLinksRequestFieldPaymentLinkId = big.NewInt(1 << 0)
)

type DeactivatePaymentLinksRequest struct {
	// Unique identifier that we assigned to the payment link.
	PaymentLinkId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeactivatePaymentLinksRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetPaymentLinkId sets the PaymentLinkId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeactivatePaymentLinksRequest) SetPaymentLinkId(paymentLinkId string) {
	d.PaymentLinkId = paymentLinkId
	d.require(deactivatePaymentLinksRequestFieldPaymentLinkId)
}

var (
	listPaymentLinksRequestFieldProcessingTerminalId = big.NewInt(1 << 0)
	listPaymentLinksRequestFieldMerchantReference    = big.NewInt(1 << 1)
	listPaymentLinksRequestFieldLinkType             = big.NewInt(1 << 2)
	listPaymentLinksRequestFieldChargeType           = big.NewInt(1 << 3)
	listPaymentLinksRequestFieldStatus               = big.NewInt(1 << 4)
	listPaymentLinksRequestFieldRecipientName        = big.NewInt(1 << 5)
	listPaymentLinksRequestFieldRecipientEmail       = big.NewInt(1 << 6)
	listPaymentLinksRequestFieldCreatedOn            = big.NewInt(1 << 7)
	listPaymentLinksRequestFieldExpiresOn            = big.NewInt(1 << 8)
	listPaymentLinksRequestFieldBefore               = big.NewInt(1 << 9)
	listPaymentLinksRequestFieldAfter                = big.NewInt(1 << 10)
	listPaymentLinksRequestFieldLimit                = big.NewInt(1 << 11)
)

type ListPaymentLinksRequest struct {
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"-" url:"-"`
	// Filter results by the unique identifier that the merchant assigned to the payment link.
	MerchantReference *string `json:"-" url:"merchantReference,omitempty"`
	// Filter results by the type of link. Send a value of <code>singleUse</code> or <code>multiUse</code>.
	LinkType *ListPaymentLinksRequestLinkType `json:"-" url:"linkType,omitempty"`
	// Filter results by the user that entered the amount. Send one of the following values:
	// - <code>prompt</code> - Customer entered the amount.
	// - <code>preset</code> - Merchant entered the amount.
	ChargeType *ListPaymentLinksRequestChargeType `json:"-" url:"chargeType,omitempty"`
	// Filter results by the status of the payment link. Send a value of <code>active</code>, <code>completed</code>,<code>deactived</code>, or <code>expired</code>.
	Status *ListPaymentLinksRequestStatus `json:"-" url:"status,omitempty"`
	// Filter results by the customer's name.
	RecipientName *string `json:"-" url:"recipientName,omitempty"`
	// Filter results by the customer's email address.
	RecipientEmail *string `json:"-" url:"recipientEmail,omitempty"`
	// Filter results by the link's created date. Send a value in **YYYY-MM-DD** format.
	CreatedOn *time.Time `json:"-" url:"createdOn,omitempty" format:"date"`
	// Filter results by the link's expiry date. Send a value in **YYYY-MM-DD** format.
	ExpiresOn *time.Time `json:"-" url:"expiresOn,omitempty" format:"date"`
	// Return the previous page of results before the value that you specify.
	//
	// You can’t send the before parameter in the same request as the after parameter.
	Before *string `json:"-" url:"before,omitempty"`
	// Return the next page of results after the value that you specify.
	//
	// You can’t send the after parameter in the same request as the before parameter.
	After *string `json:"-" url:"after,omitempty"`
	// Limit the maximum number of results that we return for each page.
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListPaymentLinksRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetProcessingTerminalId(processingTerminalId string) {
	l.ProcessingTerminalId = processingTerminalId
	l.require(listPaymentLinksRequestFieldProcessingTerminalId)
}

// SetMerchantReference sets the MerchantReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetMerchantReference(merchantReference *string) {
	l.MerchantReference = merchantReference
	l.require(listPaymentLinksRequestFieldMerchantReference)
}

// SetLinkType sets the LinkType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetLinkType(linkType *ListPaymentLinksRequestLinkType) {
	l.LinkType = linkType
	l.require(listPaymentLinksRequestFieldLinkType)
}

// SetChargeType sets the ChargeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetChargeType(chargeType *ListPaymentLinksRequestChargeType) {
	l.ChargeType = chargeType
	l.require(listPaymentLinksRequestFieldChargeType)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetStatus(status *ListPaymentLinksRequestStatus) {
	l.Status = status
	l.require(listPaymentLinksRequestFieldStatus)
}

// SetRecipientName sets the RecipientName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetRecipientName(recipientName *string) {
	l.RecipientName = recipientName
	l.require(listPaymentLinksRequestFieldRecipientName)
}

// SetRecipientEmail sets the RecipientEmail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetRecipientEmail(recipientEmail *string) {
	l.RecipientEmail = recipientEmail
	l.require(listPaymentLinksRequestFieldRecipientEmail)
}

// SetCreatedOn sets the CreatedOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetCreatedOn(createdOn *time.Time) {
	l.CreatedOn = createdOn
	l.require(listPaymentLinksRequestFieldCreatedOn)
}

// SetExpiresOn sets the ExpiresOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetExpiresOn(expiresOn *time.Time) {
	l.ExpiresOn = expiresOn
	l.require(listPaymentLinksRequestFieldExpiresOn)
}

// SetBefore sets the Before field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetBefore(before *string) {
	l.Before = before
	l.require(listPaymentLinksRequestFieldBefore)
}

// SetAfter sets the After field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetAfter(after *string) {
	l.After = after
	l.require(listPaymentLinksRequestFieldAfter)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentLinksRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listPaymentLinksRequestFieldLimit)
}

var (
	partiallyUpdatePaymentLinksRequestFieldIdempotencyKey = big.NewInt(1 << 0)
	partiallyUpdatePaymentLinksRequestFieldPaymentLinkId  = big.NewInt(1 << 1)
)

type PartiallyUpdatePaymentLinksRequest struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that we assigned to the payment link.
	PaymentLinkId string       `json:"-" url:"-"`
	Body          PatchRequest `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PartiallyUpdatePaymentLinksRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyUpdatePaymentLinksRequest) SetIdempotencyKey(idempotencyKey string) {
	p.IdempotencyKey = idempotencyKey
	p.require(partiallyUpdatePaymentLinksRequestFieldIdempotencyKey)
}

// SetPaymentLinkId sets the PaymentLinkId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyUpdatePaymentLinksRequest) SetPaymentLinkId(paymentLinkId string) {
	p.PaymentLinkId = paymentLinkId
	p.require(partiallyUpdatePaymentLinksRequestFieldPaymentLinkId)
}

func (p *PartiallyUpdatePaymentLinksRequest) UnmarshalJSON(data []byte) error {
	var body PatchRequest
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	p.Body = body
	return nil
}

func (p *PartiallyUpdatePaymentLinksRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(p.Body)
}

var (
	retrievePaymentLinksRequestFieldPaymentLinkId = big.NewInt(1 << 0)
)

type RetrievePaymentLinksRequest struct {
	// Unique identifier that we assigned to the payment link.
	PaymentLinkId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RetrievePaymentLinksRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetPaymentLinkId sets the PaymentLinkId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievePaymentLinksRequest) SetPaymentLinkId(paymentLinkId string) {
	r.PaymentLinkId = paymentLinkId
	r.require(retrievePaymentLinksRequestFieldPaymentLinkId)
}

// Object that contains information about saving the customer’s payment details.
var (
	credentialOnFileFieldTokenize     = big.NewInt(1 << 0)
	credentialOnFileFieldMitAgreement = big.NewInt(1 << 1)
)

type CredentialOnFile struct {
	// Indicates if our gateway should tokenize the customer’s payment details as part of the transaction.
	Tokenize *bool `json:"tokenize,omitempty" url:"tokenize,omitempty"`
	// Indicates how the merchant can use the customer’s card details, as agreed by the customer:
	//
	// - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
	// - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don’t have a fixed duration and run until the customer cancels the agreement.
	// - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.
	//
	// **Note:** If you send a value for **mitAgreement**, you must send the **standingInstructions** object in the **paymentOrder** object.
	MitAgreement *CredentialOnFileMitAgreement `json:"mitAgreement,omitempty" url:"mitAgreement,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CredentialOnFile) GetTokenize() *bool {
	if c == nil {
		return nil
	}
	return c.Tokenize
}

func (c *CredentialOnFile) GetMitAgreement() *CredentialOnFileMitAgreement {
	if c == nil {
		return nil
	}
	return c.MitAgreement
}

func (c *CredentialOnFile) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialOnFile) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTokenize sets the Tokenize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CredentialOnFile) SetTokenize(tokenize *bool) {
	c.Tokenize = tokenize
	c.require(credentialOnFileFieldTokenize)
}

// SetMitAgreement sets the MitAgreement field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CredentialOnFile) SetMitAgreement(mitAgreement *CredentialOnFileMitAgreement) {
	c.MitAgreement = mitAgreement
	c.require(credentialOnFileFieldMitAgreement)
}

func (c *CredentialOnFile) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialOnFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialOnFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialOnFile) MarshalJSON() ([]byte, error) {
	type embed CredentialOnFile
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CredentialOnFile) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates how the merchant can use the customer’s card details, as agreed by the customer:
//
// - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
// - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don’t have a fixed duration and run until the customer cancels the agreement.
// - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.
//
// **Note:** If you send a value for **mitAgreement**, you must send the **standingInstructions** object in the **paymentOrder** object.
type CredentialOnFileMitAgreement string

const (
	CredentialOnFileMitAgreementUnscheduled CredentialOnFileMitAgreement = "unscheduled"
	CredentialOnFileMitAgreementRecurring   CredentialOnFileMitAgreement = "recurring"
	CredentialOnFileMitAgreementInstallment CredentialOnFileMitAgreement = "installment"
)

func NewCredentialOnFileMitAgreementFromString(s string) (CredentialOnFileMitAgreement, error) {
	switch s {
	case "unscheduled":
		return CredentialOnFileMitAgreementUnscheduled, nil
	case "recurring":
		return CredentialOnFileMitAgreementRecurring, nil
	case "installment":
		return CredentialOnFileMitAgreementInstallment, nil
	}
	var t CredentialOnFileMitAgreement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CredentialOnFileMitAgreement) Ptr() *CredentialOnFileMitAgreement {
	return &c
}

// Object that contains the information for the custom label.
var (
	customLabelFieldElement = big.NewInt(1 << 0)
	customLabelFieldLabel   = big.NewInt(1 << 1)
)

type CustomLabel struct {
	// Element that you want to provide a custom label for.
	Element *CustomLabelElement `json:"element,omitempty" url:"element,omitempty"`
	// Custom label to display on the element.
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomLabel) GetElement() *CustomLabelElement {
	if c == nil {
		return nil
	}
	return c.Element
}

func (c *CustomLabel) GetLabel() *string {
	if c == nil {
		return nil
	}
	return c.Label
}

func (c *CustomLabel) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomLabel) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetElement sets the Element field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomLabel) SetElement(element *CustomLabelElement) {
	c.Element = element
	c.require(customLabelFieldElement)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomLabel) SetLabel(label *string) {
	c.Label = label
	c.require(customLabelFieldLabel)
}

func (c *CustomLabel) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomLabel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomLabel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomLabel) MarshalJSON() ([]byte, error) {
	type embed CustomLabel
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CustomLabel) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Element that you want to provide a custom label for.
type CustomLabelElement string

const (
	CustomLabelElementPaymentButton CustomLabelElement = "paymentButton"
)

func NewCustomLabelElementFromString(s string) (CustomLabelElement, error) {
	switch s {
	case "paymentButton":
		return CustomLabelElementPaymentButton, nil
	}
	var t CustomLabelElement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomLabelElement) Ptr() *CustomLabelElement {
	return &c
}

// Object that contains information about a multi-use payment link.
var (
	multiUsePaymentLinkFieldPaymentLinkId     = big.NewInt(1 << 0)
	multiUsePaymentLinkFieldMerchantReference = big.NewInt(1 << 1)
	multiUsePaymentLinkFieldOrder             = big.NewInt(1 << 2)
	multiUsePaymentLinkFieldAuthType          = big.NewInt(1 << 3)
	multiUsePaymentLinkFieldPaymentMethods    = big.NewInt(1 << 4)
	multiUsePaymentLinkFieldCustomLabels      = big.NewInt(1 << 5)
	multiUsePaymentLinkFieldAssets            = big.NewInt(1 << 6)
	multiUsePaymentLinkFieldStatus            = big.NewInt(1 << 7)
	multiUsePaymentLinkFieldCreatedOn         = big.NewInt(1 << 8)
	multiUsePaymentLinkFieldExpiresOn         = big.NewInt(1 << 9)
	multiUsePaymentLinkFieldCredentialOnFile  = big.NewInt(1 << 10)
)

type MultiUsePaymentLink struct {
	// Unique identifier that we assigned to the payment link.
	PaymentLinkId *string `json:"paymentLinkId,omitempty" url:"paymentLinkId,omitempty"`
	// Unique identifier that the merchant assigned to the payment.
	MerchantReference string                    `json:"merchantReference" url:"merchantReference"`
	Order             *MultiUsePaymentLinkOrder `json:"order" url:"order"`
	// Type of transaction.
	AuthType MultiUsePaymentLinkAuthType `json:"authType" url:"authType"`
	// Payment methods that the merchant accepts.
	// **Note:** If a payment is a pre-authorization, the customer must pay by card.
	PaymentMethods []MultiUsePaymentLinkPaymentMethodsItem `json:"paymentMethods" url:"paymentMethods"`
	// Array of customLabel objects.
	// **Note:** You can change the label of the payment button only.
	CustomLabels []*CustomLabel     `json:"customLabels,omitempty" url:"customLabels,omitempty"`
	Assets       *PaymentLinkAssets `json:"assets,omitempty" url:"assets,omitempty"`
	// Status of the payment link. The value is one of the following:
	// - `active` - Payment link is active.
	// - `completed` - Customer has paid.
	// - `deactivated` - Merchant has deactivated the link.
	// - `expired` - Payment link has expired.
	Status *MultiUsePaymentLinkStatus `json:"status,omitempty" url:"status,omitempty"`
	// Date that the merchant created the link. The format of this value is **YYYY-MM-DD**.
	CreatedOn *time.Time `json:"createdOn,omitempty" url:"createdOn,omitempty" format:"date"`
	// Last date that the customer can use the payment link. The format of this value is **YYYY-MM-DD**.
	ExpiresOn        *time.Time        `json:"expiresOn,omitempty" url:"expiresOn,omitempty" format:"date"`
	CredentialOnFile *CredentialOnFile `json:"credentialOnFile,omitempty" url:"credentialOnFile,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultiUsePaymentLink) GetPaymentLinkId() *string {
	if m == nil {
		return nil
	}
	return m.PaymentLinkId
}

func (m *MultiUsePaymentLink) GetMerchantReference() string {
	if m == nil {
		return ""
	}
	return m.MerchantReference
}

func (m *MultiUsePaymentLink) GetOrder() *MultiUsePaymentLinkOrder {
	if m == nil {
		return nil
	}
	return m.Order
}

func (m *MultiUsePaymentLink) GetAuthType() MultiUsePaymentLinkAuthType {
	if m == nil {
		return ""
	}
	return m.AuthType
}

func (m *MultiUsePaymentLink) GetPaymentMethods() []MultiUsePaymentLinkPaymentMethodsItem {
	if m == nil {
		return nil
	}
	return m.PaymentMethods
}

func (m *MultiUsePaymentLink) GetCustomLabels() []*CustomLabel {
	if m == nil {
		return nil
	}
	return m.CustomLabels
}

func (m *MultiUsePaymentLink) GetAssets() *PaymentLinkAssets {
	if m == nil {
		return nil
	}
	return m.Assets
}

func (m *MultiUsePaymentLink) GetStatus() *MultiUsePaymentLinkStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *MultiUsePaymentLink) GetCreatedOn() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreatedOn
}

func (m *MultiUsePaymentLink) GetExpiresOn() *time.Time {
	if m == nil {
		return nil
	}
	return m.ExpiresOn
}

func (m *MultiUsePaymentLink) GetCredentialOnFile() *CredentialOnFile {
	if m == nil {
		return nil
	}
	return m.CredentialOnFile
}

func (m *MultiUsePaymentLink) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultiUsePaymentLink) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetPaymentLinkId sets the PaymentLinkId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetPaymentLinkId(paymentLinkId *string) {
	m.PaymentLinkId = paymentLinkId
	m.require(multiUsePaymentLinkFieldPaymentLinkId)
}

// SetMerchantReference sets the MerchantReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetMerchantReference(merchantReference string) {
	m.MerchantReference = merchantReference
	m.require(multiUsePaymentLinkFieldMerchantReference)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetOrder(order *MultiUsePaymentLinkOrder) {
	m.Order = order
	m.require(multiUsePaymentLinkFieldOrder)
}

// SetAuthType sets the AuthType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetAuthType(authType MultiUsePaymentLinkAuthType) {
	m.AuthType = authType
	m.require(multiUsePaymentLinkFieldAuthType)
}

// SetPaymentMethods sets the PaymentMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetPaymentMethods(paymentMethods []MultiUsePaymentLinkPaymentMethodsItem) {
	m.PaymentMethods = paymentMethods
	m.require(multiUsePaymentLinkFieldPaymentMethods)
}

// SetCustomLabels sets the CustomLabels field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetCustomLabels(customLabels []*CustomLabel) {
	m.CustomLabels = customLabels
	m.require(multiUsePaymentLinkFieldCustomLabels)
}

// SetAssets sets the Assets field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetAssets(assets *PaymentLinkAssets) {
	m.Assets = assets
	m.require(multiUsePaymentLinkFieldAssets)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetStatus(status *MultiUsePaymentLinkStatus) {
	m.Status = status
	m.require(multiUsePaymentLinkFieldStatus)
}

// SetCreatedOn sets the CreatedOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetCreatedOn(createdOn *time.Time) {
	m.CreatedOn = createdOn
	m.require(multiUsePaymentLinkFieldCreatedOn)
}

// SetExpiresOn sets the ExpiresOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetExpiresOn(expiresOn *time.Time) {
	m.ExpiresOn = expiresOn
	m.require(multiUsePaymentLinkFieldExpiresOn)
}

// SetCredentialOnFile sets the CredentialOnFile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLink) SetCredentialOnFile(credentialOnFile *CredentialOnFile) {
	m.CredentialOnFile = credentialOnFile
	m.require(multiUsePaymentLinkFieldCredentialOnFile)
}

func (m *MultiUsePaymentLink) UnmarshalJSON(data []byte) error {
	type embed MultiUsePaymentLink
	var unmarshaler = struct {
		embed
		CreatedOn *internal.Date `json:"createdOn,omitempty"`
		ExpiresOn *internal.Date `json:"expiresOn,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MultiUsePaymentLink(unmarshaler.embed)
	m.CreatedOn = unmarshaler.CreatedOn.TimePtr()
	m.ExpiresOn = unmarshaler.ExpiresOn.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultiUsePaymentLink) MarshalJSON() ([]byte, error) {
	type embed MultiUsePaymentLink
	var marshaler = struct {
		embed
		CreatedOn *internal.Date `json:"createdOn,omitempty"`
		ExpiresOn *internal.Date `json:"expiresOn,omitempty"`
	}{
		embed:     embed(*m),
		CreatedOn: internal.NewOptionalDate(m.CreatedOn),
		ExpiresOn: internal.NewOptionalDate(m.ExpiresOn),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MultiUsePaymentLink) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Type of transaction.
type MultiUsePaymentLinkAuthType string

const (
	MultiUsePaymentLinkAuthTypeSale             MultiUsePaymentLinkAuthType = "sale"
	MultiUsePaymentLinkAuthTypePreAuthorization MultiUsePaymentLinkAuthType = "preAuthorization"
)

func NewMultiUsePaymentLinkAuthTypeFromString(s string) (MultiUsePaymentLinkAuthType, error) {
	switch s {
	case "sale":
		return MultiUsePaymentLinkAuthTypeSale, nil
	case "preAuthorization":
		return MultiUsePaymentLinkAuthTypePreAuthorization, nil
	}
	var t MultiUsePaymentLinkAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MultiUsePaymentLinkAuthType) Ptr() *MultiUsePaymentLinkAuthType {
	return &m
}

// Object that contains information about the order.
var (
	multiUsePaymentLinkOrderFieldDescription = big.NewInt(1 << 0)
	multiUsePaymentLinkOrderFieldCharge      = big.NewInt(1 << 1)
)

type MultiUsePaymentLinkOrder struct {
	// A brief description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Polymorphic object that indicates who enters the amount for the payment link.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`prompt` - Customer enters the amount.
	// -	`preset` - Merchant sets the amount.
	Charge *MultiUsePaymentLinkOrderCharge `json:"charge" url:"charge"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultiUsePaymentLinkOrder) GetDescription() *string {
	if m == nil {
		return nil
	}
	return m.Description
}

func (m *MultiUsePaymentLinkOrder) GetCharge() *MultiUsePaymentLinkOrderCharge {
	if m == nil {
		return nil
	}
	return m.Charge
}

func (m *MultiUsePaymentLinkOrder) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultiUsePaymentLinkOrder) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLinkOrder) SetDescription(description *string) {
	m.Description = description
	m.require(multiUsePaymentLinkOrderFieldDescription)
}

// SetCharge sets the Charge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultiUsePaymentLinkOrder) SetCharge(charge *MultiUsePaymentLinkOrderCharge) {
	m.Charge = charge
	m.require(multiUsePaymentLinkOrderFieldCharge)
}

func (m *MultiUsePaymentLinkOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler MultiUsePaymentLinkOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultiUsePaymentLinkOrder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultiUsePaymentLinkOrder) MarshalJSON() ([]byte, error) {
	type embed MultiUsePaymentLinkOrder
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MultiUsePaymentLinkOrder) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Polymorphic object that indicates who enters the amount for the payment link.
//
// The value of the type parameter determines which variant you should use:
// -	`prompt` - Customer enters the amount.
// -	`preset` - Merchant sets the amount.
type MultiUsePaymentLinkOrderCharge struct {
	Type   string
	Prompt *PromptPaymentLinkCharge
	Preset *PresetPaymentLinkCharge
}

func (m *MultiUsePaymentLinkOrderCharge) GetType() string {
	if m == nil {
		return ""
	}
	return m.Type
}

func (m *MultiUsePaymentLinkOrderCharge) GetPrompt() *PromptPaymentLinkCharge {
	if m == nil {
		return nil
	}
	return m.Prompt
}

func (m *MultiUsePaymentLinkOrderCharge) GetPreset() *PresetPaymentLinkCharge {
	if m == nil {
		return nil
	}
	return m.Preset
}

func (m *MultiUsePaymentLinkOrderCharge) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	m.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", m)
	}
	switch unmarshaler.Type {
	case "prompt":
		value := new(PromptPaymentLinkCharge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.Prompt = value
	case "preset":
		value := new(PresetPaymentLinkCharge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		m.Preset = value
	}
	return nil
}

func (m MultiUsePaymentLinkOrderCharge) MarshalJSON() ([]byte, error) {
	if err := m.validate(); err != nil {
		return nil, err
	}
	if m.Prompt != nil {
		return internal.MarshalJSONWithExtraProperty(m.Prompt, "type", "prompt")
	}
	if m.Preset != nil {
		return internal.MarshalJSONWithExtraProperty(m.Preset, "type", "preset")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", m)
}

type MultiUsePaymentLinkOrderChargeVisitor interface {
	VisitPrompt(*PromptPaymentLinkCharge) error
	VisitPreset(*PresetPaymentLinkCharge) error
}

func (m *MultiUsePaymentLinkOrderCharge) Accept(visitor MultiUsePaymentLinkOrderChargeVisitor) error {
	if m.Prompt != nil {
		return visitor.VisitPrompt(m.Prompt)
	}
	if m.Preset != nil {
		return visitor.VisitPreset(m.Preset)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", m)
}

func (m *MultiUsePaymentLinkOrderCharge) validate() error {
	if m == nil {
		return fmt.Errorf("type %T is nil", m)
	}
	var fields []string
	if m.Prompt != nil {
		fields = append(fields, "prompt")
	}
	if m.Preset != nil {
		fields = append(fields, "preset")
	}
	if len(fields) == 0 {
		if m.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", m, m.Type)
		}
		return fmt.Errorf("type %T is empty", m)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", m, fields)
	}
	if m.Type != "" {
		field := fields[0]
		if m.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				m,
				m.Type,
				m,
			)
		}
	}
	return nil
}

type MultiUsePaymentLinkPaymentMethodsItem string

const (
	MultiUsePaymentLinkPaymentMethodsItemCard         MultiUsePaymentLinkPaymentMethodsItem = "card"
	MultiUsePaymentLinkPaymentMethodsItemBankTransfer MultiUsePaymentLinkPaymentMethodsItem = "bankTransfer"
)

func NewMultiUsePaymentLinkPaymentMethodsItemFromString(s string) (MultiUsePaymentLinkPaymentMethodsItem, error) {
	switch s {
	case "card":
		return MultiUsePaymentLinkPaymentMethodsItemCard, nil
	case "bankTransfer":
		return MultiUsePaymentLinkPaymentMethodsItemBankTransfer, nil
	}
	var t MultiUsePaymentLinkPaymentMethodsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MultiUsePaymentLinkPaymentMethodsItem) Ptr() *MultiUsePaymentLinkPaymentMethodsItem {
	return &m
}

// Status of the payment link. The value is one of the following:
// - `active` - Payment link is active.
// - `completed` - Customer has paid.
// - `deactivated` - Merchant has deactivated the link.
// - `expired` - Payment link has expired.
type MultiUsePaymentLinkStatus string

const (
	MultiUsePaymentLinkStatusActive      MultiUsePaymentLinkStatus = "active"
	MultiUsePaymentLinkStatusCompleted   MultiUsePaymentLinkStatus = "completed"
	MultiUsePaymentLinkStatusDeactivated MultiUsePaymentLinkStatus = "deactivated"
	MultiUsePaymentLinkStatusExpired     MultiUsePaymentLinkStatus = "expired"
)

func NewMultiUsePaymentLinkStatusFromString(s string) (MultiUsePaymentLinkStatus, error) {
	switch s {
	case "active":
		return MultiUsePaymentLinkStatusActive, nil
	case "completed":
		return MultiUsePaymentLinkStatusCompleted, nil
	case "deactivated":
		return MultiUsePaymentLinkStatusDeactivated, nil
	case "expired":
		return MultiUsePaymentLinkStatusExpired, nil
	}
	var t MultiUsePaymentLinkStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MultiUsePaymentLinkStatus) Ptr() *MultiUsePaymentLinkStatus {
	return &m
}

// Object that contains shareable assets for the payment link.
var (
	paymentLinkAssetsFieldPaymentUrl    = big.NewInt(1 << 0)
	paymentLinkAssetsFieldPaymentButton = big.NewInt(1 << 1)
)

type PaymentLinkAssets struct {
	// URL of the payment link.
	PaymentUrl string `json:"paymentUrl" url:"paymentUrl"`
	// HTML code for the payment link. You can embed the HTML code in the merchant's website.
	PaymentButton string `json:"paymentButton" url:"paymentButton"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLinkAssets) GetPaymentUrl() string {
	if p == nil {
		return ""
	}
	return p.PaymentUrl
}

func (p *PaymentLinkAssets) GetPaymentButton() string {
	if p == nil {
		return ""
	}
	return p.PaymentButton
}

func (p *PaymentLinkAssets) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLinkAssets) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPaymentUrl sets the PaymentUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkAssets) SetPaymentUrl(paymentUrl string) {
	p.PaymentUrl = paymentUrl
	p.require(paymentLinkAssetsFieldPaymentUrl)
}

// SetPaymentButton sets the PaymentButton field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkAssets) SetPaymentButton(paymentButton string) {
	p.PaymentButton = paymentButton
	p.require(paymentLinkAssetsFieldPaymentButton)
}

func (p *PaymentLinkAssets) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLinkAssets
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLinkAssets(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLinkAssets) MarshalJSON() ([]byte, error) {
	type embed PaymentLinkAssets
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentLinkAssets) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentLinkPaginatedListFieldLimit   = big.NewInt(1 << 0)
	paymentLinkPaginatedListFieldCount   = big.NewInt(1 << 1)
	paymentLinkPaginatedListFieldHasMore = big.NewInt(1 << 2)
	paymentLinkPaginatedListFieldLinks   = big.NewInt(1 << 3)
	paymentLinkPaginatedListFieldData    = big.NewInt(1 << 4)
)

type PaymentLinkPaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of polymorphic objects that contains payment link information.
	//
	// The value of the type parameter determines which variant you should use:
	// -	'multiUse' - Create a link that the merchant can use to take multiple payments.
	// -	'singleUse' - Create a link that the merchant can use for only one payment.
	Data []*PaymentLinkPaginatedListDataItem `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLinkPaginatedList) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaymentLinkPaginatedList) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaymentLinkPaginatedList) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaymentLinkPaginatedList) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaymentLinkPaginatedList) GetData() []*PaymentLinkPaginatedListDataItem {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentLinkPaginatedList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLinkPaginatedList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkPaginatedList) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paymentLinkPaginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkPaginatedList) SetCount(count *int) {
	p.Count = count
	p.require(paymentLinkPaginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkPaginatedList) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paymentLinkPaginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkPaginatedList) SetLinks(links []*Link) {
	p.Links = links
	p.require(paymentLinkPaginatedListFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkPaginatedList) SetData(data []*PaymentLinkPaginatedListDataItem) {
	p.Data = data
	p.require(paymentLinkPaginatedListFieldData)
}

func (p *PaymentLinkPaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLinkPaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLinkPaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLinkPaginatedList) MarshalJSON() ([]byte, error) {
	type embed PaymentLinkPaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentLinkPaginatedList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentLinkPaginatedListDataItem struct {
	Type      string
	MultiUse  *MultiUsePaymentLink
	SingleUse *SingleUsePaymentLink
}

func (p *PaymentLinkPaginatedListDataItem) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentLinkPaginatedListDataItem) GetMultiUse() *MultiUsePaymentLink {
	if p == nil {
		return nil
	}
	return p.MultiUse
}

func (p *PaymentLinkPaginatedListDataItem) GetSingleUse() *SingleUsePaymentLink {
	if p == nil {
		return nil
	}
	return p.SingleUse
}

func (p *PaymentLinkPaginatedListDataItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "multiUse":
		value := new(MultiUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.MultiUse = value
	case "singleUse":
		value := new(SingleUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SingleUse = value
	}
	return nil
}

func (p PaymentLinkPaginatedListDataItem) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.MultiUse != nil {
		return internal.MarshalJSONWithExtraProperty(p.MultiUse, "type", "multiUse")
	}
	if p.SingleUse != nil {
		return internal.MarshalJSONWithExtraProperty(p.SingleUse, "type", "singleUse")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentLinkPaginatedListDataItemVisitor interface {
	VisitMultiUse(*MultiUsePaymentLink) error
	VisitSingleUse(*SingleUsePaymentLink) error
}

func (p *PaymentLinkPaginatedListDataItem) Accept(visitor PaymentLinkPaginatedListDataItemVisitor) error {
	if p.MultiUse != nil {
		return visitor.VisitMultiUse(p.MultiUse)
	}
	if p.SingleUse != nil {
		return visitor.VisitSingleUse(p.SingleUse)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentLinkPaginatedListDataItem) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.MultiUse != nil {
		fields = append(fields, "multiUse")
	}
	if p.SingleUse != nil {
		fields = append(fields, "singleUse")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

// Object that contains information about the charge when the merchant enters the amount of the transaction.
var (
	presetPaymentLinkChargeFieldAmount   = big.NewInt(1 << 0)
	presetPaymentLinkChargeFieldCurrency = big.NewInt(1 << 1)
)

type PresetPaymentLinkCharge struct {
	// Total amount of the transaction. The value is in the currency's lowest denomination, for example, cents.
	Amount   int64    `json:"amount" url:"amount"`
	Currency Currency `json:"currency" url:"currency"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PresetPaymentLinkCharge) GetAmount() int64 {
	if p == nil {
		return 0
	}
	return p.Amount
}

func (p *PresetPaymentLinkCharge) GetCurrency() Currency {
	if p == nil {
		return ""
	}
	return p.Currency
}

func (p *PresetPaymentLinkCharge) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PresetPaymentLinkCharge) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PresetPaymentLinkCharge) SetAmount(amount int64) {
	p.Amount = amount
	p.require(presetPaymentLinkChargeFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PresetPaymentLinkCharge) SetCurrency(currency Currency) {
	p.Currency = currency
	p.require(presetPaymentLinkChargeFieldCurrency)
}

func (p *PresetPaymentLinkCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler PresetPaymentLinkCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PresetPaymentLinkCharge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PresetPaymentLinkCharge) MarshalJSON() ([]byte, error) {
	type embed PresetPaymentLinkCharge
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PresetPaymentLinkCharge) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the charge when the customer enters the amount of the transaction.
var (
	promptPaymentLinkChargeFieldCurrency = big.NewInt(1 << 0)
)

type PromptPaymentLinkCharge struct {
	Currency Currency `json:"currency" url:"currency"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PromptPaymentLinkCharge) GetCurrency() Currency {
	if p == nil {
		return ""
	}
	return p.Currency
}

func (p *PromptPaymentLinkCharge) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PromptPaymentLinkCharge) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PromptPaymentLinkCharge) SetCurrency(currency Currency) {
	p.Currency = currency
	p.require(promptPaymentLinkChargeFieldCurrency)
}

func (p *PromptPaymentLinkCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler PromptPaymentLinkCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PromptPaymentLinkCharge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PromptPaymentLinkCharge) MarshalJSON() ([]byte, error) {
	type embed PromptPaymentLinkCharge
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PromptPaymentLinkCharge) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about a single-use payment link.
var (
	singleUsePaymentLinkFieldPaymentLinkId     = big.NewInt(1 << 0)
	singleUsePaymentLinkFieldMerchantReference = big.NewInt(1 << 1)
	singleUsePaymentLinkFieldOrder             = big.NewInt(1 << 2)
	singleUsePaymentLinkFieldAuthType          = big.NewInt(1 << 3)
	singleUsePaymentLinkFieldPaymentMethods    = big.NewInt(1 << 4)
	singleUsePaymentLinkFieldCustomLabels      = big.NewInt(1 << 5)
	singleUsePaymentLinkFieldAssets            = big.NewInt(1 << 6)
	singleUsePaymentLinkFieldStatus            = big.NewInt(1 << 7)
	singleUsePaymentLinkFieldCreatedOn         = big.NewInt(1 << 8)
	singleUsePaymentLinkFieldExpiresOn         = big.NewInt(1 << 9)
	singleUsePaymentLinkFieldCredentialOnFile  = big.NewInt(1 << 10)
)

type SingleUsePaymentLink struct {
	// Unique identifier that we assigned to the payment link.
	PaymentLinkId *string `json:"paymentLinkId,omitempty" url:"paymentLinkId,omitempty"`
	// Unique identifier that the merchant assigned to the payment.
	MerchantReference string                     `json:"merchantReference" url:"merchantReference"`
	Order             *SingleUsePaymentLinkOrder `json:"order" url:"order"`
	// Type of transaction.
	AuthType SingleUsePaymentLinkAuthType `json:"authType" url:"authType"`
	// Payment methods that the merchant accepts.
	// **Note:** If the payment is a pre-authorization, the customer must pay by card.
	PaymentMethods []SingleUsePaymentLinkPaymentMethodsItem `json:"paymentMethods" url:"paymentMethods"`
	// Array of customLabel objects.
	// **Note:** You can change the label of the payment button only.
	CustomLabels []*CustomLabel     `json:"customLabels,omitempty" url:"customLabels,omitempty"`
	Assets       *PaymentLinkAssets `json:"assets,omitempty" url:"assets,omitempty"`
	// Status of the payment link. The value is one of the following:
	// - `active` - Payment link is active.
	// - `completed` - Customer has paid.
	// - `deactivated` - Merchant has deactivated the link.
	// - `expired` - Payment link has expired.
	Status *SingleUsePaymentLinkStatus `json:"status,omitempty" url:"status,omitempty"`
	// Date that the merchant created the link. The format of this value is **YYYY-MM-DD**.
	CreatedOn *time.Time `json:"createdOn,omitempty" url:"createdOn,omitempty" format:"date"`
	// Last date that the customer can use the payment link. The format of this value is **YYYY-MM-DD**.
	ExpiresOn        time.Time         `json:"expiresOn" url:"expiresOn" format:"date"`
	CredentialOnFile *CredentialOnFile `json:"credentialOnFile,omitempty" url:"credentialOnFile,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleUsePaymentLink) GetPaymentLinkId() *string {
	if s == nil {
		return nil
	}
	return s.PaymentLinkId
}

func (s *SingleUsePaymentLink) GetMerchantReference() string {
	if s == nil {
		return ""
	}
	return s.MerchantReference
}

func (s *SingleUsePaymentLink) GetOrder() *SingleUsePaymentLinkOrder {
	if s == nil {
		return nil
	}
	return s.Order
}

func (s *SingleUsePaymentLink) GetAuthType() SingleUsePaymentLinkAuthType {
	if s == nil {
		return ""
	}
	return s.AuthType
}

func (s *SingleUsePaymentLink) GetPaymentMethods() []SingleUsePaymentLinkPaymentMethodsItem {
	if s == nil {
		return nil
	}
	return s.PaymentMethods
}

func (s *SingleUsePaymentLink) GetCustomLabels() []*CustomLabel {
	if s == nil {
		return nil
	}
	return s.CustomLabels
}

func (s *SingleUsePaymentLink) GetAssets() *PaymentLinkAssets {
	if s == nil {
		return nil
	}
	return s.Assets
}

func (s *SingleUsePaymentLink) GetStatus() *SingleUsePaymentLinkStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SingleUsePaymentLink) GetCreatedOn() *time.Time {
	if s == nil {
		return nil
	}
	return s.CreatedOn
}

func (s *SingleUsePaymentLink) GetExpiresOn() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.ExpiresOn
}

func (s *SingleUsePaymentLink) GetCredentialOnFile() *CredentialOnFile {
	if s == nil {
		return nil
	}
	return s.CredentialOnFile
}

func (s *SingleUsePaymentLink) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUsePaymentLink) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetPaymentLinkId sets the PaymentLinkId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetPaymentLinkId(paymentLinkId *string) {
	s.PaymentLinkId = paymentLinkId
	s.require(singleUsePaymentLinkFieldPaymentLinkId)
}

// SetMerchantReference sets the MerchantReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetMerchantReference(merchantReference string) {
	s.MerchantReference = merchantReference
	s.require(singleUsePaymentLinkFieldMerchantReference)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetOrder(order *SingleUsePaymentLinkOrder) {
	s.Order = order
	s.require(singleUsePaymentLinkFieldOrder)
}

// SetAuthType sets the AuthType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetAuthType(authType SingleUsePaymentLinkAuthType) {
	s.AuthType = authType
	s.require(singleUsePaymentLinkFieldAuthType)
}

// SetPaymentMethods sets the PaymentMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetPaymentMethods(paymentMethods []SingleUsePaymentLinkPaymentMethodsItem) {
	s.PaymentMethods = paymentMethods
	s.require(singleUsePaymentLinkFieldPaymentMethods)
}

// SetCustomLabels sets the CustomLabels field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetCustomLabels(customLabels []*CustomLabel) {
	s.CustomLabels = customLabels
	s.require(singleUsePaymentLinkFieldCustomLabels)
}

// SetAssets sets the Assets field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetAssets(assets *PaymentLinkAssets) {
	s.Assets = assets
	s.require(singleUsePaymentLinkFieldAssets)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetStatus(status *SingleUsePaymentLinkStatus) {
	s.Status = status
	s.require(singleUsePaymentLinkFieldStatus)
}

// SetCreatedOn sets the CreatedOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetCreatedOn(createdOn *time.Time) {
	s.CreatedOn = createdOn
	s.require(singleUsePaymentLinkFieldCreatedOn)
}

// SetExpiresOn sets the ExpiresOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetExpiresOn(expiresOn time.Time) {
	s.ExpiresOn = expiresOn
	s.require(singleUsePaymentLinkFieldExpiresOn)
}

// SetCredentialOnFile sets the CredentialOnFile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLink) SetCredentialOnFile(credentialOnFile *CredentialOnFile) {
	s.CredentialOnFile = credentialOnFile
	s.require(singleUsePaymentLinkFieldCredentialOnFile)
}

func (s *SingleUsePaymentLink) UnmarshalJSON(data []byte) error {
	type embed SingleUsePaymentLink
	var unmarshaler = struct {
		embed
		CreatedOn *internal.Date `json:"createdOn,omitempty"`
		ExpiresOn *internal.Date `json:"expiresOn"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SingleUsePaymentLink(unmarshaler.embed)
	s.CreatedOn = unmarshaler.CreatedOn.TimePtr()
	s.ExpiresOn = unmarshaler.ExpiresOn.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUsePaymentLink) MarshalJSON() ([]byte, error) {
	type embed SingleUsePaymentLink
	var marshaler = struct {
		embed
		CreatedOn *internal.Date `json:"createdOn,omitempty"`
		ExpiresOn *internal.Date `json:"expiresOn"`
	}{
		embed:     embed(*s),
		CreatedOn: internal.NewOptionalDate(s.CreatedOn),
		ExpiresOn: internal.NewDate(s.ExpiresOn),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleUsePaymentLink) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Type of transaction.
type SingleUsePaymentLinkAuthType string

const (
	SingleUsePaymentLinkAuthTypeSale             SingleUsePaymentLinkAuthType = "sale"
	SingleUsePaymentLinkAuthTypePreAuthorization SingleUsePaymentLinkAuthType = "preAuthorization"
)

func NewSingleUsePaymentLinkAuthTypeFromString(s string) (SingleUsePaymentLinkAuthType, error) {
	switch s {
	case "sale":
		return SingleUsePaymentLinkAuthTypeSale, nil
	case "preAuthorization":
		return SingleUsePaymentLinkAuthTypePreAuthorization, nil
	}
	var t SingleUsePaymentLinkAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleUsePaymentLinkAuthType) Ptr() *SingleUsePaymentLinkAuthType {
	return &s
}

// Object that contains information about the order.
var (
	singleUsePaymentLinkOrderFieldOrderId     = big.NewInt(1 << 0)
	singleUsePaymentLinkOrderFieldDescription = big.NewInt(1 << 1)
	singleUsePaymentLinkOrderFieldCharge      = big.NewInt(1 << 2)
)

type SingleUsePaymentLinkOrder struct {
	// Unique identifier that the merchant assigned to the order.
	OrderId string `json:"orderId" url:"orderId"`
	// A brief description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Polymorphic object that indicates who enters the amount for the payment link.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`prompt` - Customer enters the amount.
	// -	`preset` - Merchant sets the amount.
	Charge *SingleUsePaymentLinkOrderCharge `json:"charge" url:"charge"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleUsePaymentLinkOrder) GetOrderId() string {
	if s == nil {
		return ""
	}
	return s.OrderId
}

func (s *SingleUsePaymentLinkOrder) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SingleUsePaymentLinkOrder) GetCharge() *SingleUsePaymentLinkOrderCharge {
	if s == nil {
		return nil
	}
	return s.Charge
}

func (s *SingleUsePaymentLinkOrder) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUsePaymentLinkOrder) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLinkOrder) SetOrderId(orderId string) {
	s.OrderId = orderId
	s.require(singleUsePaymentLinkOrderFieldOrderId)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLinkOrder) SetDescription(description *string) {
	s.Description = description
	s.require(singleUsePaymentLinkOrderFieldDescription)
}

// SetCharge sets the Charge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUsePaymentLinkOrder) SetCharge(charge *SingleUsePaymentLinkOrderCharge) {
	s.Charge = charge
	s.require(singleUsePaymentLinkOrderFieldCharge)
}

func (s *SingleUsePaymentLinkOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUsePaymentLinkOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUsePaymentLinkOrder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUsePaymentLinkOrder) MarshalJSON() ([]byte, error) {
	type embed SingleUsePaymentLinkOrder
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleUsePaymentLinkOrder) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Polymorphic object that indicates who enters the amount for the payment link.
//
// The value of the type parameter determines which variant you should use:
// -	`prompt` - Customer enters the amount.
// -	`preset` - Merchant sets the amount.
type SingleUsePaymentLinkOrderCharge struct {
	Type   string
	Prompt *PromptPaymentLinkCharge
	Preset *PresetPaymentLinkCharge
}

func (s *SingleUsePaymentLinkOrderCharge) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SingleUsePaymentLinkOrderCharge) GetPrompt() *PromptPaymentLinkCharge {
	if s == nil {
		return nil
	}
	return s.Prompt
}

func (s *SingleUsePaymentLinkOrderCharge) GetPreset() *PresetPaymentLinkCharge {
	if s == nil {
		return nil
	}
	return s.Preset
}

func (s *SingleUsePaymentLinkOrderCharge) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "prompt":
		value := new(PromptPaymentLinkCharge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Prompt = value
	case "preset":
		value := new(PresetPaymentLinkCharge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Preset = value
	}
	return nil
}

func (s SingleUsePaymentLinkOrderCharge) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Prompt != nil {
		return internal.MarshalJSONWithExtraProperty(s.Prompt, "type", "prompt")
	}
	if s.Preset != nil {
		return internal.MarshalJSONWithExtraProperty(s.Preset, "type", "preset")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleUsePaymentLinkOrderChargeVisitor interface {
	VisitPrompt(*PromptPaymentLinkCharge) error
	VisitPreset(*PresetPaymentLinkCharge) error
}

func (s *SingleUsePaymentLinkOrderCharge) Accept(visitor SingleUsePaymentLinkOrderChargeVisitor) error {
	if s.Prompt != nil {
		return visitor.VisitPrompt(s.Prompt)
	}
	if s.Preset != nil {
		return visitor.VisitPreset(s.Preset)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleUsePaymentLinkOrderCharge) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Prompt != nil {
		fields = append(fields, "prompt")
	}
	if s.Preset != nil {
		fields = append(fields, "preset")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

type SingleUsePaymentLinkPaymentMethodsItem string

const (
	SingleUsePaymentLinkPaymentMethodsItemCard         SingleUsePaymentLinkPaymentMethodsItem = "card"
	SingleUsePaymentLinkPaymentMethodsItemBankTransfer SingleUsePaymentLinkPaymentMethodsItem = "bankTransfer"
)

func NewSingleUsePaymentLinkPaymentMethodsItemFromString(s string) (SingleUsePaymentLinkPaymentMethodsItem, error) {
	switch s {
	case "card":
		return SingleUsePaymentLinkPaymentMethodsItemCard, nil
	case "bankTransfer":
		return SingleUsePaymentLinkPaymentMethodsItemBankTransfer, nil
	}
	var t SingleUsePaymentLinkPaymentMethodsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleUsePaymentLinkPaymentMethodsItem) Ptr() *SingleUsePaymentLinkPaymentMethodsItem {
	return &s
}

// Status of the payment link. The value is one of the following:
// - `active` - Payment link is active.
// - `completed` - Customer has paid.
// - `deactivated` - Merchant has deactivated the link.
// - `expired` - Payment link has expired.
type SingleUsePaymentLinkStatus string

const (
	SingleUsePaymentLinkStatusActive      SingleUsePaymentLinkStatus = "active"
	SingleUsePaymentLinkStatusCompleted   SingleUsePaymentLinkStatus = "completed"
	SingleUsePaymentLinkStatusDeactivated SingleUsePaymentLinkStatus = "deactivated"
	SingleUsePaymentLinkStatusExpired     SingleUsePaymentLinkStatus = "expired"
)

func NewSingleUsePaymentLinkStatusFromString(s string) (SingleUsePaymentLinkStatus, error) {
	switch s {
	case "active":
		return SingleUsePaymentLinkStatusActive, nil
	case "completed":
		return SingleUsePaymentLinkStatusCompleted, nil
	case "deactivated":
		return SingleUsePaymentLinkStatusDeactivated, nil
	case "expired":
		return SingleUsePaymentLinkStatusExpired, nil
	}
	var t SingleUsePaymentLinkStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleUsePaymentLinkStatus) Ptr() *SingleUsePaymentLinkStatus {
	return &s
}

type CreatePaymentLinksRequestBody struct {
	Type      string
	MultiUse  *MultiUsePaymentLink
	SingleUse *SingleUsePaymentLink
}

func (c *CreatePaymentLinksRequestBody) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CreatePaymentLinksRequestBody) GetMultiUse() *MultiUsePaymentLink {
	if c == nil {
		return nil
	}
	return c.MultiUse
}

func (c *CreatePaymentLinksRequestBody) GetSingleUse() *SingleUsePaymentLink {
	if c == nil {
		return nil
	}
	return c.SingleUse
}

func (c *CreatePaymentLinksRequestBody) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "multiUse":
		value := new(MultiUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.MultiUse = value
	case "singleUse":
		value := new(SingleUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.SingleUse = value
	}
	return nil
}

func (c CreatePaymentLinksRequestBody) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.MultiUse != nil {
		return internal.MarshalJSONWithExtraProperty(c.MultiUse, "type", "multiUse")
	}
	if c.SingleUse != nil {
		return internal.MarshalJSONWithExtraProperty(c.SingleUse, "type", "singleUse")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CreatePaymentLinksRequestBodyVisitor interface {
	VisitMultiUse(*MultiUsePaymentLink) error
	VisitSingleUse(*SingleUsePaymentLink) error
}

func (c *CreatePaymentLinksRequestBody) Accept(visitor CreatePaymentLinksRequestBodyVisitor) error {
	if c.MultiUse != nil {
		return visitor.VisitMultiUse(c.MultiUse)
	}
	if c.SingleUse != nil {
		return visitor.VisitSingleUse(c.SingleUse)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *CreatePaymentLinksRequestBody) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.MultiUse != nil {
		fields = append(fields, "multiUse")
	}
	if c.SingleUse != nil {
		fields = append(fields, "singleUse")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type CreatePaymentLinksResponse struct {
	Type      string
	MultiUse  *MultiUsePaymentLink
	SingleUse *SingleUsePaymentLink
}

func (c *CreatePaymentLinksResponse) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CreatePaymentLinksResponse) GetMultiUse() *MultiUsePaymentLink {
	if c == nil {
		return nil
	}
	return c.MultiUse
}

func (c *CreatePaymentLinksResponse) GetSingleUse() *SingleUsePaymentLink {
	if c == nil {
		return nil
	}
	return c.SingleUse
}

func (c *CreatePaymentLinksResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "multiUse":
		value := new(MultiUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.MultiUse = value
	case "singleUse":
		value := new(SingleUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.SingleUse = value
	}
	return nil
}

func (c CreatePaymentLinksResponse) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.MultiUse != nil {
		return internal.MarshalJSONWithExtraProperty(c.MultiUse, "type", "multiUse")
	}
	if c.SingleUse != nil {
		return internal.MarshalJSONWithExtraProperty(c.SingleUse, "type", "singleUse")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CreatePaymentLinksResponseVisitor interface {
	VisitMultiUse(*MultiUsePaymentLink) error
	VisitSingleUse(*SingleUsePaymentLink) error
}

func (c *CreatePaymentLinksResponse) Accept(visitor CreatePaymentLinksResponseVisitor) error {
	if c.MultiUse != nil {
		return visitor.VisitMultiUse(c.MultiUse)
	}
	if c.SingleUse != nil {
		return visitor.VisitSingleUse(c.SingleUse)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *CreatePaymentLinksResponse) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.MultiUse != nil {
		fields = append(fields, "multiUse")
	}
	if c.SingleUse != nil {
		fields = append(fields, "singleUse")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type DeactivatePaymentLinksResponse struct {
	Type      string
	MultiUse  *MultiUsePaymentLink
	SingleUse *SingleUsePaymentLink
}

func (d *DeactivatePaymentLinksResponse) GetType() string {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DeactivatePaymentLinksResponse) GetMultiUse() *MultiUsePaymentLink {
	if d == nil {
		return nil
	}
	return d.MultiUse
}

func (d *DeactivatePaymentLinksResponse) GetSingleUse() *SingleUsePaymentLink {
	if d == nil {
		return nil
	}
	return d.SingleUse
}

func (d *DeactivatePaymentLinksResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", d)
	}
	switch unmarshaler.Type {
	case "multiUse":
		value := new(MultiUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.MultiUse = value
	case "singleUse":
		value := new(SingleUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.SingleUse = value
	}
	return nil
}

func (d DeactivatePaymentLinksResponse) MarshalJSON() ([]byte, error) {
	if err := d.validate(); err != nil {
		return nil, err
	}
	if d.MultiUse != nil {
		return internal.MarshalJSONWithExtraProperty(d.MultiUse, "type", "multiUse")
	}
	if d.SingleUse != nil {
		return internal.MarshalJSONWithExtraProperty(d.SingleUse, "type", "singleUse")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DeactivatePaymentLinksResponseVisitor interface {
	VisitMultiUse(*MultiUsePaymentLink) error
	VisitSingleUse(*SingleUsePaymentLink) error
}

func (d *DeactivatePaymentLinksResponse) Accept(visitor DeactivatePaymentLinksResponseVisitor) error {
	if d.MultiUse != nil {
		return visitor.VisitMultiUse(d.MultiUse)
	}
	if d.SingleUse != nil {
		return visitor.VisitSingleUse(d.SingleUse)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", d)
}

func (d *DeactivatePaymentLinksResponse) validate() error {
	if d == nil {
		return fmt.Errorf("type %T is nil", d)
	}
	var fields []string
	if d.MultiUse != nil {
		fields = append(fields, "multiUse")
	}
	if d.SingleUse != nil {
		fields = append(fields, "singleUse")
	}
	if len(fields) == 0 {
		if d.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", d, d.Type)
		}
		return fmt.Errorf("type %T is empty", d)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", d, fields)
	}
	if d.Type != "" {
		field := fields[0]
		if d.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				d,
				d.Type,
				d,
			)
		}
	}
	return nil
}

type ListPaymentLinksRequestChargeType string

const (
	ListPaymentLinksRequestChargeTypePreset ListPaymentLinksRequestChargeType = "preset"
	ListPaymentLinksRequestChargeTypePrompt ListPaymentLinksRequestChargeType = "prompt"
)

func NewListPaymentLinksRequestChargeTypeFromString(s string) (ListPaymentLinksRequestChargeType, error) {
	switch s {
	case "preset":
		return ListPaymentLinksRequestChargeTypePreset, nil
	case "prompt":
		return ListPaymentLinksRequestChargeTypePrompt, nil
	}
	var t ListPaymentLinksRequestChargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentLinksRequestChargeType) Ptr() *ListPaymentLinksRequestChargeType {
	return &l
}

type ListPaymentLinksRequestLinkType string

const (
	ListPaymentLinksRequestLinkTypeMultiUse  ListPaymentLinksRequestLinkType = "multiUse"
	ListPaymentLinksRequestLinkTypeSingleUse ListPaymentLinksRequestLinkType = "singleUse"
)

func NewListPaymentLinksRequestLinkTypeFromString(s string) (ListPaymentLinksRequestLinkType, error) {
	switch s {
	case "multiUse":
		return ListPaymentLinksRequestLinkTypeMultiUse, nil
	case "singleUse":
		return ListPaymentLinksRequestLinkTypeSingleUse, nil
	}
	var t ListPaymentLinksRequestLinkType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentLinksRequestLinkType) Ptr() *ListPaymentLinksRequestLinkType {
	return &l
}

type ListPaymentLinksRequestStatus string

const (
	ListPaymentLinksRequestStatusActive      ListPaymentLinksRequestStatus = "active"
	ListPaymentLinksRequestStatusCompleted   ListPaymentLinksRequestStatus = "completed"
	ListPaymentLinksRequestStatusDeactivated ListPaymentLinksRequestStatus = "deactivated"
	ListPaymentLinksRequestStatusExpired     ListPaymentLinksRequestStatus = "expired"
)

func NewListPaymentLinksRequestStatusFromString(s string) (ListPaymentLinksRequestStatus, error) {
	switch s {
	case "active":
		return ListPaymentLinksRequestStatusActive, nil
	case "completed":
		return ListPaymentLinksRequestStatusCompleted, nil
	case "deactivated":
		return ListPaymentLinksRequestStatusDeactivated, nil
	case "expired":
		return ListPaymentLinksRequestStatusExpired, nil
	}
	var t ListPaymentLinksRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentLinksRequestStatus) Ptr() *ListPaymentLinksRequestStatus {
	return &l
}

type PartiallyUpdatePaymentLinksResponse struct {
	Type      string
	MultiUse  *MultiUsePaymentLink
	SingleUse *SingleUsePaymentLink
}

func (p *PartiallyUpdatePaymentLinksResponse) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PartiallyUpdatePaymentLinksResponse) GetMultiUse() *MultiUsePaymentLink {
	if p == nil {
		return nil
	}
	return p.MultiUse
}

func (p *PartiallyUpdatePaymentLinksResponse) GetSingleUse() *SingleUsePaymentLink {
	if p == nil {
		return nil
	}
	return p.SingleUse
}

func (p *PartiallyUpdatePaymentLinksResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "multiUse":
		value := new(MultiUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.MultiUse = value
	case "singleUse":
		value := new(SingleUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.SingleUse = value
	}
	return nil
}

func (p PartiallyUpdatePaymentLinksResponse) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.MultiUse != nil {
		return internal.MarshalJSONWithExtraProperty(p.MultiUse, "type", "multiUse")
	}
	if p.SingleUse != nil {
		return internal.MarshalJSONWithExtraProperty(p.SingleUse, "type", "singleUse")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PartiallyUpdatePaymentLinksResponseVisitor interface {
	VisitMultiUse(*MultiUsePaymentLink) error
	VisitSingleUse(*SingleUsePaymentLink) error
}

func (p *PartiallyUpdatePaymentLinksResponse) Accept(visitor PartiallyUpdatePaymentLinksResponseVisitor) error {
	if p.MultiUse != nil {
		return visitor.VisitMultiUse(p.MultiUse)
	}
	if p.SingleUse != nil {
		return visitor.VisitSingleUse(p.SingleUse)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PartiallyUpdatePaymentLinksResponse) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.MultiUse != nil {
		fields = append(fields, "multiUse")
	}
	if p.SingleUse != nil {
		fields = append(fields, "singleUse")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type RetrievePaymentLinksResponse struct {
	Type      string
	MultiUse  *MultiUsePaymentLink
	SingleUse *SingleUsePaymentLink
}

func (r *RetrievePaymentLinksResponse) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RetrievePaymentLinksResponse) GetMultiUse() *MultiUsePaymentLink {
	if r == nil {
		return nil
	}
	return r.MultiUse
}

func (r *RetrievePaymentLinksResponse) GetSingleUse() *SingleUsePaymentLink {
	if r == nil {
		return nil
	}
	return r.SingleUse
}

func (r *RetrievePaymentLinksResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "multiUse":
		value := new(MultiUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.MultiUse = value
	case "singleUse":
		value := new(SingleUsePaymentLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.SingleUse = value
	}
	return nil
}

func (r RetrievePaymentLinksResponse) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.MultiUse != nil {
		return internal.MarshalJSONWithExtraProperty(r.MultiUse, "type", "multiUse")
	}
	if r.SingleUse != nil {
		return internal.MarshalJSONWithExtraProperty(r.SingleUse, "type", "singleUse")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RetrievePaymentLinksResponseVisitor interface {
	VisitMultiUse(*MultiUsePaymentLink) error
	VisitSingleUse(*SingleUsePaymentLink) error
}

func (r *RetrievePaymentLinksResponse) Accept(visitor RetrievePaymentLinksResponseVisitor) error {
	if r.MultiUse != nil {
		return visitor.VisitMultiUse(r.MultiUse)
	}
	if r.SingleUse != nil {
		return visitor.VisitSingleUse(r.SingleUse)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *RetrievePaymentLinksResponse) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.MultiUse != nil {
		fields = append(fields, "multiUse")
	}
	if r.SingleUse != nil {
		fields = append(fields, "singleUse")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}
