// Code generated by Fern. DO NOT EDIT.

package payroc

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
	time "time"
)

// Polymorphic object that contains information about the single-use token.
type AccountUpdate struct {
	Type           string
	SingleUseToken *SingleUseTokenAccountUpdate
}

func (a *AccountUpdate) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AccountUpdate) GetSingleUseToken() *SingleUseTokenAccountUpdate {
	if a == nil {
		return nil
	}
	return a.SingleUseToken
}

func (a *AccountUpdate) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "singleUseToken":
		value := new(SingleUseTokenAccountUpdate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.SingleUseToken = value
	}
	return nil
}

func (a AccountUpdate) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.SingleUseToken != nil {
		return internal.MarshalJSONWithExtraProperty(a.SingleUseToken, "type", "singleUseToken")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AccountUpdateVisitor interface {
	VisitSingleUseToken(*SingleUseTokenAccountUpdate) error
}

func (a *AccountUpdate) Accept(visitor AccountUpdateVisitor) error {
	if a.SingleUseToken != nil {
		return visitor.VisitSingleUseToken(a.SingleUseToken)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AccountUpdate) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.SingleUseToken != nil {
		fields = append(fields, "singleUseToken")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

// Object that contains the fees for ACH transactions.
var (
	achFieldFees = big.NewInt(1 << 0)
)

type Ach struct {
	// Object that contains processing fees for ACH transactions.
	Fees *AchFees `json:"fees,omitempty" url:"fees,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Ach) GetFees() *AchFees {
	if a == nil {
		return nil
	}
	return a.Fees
}

func (a *Ach) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Ach) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Ach) SetFees(fees *AchFees) {
	a.Fees = fees
	a.require(achFieldFees)
}

func (a *Ach) UnmarshalJSON(data []byte) error {
	type unmarshaler Ach
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Ach(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Ach) MarshalJSON() ([]byte, error) {
	type embed Ach
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Ach) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Object that contains the customer's account details.
var (
	achBankAccountFieldSecCode       = big.NewInt(1 << 0)
	achBankAccountFieldNameOnAccount = big.NewInt(1 << 1)
	achBankAccountFieldAccountNumber = big.NewInt(1 << 2)
	achBankAccountFieldRoutingNumber = big.NewInt(1 << 3)
	achBankAccountFieldSecureToken   = big.NewInt(1 << 4)
)

type AchBankAccount struct {
	// Indicates the type of authorization for the transaction.
	//
	// **Note:** The field is mandatory for ACH secure token.
	//
	// - `web` – Online transaction.
	// - `tel` – Telephone transaction.
	// - `ccd` – Corporate credit card or debit card transaction.
	// - `ppd` – Pre-arranged transaction.
	SecCode *AchBankAccountSecCode `json:"secCode,omitempty" url:"secCode,omitempty"`
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer's bank account number. We mask all digits except the last four digits.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Routing number of the customer’s account.
	//
	// **Note:** In responses, our gateway shows only the last four digits of the account's routing number, for example, *****4162.
	RoutingNumber string              `json:"routingNumber" url:"routingNumber"`
	SecureToken   *SecureTokenSummary `json:"secureToken,omitempty" url:"secureToken,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchBankAccount) GetSecCode() *AchBankAccountSecCode {
	if a == nil {
		return nil
	}
	return a.SecCode
}

func (a *AchBankAccount) GetNameOnAccount() string {
	if a == nil {
		return ""
	}
	return a.NameOnAccount
}

func (a *AchBankAccount) GetAccountNumber() string {
	if a == nil {
		return ""
	}
	return a.AccountNumber
}

func (a *AchBankAccount) GetRoutingNumber() string {
	if a == nil {
		return ""
	}
	return a.RoutingNumber
}

func (a *AchBankAccount) GetSecureToken() *SecureTokenSummary {
	if a == nil {
		return nil
	}
	return a.SecureToken
}

func (a *AchBankAccount) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchBankAccount) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetSecCode sets the SecCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchBankAccount) SetSecCode(secCode *AchBankAccountSecCode) {
	a.SecCode = secCode
	a.require(achBankAccountFieldSecCode)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchBankAccount) SetNameOnAccount(nameOnAccount string) {
	a.NameOnAccount = nameOnAccount
	a.require(achBankAccountFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchBankAccount) SetAccountNumber(accountNumber string) {
	a.AccountNumber = accountNumber
	a.require(achBankAccountFieldAccountNumber)
}

// SetRoutingNumber sets the RoutingNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchBankAccount) SetRoutingNumber(routingNumber string) {
	a.RoutingNumber = routingNumber
	a.require(achBankAccountFieldRoutingNumber)
}

// SetSecureToken sets the SecureToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchBankAccount) SetSecureToken(secureToken *SecureTokenSummary) {
	a.SecureToken = secureToken
	a.require(achBankAccountFieldSecureToken)
}

func (a *AchBankAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler AchBankAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchBankAccount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchBankAccount) MarshalJSON() ([]byte, error) {
	type embed AchBankAccount
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchBankAccount) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Indicates the type of authorization for the transaction.
//
// **Note:** The field is mandatory for ACH secure token.
//
// - `web` – Online transaction.
// - `tel` – Telephone transaction.
// - `ccd` – Corporate credit card or debit card transaction.
// - `ppd` – Pre-arranged transaction.
type AchBankAccountSecCode string

const (
	AchBankAccountSecCodeWeb AchBankAccountSecCode = "web"
	AchBankAccountSecCodeTel AchBankAccountSecCode = "tel"
	AchBankAccountSecCodeCcd AchBankAccountSecCode = "ccd"
	AchBankAccountSecCodePpd AchBankAccountSecCode = "ppd"
)

func NewAchBankAccountSecCodeFromString(s string) (AchBankAccountSecCode, error) {
	switch s {
	case "web":
		return AchBankAccountSecCodeWeb, nil
	case "tel":
		return AchBankAccountSecCodeTel, nil
	case "ccd":
		return AchBankAccountSecCodeCcd, nil
	case "ppd":
		return AchBankAccountSecCodePpd, nil
	}
	var t AchBankAccountSecCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AchBankAccountSecCode) Ptr() *AchBankAccountSecCode {
	return &a
}

// Object that contains information about the ACH deposit.
var (
	achDepositFieldAchDepositId    = big.NewInt(1 << 0)
	achDepositFieldAssociationDate = big.NewInt(1 << 1)
	achDepositFieldAchDate         = big.NewInt(1 << 2)
	achDepositFieldPaymentDate     = big.NewInt(1 << 3)
	achDepositFieldTransactions    = big.NewInt(1 << 4)
	achDepositFieldSales           = big.NewInt(1 << 5)
	achDepositFieldReturns         = big.NewInt(1 << 6)
	achDepositFieldDailyFees       = big.NewInt(1 << 7)
	achDepositFieldHeldSales       = big.NewInt(1 << 8)
	achDepositFieldAchAdjustment   = big.NewInt(1 << 9)
	achDepositFieldHoldback        = big.NewInt(1 << 10)
	achDepositFieldReserveRelease  = big.NewInt(1 << 11)
	achDepositFieldNetAmount       = big.NewInt(1 << 12)
	achDepositFieldMerchant        = big.NewInt(1 << 13)
	achDepositFieldLinks           = big.NewInt(1 << 14)
)

type AchDeposit struct {
	// Unique identifier that we assigned to the ACH deposit.
	AchDepositId *int `json:"achDepositId,omitempty" url:"achDepositId,omitempty"`
	// Date that we sent the transactions to the card brands for clearing. The format of this value is **YYYY-MM-DD**.
	AssociationDate *time.Time `json:"associationDate,omitempty" url:"associationDate,omitempty" format:"date"`
	// Date that we sent the ACH deposit. The format of this value is **YYYY-MM-DD**.
	AchDate *time.Time `json:"achDate,omitempty" url:"achDate,omitempty" format:"date"`
	// Date that the merchant received the ACH deposit. The format of this value is **YYYY-MM-DD**.
	PaymentDate *time.Time `json:"paymentDate,omitempty" url:"paymentDate,omitempty" format:"date"`
	// Number of transactions in the ACH deposit.
	Transactions *int `json:"transactions,omitempty" url:"transactions,omitempty"`
	// Amount of sales in the ACH deposit. We return the value in the currency's lowest denomination, for example, cents.
	Sales *int64 `json:"sales,omitempty" url:"sales,omitempty"`
	// Amount of returns in the ACH deposit. We return the value in the currency's lowest denomination, for example, cents.
	Returns *int64 `json:"returns,omitempty" url:"returns,omitempty"`
	// Amount of fees that were applied to the transactions in the ACH deposit. We return the value in the currency's lowest denomination, for example cents.
	DailyFees *int64 `json:"dailyFees,omitempty" url:"dailyFees,omitempty"`
	// Amount of funds that we held if the merchant was in full suspense. We return the value in the currency's lowest denomination, for example, cents.
	HeldSales *int64 `json:"heldSales,omitempty" url:"heldSales,omitempty"`
	// Amount of adjustments that we made to the ACH deposit. We return the value in the currency's lowest denomination, for example, cents.
	AchAdjustment *int64 `json:"achAdjustment,omitempty" url:"achAdjustment,omitempty"`
	// Amount of funds that we held as reserve from the ACH deposit. We return the value in the currency's lowest denomination, for example, cents.
	Holdback *int64 `json:"holdback,omitempty" url:"holdback,omitempty"`
	// Amount of funds that we released from holdback. We return the value in the currency's lowest denomination, for example, cents.
	ReserveRelease *int64 `json:"reserveRelease,omitempty" url:"reserveRelease,omitempty"`
	// Total amount that we paid the merchant after fees and adjustments. We return the value in the currency's lowest denomination, for example, cents.
	NetAmount *int64           `json:"netAmount,omitempty" url:"netAmount,omitempty"`
	Merchant  *MerchantSummary `json:"merchant,omitempty" url:"merchant,omitempty"`
	Links     []*Link          `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchDeposit) GetAchDepositId() *int {
	if a == nil {
		return nil
	}
	return a.AchDepositId
}

func (a *AchDeposit) GetAssociationDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.AssociationDate
}

func (a *AchDeposit) GetAchDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.AchDate
}

func (a *AchDeposit) GetPaymentDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.PaymentDate
}

func (a *AchDeposit) GetTransactions() *int {
	if a == nil {
		return nil
	}
	return a.Transactions
}

func (a *AchDeposit) GetSales() *int64 {
	if a == nil {
		return nil
	}
	return a.Sales
}

func (a *AchDeposit) GetReturns() *int64 {
	if a == nil {
		return nil
	}
	return a.Returns
}

func (a *AchDeposit) GetDailyFees() *int64 {
	if a == nil {
		return nil
	}
	return a.DailyFees
}

func (a *AchDeposit) GetHeldSales() *int64 {
	if a == nil {
		return nil
	}
	return a.HeldSales
}

func (a *AchDeposit) GetAchAdjustment() *int64 {
	if a == nil {
		return nil
	}
	return a.AchAdjustment
}

func (a *AchDeposit) GetHoldback() *int64 {
	if a == nil {
		return nil
	}
	return a.Holdback
}

func (a *AchDeposit) GetReserveRelease() *int64 {
	if a == nil {
		return nil
	}
	return a.ReserveRelease
}

func (a *AchDeposit) GetNetAmount() *int64 {
	if a == nil {
		return nil
	}
	return a.NetAmount
}

func (a *AchDeposit) GetMerchant() *MerchantSummary {
	if a == nil {
		return nil
	}
	return a.Merchant
}

func (a *AchDeposit) GetLinks() []*Link {
	if a == nil {
		return nil
	}
	return a.Links
}

func (a *AchDeposit) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchDeposit) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAchDepositId sets the AchDepositId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetAchDepositId(achDepositId *int) {
	a.AchDepositId = achDepositId
	a.require(achDepositFieldAchDepositId)
}

// SetAssociationDate sets the AssociationDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetAssociationDate(associationDate *time.Time) {
	a.AssociationDate = associationDate
	a.require(achDepositFieldAssociationDate)
}

// SetAchDate sets the AchDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetAchDate(achDate *time.Time) {
	a.AchDate = achDate
	a.require(achDepositFieldAchDate)
}

// SetPaymentDate sets the PaymentDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetPaymentDate(paymentDate *time.Time) {
	a.PaymentDate = paymentDate
	a.require(achDepositFieldPaymentDate)
}

// SetTransactions sets the Transactions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetTransactions(transactions *int) {
	a.Transactions = transactions
	a.require(achDepositFieldTransactions)
}

// SetSales sets the Sales field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetSales(sales *int64) {
	a.Sales = sales
	a.require(achDepositFieldSales)
}

// SetReturns sets the Returns field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetReturns(returns *int64) {
	a.Returns = returns
	a.require(achDepositFieldReturns)
}

// SetDailyFees sets the DailyFees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetDailyFees(dailyFees *int64) {
	a.DailyFees = dailyFees
	a.require(achDepositFieldDailyFees)
}

// SetHeldSales sets the HeldSales field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetHeldSales(heldSales *int64) {
	a.HeldSales = heldSales
	a.require(achDepositFieldHeldSales)
}

// SetAchAdjustment sets the AchAdjustment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetAchAdjustment(achAdjustment *int64) {
	a.AchAdjustment = achAdjustment
	a.require(achDepositFieldAchAdjustment)
}

// SetHoldback sets the Holdback field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetHoldback(holdback *int64) {
	a.Holdback = holdback
	a.require(achDepositFieldHoldback)
}

// SetReserveRelease sets the ReserveRelease field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetReserveRelease(reserveRelease *int64) {
	a.ReserveRelease = reserveRelease
	a.require(achDepositFieldReserveRelease)
}

// SetNetAmount sets the NetAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetNetAmount(netAmount *int64) {
	a.NetAmount = netAmount
	a.require(achDepositFieldNetAmount)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetMerchant(merchant *MerchantSummary) {
	a.Merchant = merchant
	a.require(achDepositFieldMerchant)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDeposit) SetLinks(links []*Link) {
	a.Links = links
	a.require(achDepositFieldLinks)
}

func (a *AchDeposit) UnmarshalJSON(data []byte) error {
	type embed AchDeposit
	var unmarshaler = struct {
		embed
		AssociationDate *internal.Date `json:"associationDate,omitempty"`
		AchDate         *internal.Date `json:"achDate,omitempty"`
		PaymentDate     *internal.Date `json:"paymentDate,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AchDeposit(unmarshaler.embed)
	a.AssociationDate = unmarshaler.AssociationDate.TimePtr()
	a.AchDate = unmarshaler.AchDate.TimePtr()
	a.PaymentDate = unmarshaler.PaymentDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchDeposit) MarshalJSON() ([]byte, error) {
	type embed AchDeposit
	var marshaler = struct {
		embed
		AssociationDate *internal.Date `json:"associationDate,omitempty"`
		AchDate         *internal.Date `json:"achDate,omitempty"`
		PaymentDate     *internal.Date `json:"paymentDate,omitempty"`
	}{
		embed:           embed(*a),
		AssociationDate: internal.NewOptionalDate(a.AssociationDate),
		AchDate:         internal.NewOptionalDate(a.AchDate),
		PaymentDate:     internal.NewOptionalDate(a.PaymentDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchDeposit) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Object that contains information about the ACH deposit fee.
var (
	achDepositFeeFieldAssociationDate = big.NewInt(1 << 0)
	achDepositFeeFieldAdjustmentDate  = big.NewInt(1 << 1)
	achDepositFeeFieldDescription     = big.NewInt(1 << 2)
	achDepositFeeFieldAmount          = big.NewInt(1 << 3)
	achDepositFeeFieldMerchant        = big.NewInt(1 << 4)
	achDepositFeeFieldAchDeposit      = big.NewInt(1 << 5)
)

type AchDepositFee struct {
	// Date that we sent the transaction to the cards brands for clearing. The format of this value is **YYYY-MM-DD**.
	AssociationDate *time.Time `json:"associationDate,omitempty" url:"associationDate,omitempty" format:"date"`
	// Date of the adjustment. The format of this value is **YYYY-MM-DD**.
	AdjustmentDate *time.Time `json:"adjustmentDate,omitempty" url:"adjustmentDate,omitempty" format:"date"`
	// Description of the ACH deposit fee.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total value of ACH deposit fee.
	Amount     *int               `json:"amount,omitempty" url:"amount,omitempty"`
	Merchant   *MerchantSummary   `json:"merchant,omitempty" url:"merchant,omitempty"`
	AchDeposit *AchDepositSummary `json:"achDeposit,omitempty" url:"achDeposit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchDepositFee) GetAssociationDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.AssociationDate
}

func (a *AchDepositFee) GetAdjustmentDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.AdjustmentDate
}

func (a *AchDepositFee) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *AchDepositFee) GetAmount() *int {
	if a == nil {
		return nil
	}
	return a.Amount
}

func (a *AchDepositFee) GetMerchant() *MerchantSummary {
	if a == nil {
		return nil
	}
	return a.Merchant
}

func (a *AchDepositFee) GetAchDeposit() *AchDepositSummary {
	if a == nil {
		return nil
	}
	return a.AchDeposit
}

func (a *AchDepositFee) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchDepositFee) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAssociationDate sets the AssociationDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositFee) SetAssociationDate(associationDate *time.Time) {
	a.AssociationDate = associationDate
	a.require(achDepositFeeFieldAssociationDate)
}

// SetAdjustmentDate sets the AdjustmentDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositFee) SetAdjustmentDate(adjustmentDate *time.Time) {
	a.AdjustmentDate = adjustmentDate
	a.require(achDepositFeeFieldAdjustmentDate)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositFee) SetDescription(description *string) {
	a.Description = description
	a.require(achDepositFeeFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositFee) SetAmount(amount *int) {
	a.Amount = amount
	a.require(achDepositFeeFieldAmount)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositFee) SetMerchant(merchant *MerchantSummary) {
	a.Merchant = merchant
	a.require(achDepositFeeFieldMerchant)
}

// SetAchDeposit sets the AchDeposit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositFee) SetAchDeposit(achDeposit *AchDepositSummary) {
	a.AchDeposit = achDeposit
	a.require(achDepositFeeFieldAchDeposit)
}

func (a *AchDepositFee) UnmarshalJSON(data []byte) error {
	type embed AchDepositFee
	var unmarshaler = struct {
		embed
		AssociationDate *internal.Date `json:"associationDate,omitempty"`
		AdjustmentDate  *internal.Date `json:"adjustmentDate,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AchDepositFee(unmarshaler.embed)
	a.AssociationDate = unmarshaler.AssociationDate.TimePtr()
	a.AdjustmentDate = unmarshaler.AdjustmentDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchDepositFee) MarshalJSON() ([]byte, error) {
	type embed AchDepositFee
	var marshaler = struct {
		embed
		AssociationDate *internal.Date `json:"associationDate,omitempty"`
		AdjustmentDate  *internal.Date `json:"adjustmentDate,omitempty"`
	}{
		embed:           embed(*a),
		AssociationDate: internal.NewOptionalDate(a.AssociationDate),
		AdjustmentDate:  internal.NewOptionalDate(a.AdjustmentDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchDepositFee) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Object that contains information about the ACH deposit.
var (
	achDepositSummaryFieldAchDepositId = big.NewInt(1 << 0)
	achDepositSummaryFieldLink         = big.NewInt(1 << 1)
)

type AchDepositSummary struct {
	// Unique identifier of the ACH deposit.
	AchDepositId *int  `json:"achDepositId,omitempty" url:"achDepositId,omitempty"`
	Link         *Link `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchDepositSummary) GetAchDepositId() *int {
	if a == nil {
		return nil
	}
	return a.AchDepositId
}

func (a *AchDepositSummary) GetLink() *Link {
	if a == nil {
		return nil
	}
	return a.Link
}

func (a *AchDepositSummary) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchDepositSummary) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAchDepositId sets the AchDepositId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositSummary) SetAchDepositId(achDepositId *int) {
	a.AchDepositId = achDepositId
	a.require(achDepositSummaryFieldAchDepositId)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchDepositSummary) SetLink(link *Link) {
	a.Link = link
	a.require(achDepositSummaryFieldLink)
}

func (a *AchDepositSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler AchDepositSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchDepositSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchDepositSummary) MarshalJSON() ([]byte, error) {
	type embed AchDepositSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchDepositSummary) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Object that contains processing fees for ACH transactions.
var (
	achFeesFieldTransaction            = big.NewInt(1 << 0)
	achFeesFieldBatch                  = big.NewInt(1 << 1)
	achFeesFieldReturns                = big.NewInt(1 << 2)
	achFeesFieldUnauthorizedReturn     = big.NewInt(1 << 3)
	achFeesFieldStatement              = big.NewInt(1 << 4)
	achFeesFieldMonthlyMinimum         = big.NewInt(1 << 5)
	achFeesFieldAccountVerification    = big.NewInt(1 << 6)
	achFeesFieldDiscountRateUnder10000 = big.NewInt(1 << 7)
	achFeesFieldDiscountRateAbove10000 = big.NewInt(1 << 8)
)

type AchFees struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction int `json:"transaction" url:"transaction"`
	// Fee for each batch. The value is in the currency's lowest denomination, for example, cents.
	Batch int `json:"batch" url:"batch"`
	// Fee for each return. The value is in the currency's lowest denomination, for example, cents.
	Returns int `json:"returns" url:"returns"`
	// Fee for each unauthorized return. The value is in the currency's lowest denomination, for example, cents.
	UnauthorizedReturn int `json:"unauthorizedReturn" url:"unauthorizedReturn"`
	// Fee for each statement. The value is in the currency's lowest denomination, for example, cents.
	Statement int `json:"statement" url:"statement"`
	// Minimum monthly value of transactions. The value is in the currency's lowest denomination, for example, cents.
	MonthlyMinimum int `json:"monthlyMinimum" url:"monthlyMinimum"`
	// Fee for each account verification. The value is in the currency's lowest denomination, for example, cents.
	AccountVerification int `json:"accountVerification" url:"accountVerification"`
	// Percentage discount for ACH transfers less than $10,000.
	DiscountRateUnder10000 Percentage `json:"discountRateUnder10000" url:"discountRateUnder10000"`
	// Percentage discount for ACH transfers equal to or more than $10,000.
	DiscountRateAbove10000 Percentage `json:"discountRateAbove10000" url:"discountRateAbove10000"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchFees) GetTransaction() int {
	if a == nil {
		return 0
	}
	return a.Transaction
}

func (a *AchFees) GetBatch() int {
	if a == nil {
		return 0
	}
	return a.Batch
}

func (a *AchFees) GetReturns() int {
	if a == nil {
		return 0
	}
	return a.Returns
}

func (a *AchFees) GetUnauthorizedReturn() int {
	if a == nil {
		return 0
	}
	return a.UnauthorizedReturn
}

func (a *AchFees) GetStatement() int {
	if a == nil {
		return 0
	}
	return a.Statement
}

func (a *AchFees) GetMonthlyMinimum() int {
	if a == nil {
		return 0
	}
	return a.MonthlyMinimum
}

func (a *AchFees) GetAccountVerification() int {
	if a == nil {
		return 0
	}
	return a.AccountVerification
}

func (a *AchFees) GetDiscountRateUnder10000() Percentage {
	if a == nil {
		return 0
	}
	return a.DiscountRateUnder10000
}

func (a *AchFees) GetDiscountRateAbove10000() Percentage {
	if a == nil {
		return 0
	}
	return a.DiscountRateAbove10000
}

func (a *AchFees) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchFees) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetTransaction(transaction int) {
	a.Transaction = transaction
	a.require(achFeesFieldTransaction)
}

// SetBatch sets the Batch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetBatch(batch int) {
	a.Batch = batch
	a.require(achFeesFieldBatch)
}

// SetReturns sets the Returns field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetReturns(returns int) {
	a.Returns = returns
	a.require(achFeesFieldReturns)
}

// SetUnauthorizedReturn sets the UnauthorizedReturn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetUnauthorizedReturn(unauthorizedReturn int) {
	a.UnauthorizedReturn = unauthorizedReturn
	a.require(achFeesFieldUnauthorizedReturn)
}

// SetStatement sets the Statement field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetStatement(statement int) {
	a.Statement = statement
	a.require(achFeesFieldStatement)
}

// SetMonthlyMinimum sets the MonthlyMinimum field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetMonthlyMinimum(monthlyMinimum int) {
	a.MonthlyMinimum = monthlyMinimum
	a.require(achFeesFieldMonthlyMinimum)
}

// SetAccountVerification sets the AccountVerification field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetAccountVerification(accountVerification int) {
	a.AccountVerification = accountVerification
	a.require(achFeesFieldAccountVerification)
}

// SetDiscountRateUnder10000 sets the DiscountRateUnder10000 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetDiscountRateUnder10000(discountRateUnder10000 Percentage) {
	a.DiscountRateUnder10000 = discountRateUnder10000
	a.require(achFeesFieldDiscountRateUnder10000)
}

// SetDiscountRateAbove10000 sets the DiscountRateAbove10000 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchFees) SetDiscountRateAbove10000(discountRateAbove10000 Percentage) {
	a.DiscountRateAbove10000 = discountRateAbove10000
	a.require(achFeesFieldDiscountRateAbove10000)
}

func (a *AchFees) UnmarshalJSON(data []byte) error {
	type unmarshaler AchFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchFees) MarshalJSON() ([]byte, error) {
	type embed AchFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchFees) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Object that contains information about the payment details for the customer’s automated clearing house (ACH) transactions.
var (
	achPayloadFieldAccountType   = big.NewInt(1 << 0)
	achPayloadFieldSecCode       = big.NewInt(1 << 1)
	achPayloadFieldNameOnAccount = big.NewInt(1 << 2)
	achPayloadFieldAccountNumber = big.NewInt(1 << 3)
	achPayloadFieldRoutingNumber = big.NewInt(1 << 4)
)

type AchPayload struct {
	// Indicates the customer’s account type.
	//
	// **Note:** For bank account details, send a value for accountType.
	AccountType *AchPayloadAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`
	// Indicates how the customer authorized the ACH transaction. Send one of the following values:
	//
	// - `web` – Online transaction.
	// - `tel` – Telephone transaction.
	// - `ccd` – Corporate credit card or debit card transaction.
	// - `ppd` – Pre-arranged transaction.
	SecCode *AchPayloadSecCode `json:"secCode,omitempty" url:"secCode,omitempty"`
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer’s bank account number.
	// **Note:** In responses, our gateway shows only the last four digits of the account number, for example, `*****5929`.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Nine-digit number that identifies the customer's bank.
	RoutingNumber string `json:"routingNumber" url:"routingNumber"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchPayload) GetAccountType() *AchPayloadAccountType {
	if a == nil {
		return nil
	}
	return a.AccountType
}

func (a *AchPayload) GetSecCode() *AchPayloadSecCode {
	if a == nil {
		return nil
	}
	return a.SecCode
}

func (a *AchPayload) GetNameOnAccount() string {
	if a == nil {
		return ""
	}
	return a.NameOnAccount
}

func (a *AchPayload) GetAccountNumber() string {
	if a == nil {
		return ""
	}
	return a.AccountNumber
}

func (a *AchPayload) GetRoutingNumber() string {
	if a == nil {
		return ""
	}
	return a.RoutingNumber
}

func (a *AchPayload) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchPayload) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchPayload) SetAccountType(accountType *AchPayloadAccountType) {
	a.AccountType = accountType
	a.require(achPayloadFieldAccountType)
}

// SetSecCode sets the SecCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchPayload) SetSecCode(secCode *AchPayloadSecCode) {
	a.SecCode = secCode
	a.require(achPayloadFieldSecCode)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchPayload) SetNameOnAccount(nameOnAccount string) {
	a.NameOnAccount = nameOnAccount
	a.require(achPayloadFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchPayload) SetAccountNumber(accountNumber string) {
	a.AccountNumber = accountNumber
	a.require(achPayloadFieldAccountNumber)
}

// SetRoutingNumber sets the RoutingNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchPayload) SetRoutingNumber(routingNumber string) {
	a.RoutingNumber = routingNumber
	a.require(achPayloadFieldRoutingNumber)
}

func (a *AchPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler AchPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchPayload) MarshalJSON() ([]byte, error) {
	type embed AchPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchPayload) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Indicates the customer’s account type.
//
// **Note:** For bank account details, send a value for accountType.
type AchPayloadAccountType string

const (
	AchPayloadAccountTypeChecking AchPayloadAccountType = "checking"
	AchPayloadAccountTypeSavings  AchPayloadAccountType = "savings"
)

func NewAchPayloadAccountTypeFromString(s string) (AchPayloadAccountType, error) {
	switch s {
	case "checking":
		return AchPayloadAccountTypeChecking, nil
	case "savings":
		return AchPayloadAccountTypeSavings, nil
	}
	var t AchPayloadAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AchPayloadAccountType) Ptr() *AchPayloadAccountType {
	return &a
}

// Indicates how the customer authorized the ACH transaction. Send one of the following values:
//
// - `web` – Online transaction.
// - `tel` – Telephone transaction.
// - `ccd` – Corporate credit card or debit card transaction.
// - `ppd` – Pre-arranged transaction.
type AchPayloadSecCode string

const (
	AchPayloadSecCodeWeb AchPayloadSecCode = "web"
	AchPayloadSecCodeTel AchPayloadSecCode = "tel"
	AchPayloadSecCodeCcd AchPayloadSecCode = "ccd"
	AchPayloadSecCodePpd AchPayloadSecCode = "ppd"
)

func NewAchPayloadSecCodeFromString(s string) (AchPayloadSecCode, error) {
	switch s {
	case "web":
		return AchPayloadSecCodeWeb, nil
	case "tel":
		return AchPayloadSecCodeTel, nil
	case "ccd":
		return AchPayloadSecCodeCcd, nil
	case "ppd":
		return AchPayloadSecCodePpd, nil
	}
	var t AchPayloadSecCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AchPayloadSecCode) Ptr() *AchPayloadSecCode {
	return &a
}

// Object that contains the customer's account details.
var (
	achSourceFieldNameOnAccount = big.NewInt(1 << 0)
	achSourceFieldAccountNumber = big.NewInt(1 << 1)
	achSourceFieldRoutingNumber = big.NewInt(1 << 2)
)

type AchSource struct {
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer's account number.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Routing number of the customer's account.
	RoutingNumber string `json:"routingNumber" url:"routingNumber"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchSource) GetNameOnAccount() string {
	if a == nil {
		return ""
	}
	return a.NameOnAccount
}

func (a *AchSource) GetAccountNumber() string {
	if a == nil {
		return ""
	}
	return a.AccountNumber
}

func (a *AchSource) GetRoutingNumber() string {
	if a == nil {
		return ""
	}
	return a.RoutingNumber
}

func (a *AchSource) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchSource) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchSource) SetNameOnAccount(nameOnAccount string) {
	a.NameOnAccount = nameOnAccount
	a.require(achSourceFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchSource) SetAccountNumber(accountNumber string) {
	a.AccountNumber = accountNumber
	a.require(achSourceFieldAccountNumber)
}

// SetRoutingNumber sets the RoutingNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchSource) SetRoutingNumber(routingNumber string) {
	a.RoutingNumber = routingNumber
	a.require(achSourceFieldRoutingNumber)
}

func (a *AchSource) UnmarshalJSON(data []byte) error {
	type unmarshaler AchSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchSource) MarshalJSON() ([]byte, error) {
	type embed AchSource
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchSource) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	achSourceWithAccountTypeFieldNameOnAccount = big.NewInt(1 << 0)
	achSourceWithAccountTypeFieldAccountNumber = big.NewInt(1 << 1)
	achSourceWithAccountTypeFieldRoutingNumber = big.NewInt(1 << 2)
	achSourceWithAccountTypeFieldAccountType   = big.NewInt(1 << 3)
)

type AchSourceWithAccountType struct {
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer's account number.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Routing number of the customer's account.
	RoutingNumber string `json:"routingNumber" url:"routingNumber"`
	// Indicates the customer's account type.
	AccountType *AchSourceWithAccountTypeAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AchSourceWithAccountType) GetNameOnAccount() string {
	if a == nil {
		return ""
	}
	return a.NameOnAccount
}

func (a *AchSourceWithAccountType) GetAccountNumber() string {
	if a == nil {
		return ""
	}
	return a.AccountNumber
}

func (a *AchSourceWithAccountType) GetRoutingNumber() string {
	if a == nil {
		return ""
	}
	return a.RoutingNumber
}

func (a *AchSourceWithAccountType) GetAccountType() *AchSourceWithAccountTypeAccountType {
	if a == nil {
		return nil
	}
	return a.AccountType
}

func (a *AchSourceWithAccountType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchSourceWithAccountType) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchSourceWithAccountType) SetNameOnAccount(nameOnAccount string) {
	a.NameOnAccount = nameOnAccount
	a.require(achSourceWithAccountTypeFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchSourceWithAccountType) SetAccountNumber(accountNumber string) {
	a.AccountNumber = accountNumber
	a.require(achSourceWithAccountTypeFieldAccountNumber)
}

// SetRoutingNumber sets the RoutingNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchSourceWithAccountType) SetRoutingNumber(routingNumber string) {
	a.RoutingNumber = routingNumber
	a.require(achSourceWithAccountTypeFieldRoutingNumber)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AchSourceWithAccountType) SetAccountType(accountType *AchSourceWithAccountTypeAccountType) {
	a.AccountType = accountType
	a.require(achSourceWithAccountTypeFieldAccountType)
}

func (a *AchSourceWithAccountType) UnmarshalJSON(data []byte) error {
	type unmarshaler AchSourceWithAccountType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchSourceWithAccountType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchSourceWithAccountType) MarshalJSON() ([]byte, error) {
	type embed AchSourceWithAccountType
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AchSourceWithAccountType) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Indicates the customer's account type.
type AchSourceWithAccountTypeAccountType string

const (
	AchSourceWithAccountTypeAccountTypeChecking AchSourceWithAccountTypeAccountType = "checking"
	AchSourceWithAccountTypeAccountTypeSavings  AchSourceWithAccountTypeAccountType = "savings"
)

func NewAchSourceWithAccountTypeAccountTypeFromString(s string) (AchSourceWithAccountTypeAccountType, error) {
	switch s {
	case "checking":
		return AchSourceWithAccountTypeAccountTypeChecking, nil
	case "savings":
		return AchSourceWithAccountTypeAccountTypeSavings, nil
	}
	var t AchSourceWithAccountTypeAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AchSourceWithAccountTypeAccountType) Ptr() *AchSourceWithAccountTypeAccountType {
	return &a
}

// Array of activityRecord objects.
var (
	activityRecordFieldId          = big.NewInt(1 << 0)
	activityRecordFieldDate        = big.NewInt(1 << 1)
	activityRecordFieldMerchant    = big.NewInt(1 << 2)
	activityRecordFieldRecipient   = big.NewInt(1 << 3)
	activityRecordFieldDescription = big.NewInt(1 << 4)
	activityRecordFieldAmount      = big.NewInt(1 << 5)
	activityRecordFieldType        = big.NewInt(1 << 6)
	activityRecordFieldCurrency    = big.NewInt(1 << 7)
)

type ActivityRecord struct {
	// Unique identifier that we assigned to the activity.
	Id int `json:"id" url:"id"`
	// Date that we moved the funds.
	Date string `json:"date" url:"date"`
	// Doing business as (DBA) name of the merchant that owns the funding balance.
	Merchant string `json:"merchant" url:"merchant"`
	// Name of the account holder who owns the funding account that received funds.
	//
	// **Note:** We return a value for recipient only if the value for type is `debit`.
	Recipient *string `json:"recipient,omitempty" url:"recipient,omitempty"`
	// Description of the activity.
	Description string `json:"description" url:"description"`
	// Total amount that we removed or added to the merchant's funding balance. The value is in the currency’s lowest denomination, for example, cents.
	Amount int64 `json:"amount" url:"amount"`
	// Indicates if we moved funds into or out of the funding balance. Our gateway returns one of the following values:
	// -	`credit` - We moved funds into the funding balance.
	// -	`debit` - We moved funds out of the funding balance.
	Type ActivityRecordType `json:"type" url:"type"`
	// Currency of the funds. We return a value of `USD`.
	Currency string `json:"currency" url:"currency"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActivityRecord) GetId() int {
	if a == nil {
		return 0
	}
	return a.Id
}

func (a *ActivityRecord) GetDate() string {
	if a == nil {
		return ""
	}
	return a.Date
}

func (a *ActivityRecord) GetMerchant() string {
	if a == nil {
		return ""
	}
	return a.Merchant
}

func (a *ActivityRecord) GetRecipient() *string {
	if a == nil {
		return nil
	}
	return a.Recipient
}

func (a *ActivityRecord) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActivityRecord) GetAmount() int64 {
	if a == nil {
		return 0
	}
	return a.Amount
}

func (a *ActivityRecord) GetType() ActivityRecordType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ActivityRecord) GetCurrency() string {
	if a == nil {
		return ""
	}
	return a.Currency
}

func (a *ActivityRecord) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActivityRecord) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetId(id int) {
	a.Id = id
	a.require(activityRecordFieldId)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetDate(date string) {
	a.Date = date
	a.require(activityRecordFieldDate)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetMerchant(merchant string) {
	a.Merchant = merchant
	a.require(activityRecordFieldMerchant)
}

// SetRecipient sets the Recipient field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetRecipient(recipient *string) {
	a.Recipient = recipient
	a.require(activityRecordFieldRecipient)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetDescription(description string) {
	a.Description = description
	a.require(activityRecordFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetAmount(amount int64) {
	a.Amount = amount
	a.require(activityRecordFieldAmount)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetType(type_ ActivityRecordType) {
	a.Type = type_
	a.require(activityRecordFieldType)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActivityRecord) SetCurrency(currency string) {
	a.Currency = currency
	a.require(activityRecordFieldCurrency)
}

func (a *ActivityRecord) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivityRecord
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivityRecord(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivityRecord) MarshalJSON() ([]byte, error) {
	type embed ActivityRecord
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActivityRecord) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Indicates if we moved funds into or out of the funding balance. Our gateway returns one of the following values:
// -	`credit` - We moved funds into the funding balance.
// -	`debit` - We moved funds out of the funding balance.
type ActivityRecordType string

const (
	ActivityRecordTypeCredit ActivityRecordType = "credit"
	ActivityRecordTypeDebit  ActivityRecordType = "debit"
)

func NewActivityRecordTypeFromString(s string) (ActivityRecordType, error) {
	switch s {
	case "credit":
		return ActivityRecordTypeCredit, nil
	case "debit":
		return ActivityRecordTypeDebit, nil
	}
	var t ActivityRecordType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActivityRecordType) Ptr() *ActivityRecordType {
	return &a
}

// Object that contains information about the address.
var (
	addressFieldAddress1   = big.NewInt(1 << 0)
	addressFieldAddress2   = big.NewInt(1 << 1)
	addressFieldAddress3   = big.NewInt(1 << 2)
	addressFieldCity       = big.NewInt(1 << 3)
	addressFieldState      = big.NewInt(1 << 4)
	addressFieldCountry    = big.NewInt(1 << 5)
	addressFieldPostalCode = big.NewInt(1 << 6)
)

type Address struct {
	// Address line 1.
	Address1 string `json:"address1" url:"address1"`
	// Address line 2.
	Address2 *string `json:"address2,omitempty" url:"address2,omitempty"`
	// Address line 3.
	Address3 *string `json:"address3,omitempty" url:"address3,omitempty"`
	// City.
	City string `json:"city" url:"city"`
	// Name of the state or state abbreviation.
	State string `json:"state" url:"state"`
	// Two-digit country code for the country that the business operates in. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
	Country string `json:"country" url:"country"`
	// Zip code or postal code.
	PostalCode string `json:"postalCode" url:"postalCode"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Address) GetAddress1() string {
	if a == nil {
		return ""
	}
	return a.Address1
}

func (a *Address) GetAddress2() *string {
	if a == nil {
		return nil
	}
	return a.Address2
}

func (a *Address) GetAddress3() *string {
	if a == nil {
		return nil
	}
	return a.Address3
}

func (a *Address) GetCity() string {
	if a == nil {
		return ""
	}
	return a.City
}

func (a *Address) GetState() string {
	if a == nil {
		return ""
	}
	return a.State
}

func (a *Address) GetCountry() string {
	if a == nil {
		return ""
	}
	return a.Country
}

func (a *Address) GetPostalCode() string {
	if a == nil {
		return ""
	}
	return a.PostalCode
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAddress1 sets the Address1 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Address) SetAddress1(address1 string) {
	a.Address1 = address1
	a.require(addressFieldAddress1)
}

// SetAddress2 sets the Address2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Address) SetAddress2(address2 *string) {
	a.Address2 = address2
	a.require(addressFieldAddress2)
}

// SetAddress3 sets the Address3 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Address) SetAddress3(address3 *string) {
	a.Address3 = address3
	a.require(addressFieldAddress3)
}

// SetCity sets the City field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Address) SetCity(city string) {
	a.City = city
	a.require(addressFieldCity)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Address) SetState(state string) {
	a.State = state
	a.require(addressFieldState)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Address) SetCountry(country string) {
	a.Country = country
	a.require(addressFieldCountry)
}

// SetPostalCode sets the PostalCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Address) SetPostalCode(postalCode string) {
	a.PostalCode = postalCode
	a.require(addressFieldPostalCode)
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) MarshalJSON() ([]byte, error) {
	type embed Address
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Address) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Type of address.
var (
	addressTypeFieldType = big.NewInt(1 << 0)
)

type AddressType struct {
	// Type of address.
	Type AddressTypeType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddressType) GetType() AddressTypeType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AddressType) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddressType) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AddressType) SetType(type_ AddressTypeType) {
	a.Type = type_
	a.require(addressTypeFieldType)
}

func (a *AddressType) UnmarshalJSON(data []byte) error {
	type unmarshaler AddressType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddressType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddressType) MarshalJSON() ([]byte, error) {
	type embed AddressType
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AddressType) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Type of address.
type AddressTypeType string

const (
	AddressTypeTypeLegalAddress AddressTypeType = "legalAddress"
)

func NewAddressTypeTypeFromString(s string) (AddressTypeType, error) {
	switch s {
	case "legalAddress":
		return AddressTypeTypeLegalAddress, nil
	}
	var t AddressTypeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AddressTypeType) Ptr() *AddressTypeType {
	return &a
}

type Amount = int

// Object that contains information about the authorization.
var (
	authorizationFieldAuthorizationId               = big.NewInt(1 << 0)
	authorizationFieldCreatedDate                   = big.NewInt(1 << 1)
	authorizationFieldLastModifiedDate              = big.NewInt(1 << 2)
	authorizationFieldAuthorizationResponse         = big.NewInt(1 << 3)
	authorizationFieldPreauthorizationRequestAmount = big.NewInt(1 << 4)
	authorizationFieldCurrency                      = big.NewInt(1 << 5)
	authorizationFieldBatch                         = big.NewInt(1 << 6)
	authorizationFieldCard                          = big.NewInt(1 << 7)
	authorizationFieldMerchant                      = big.NewInt(1 << 8)
	authorizationFieldTransaction                   = big.NewInt(1 << 9)
)

type Authorization struct {
	// Unique identifier that we assigned to the authorization.
	AuthorizationId *int `json:"authorizationId,omitempty" url:"authorizationId,omitempty"`
	// Date that we received the authorization. The format of this value is **YYYY-MM-DD**.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty" format:"date"`
	// Date that the authorization was last changed. The format of this value is **YYYY-MM-DD**.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty" format:"date"`
	// Response from the issuing bank for the authorization.
	AuthorizationResponse *AuthorizationAuthorizationResponse `json:"authorizationResponse,omitempty" url:"authorizationResponse,omitempty"`
	// Amount that the merchant requested for the authorization. We return the value in the currency's lowest denomination, for example, cents.
	PreauthorizationRequestAmount *int `json:"preauthorizationRequestAmount,omitempty" url:"preauthorizationRequestAmount,omitempty"`
	// Currency of the authorization. The value for the currency follows the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) standard.
	Currency    *string             `json:"currency,omitempty" url:"currency,omitempty"`
	Batch       *BatchSummary       `json:"batch,omitempty" url:"batch,omitempty"`
	Card        *CardSummary        `json:"card,omitempty" url:"card,omitempty"`
	Merchant    *MerchantSummary    `json:"merchant,omitempty" url:"merchant,omitempty"`
	Transaction *TransactionSummary `json:"transaction,omitempty" url:"transaction,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Authorization) GetAuthorizationId() *int {
	if a == nil {
		return nil
	}
	return a.AuthorizationId
}

func (a *Authorization) GetCreatedDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.CreatedDate
}

func (a *Authorization) GetLastModifiedDate() *time.Time {
	if a == nil {
		return nil
	}
	return a.LastModifiedDate
}

func (a *Authorization) GetAuthorizationResponse() *AuthorizationAuthorizationResponse {
	if a == nil {
		return nil
	}
	return a.AuthorizationResponse
}

func (a *Authorization) GetPreauthorizationRequestAmount() *int {
	if a == nil {
		return nil
	}
	return a.PreauthorizationRequestAmount
}

func (a *Authorization) GetCurrency() *string {
	if a == nil {
		return nil
	}
	return a.Currency
}

func (a *Authorization) GetBatch() *BatchSummary {
	if a == nil {
		return nil
	}
	return a.Batch
}

func (a *Authorization) GetCard() *CardSummary {
	if a == nil {
		return nil
	}
	return a.Card
}

func (a *Authorization) GetMerchant() *MerchantSummary {
	if a == nil {
		return nil
	}
	return a.Merchant
}

func (a *Authorization) GetTransaction() *TransactionSummary {
	if a == nil {
		return nil
	}
	return a.Transaction
}

func (a *Authorization) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Authorization) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAuthorizationId sets the AuthorizationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetAuthorizationId(authorizationId *int) {
	a.AuthorizationId = authorizationId
	a.require(authorizationFieldAuthorizationId)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetCreatedDate(createdDate *time.Time) {
	a.CreatedDate = createdDate
	a.require(authorizationFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetLastModifiedDate(lastModifiedDate *time.Time) {
	a.LastModifiedDate = lastModifiedDate
	a.require(authorizationFieldLastModifiedDate)
}

// SetAuthorizationResponse sets the AuthorizationResponse field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetAuthorizationResponse(authorizationResponse *AuthorizationAuthorizationResponse) {
	a.AuthorizationResponse = authorizationResponse
	a.require(authorizationFieldAuthorizationResponse)
}

// SetPreauthorizationRequestAmount sets the PreauthorizationRequestAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetPreauthorizationRequestAmount(preauthorizationRequestAmount *int) {
	a.PreauthorizationRequestAmount = preauthorizationRequestAmount
	a.require(authorizationFieldPreauthorizationRequestAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetCurrency(currency *string) {
	a.Currency = currency
	a.require(authorizationFieldCurrency)
}

// SetBatch sets the Batch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetBatch(batch *BatchSummary) {
	a.Batch = batch
	a.require(authorizationFieldBatch)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetCard(card *CardSummary) {
	a.Card = card
	a.require(authorizationFieldCard)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetMerchant(merchant *MerchantSummary) {
	a.Merchant = merchant
	a.require(authorizationFieldMerchant)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Authorization) SetTransaction(transaction *TransactionSummary) {
	a.Transaction = transaction
	a.require(authorizationFieldTransaction)
}

func (a *Authorization) UnmarshalJSON(data []byte) error {
	type embed Authorization
	var unmarshaler = struct {
		embed
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Authorization(unmarshaler.embed)
	a.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	a.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Authorization) MarshalJSON() ([]byte, error) {
	type embed Authorization
	var marshaler = struct {
		embed
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*a),
		CreatedDate:      internal.NewOptionalDate(a.CreatedDate),
		LastModifiedDate: internal.NewOptionalDate(a.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Authorization) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Response from the issuing bank for the authorization.
type AuthorizationAuthorizationResponse string

const (
	AuthorizationAuthorizationResponseActivityCountLimitExceeded              AuthorizationAuthorizationResponse = "activityCountLimitExceeded"
	AuthorizationAuthorizationResponseAlreadyReversed                         AuthorizationAuthorizationResponse = "alreadyReversed"
	AuthorizationAuthorizationResponseApproved                                AuthorizationAuthorizationResponse = "approved"
	AuthorizationAuthorizationResponseApproveVip                              AuthorizationAuthorizationResponse = "approveVip"
	AuthorizationAuthorizationResponseApproveWithId                           AuthorizationAuthorizationResponse = "approveWithId"
	AuthorizationAuthorizationResponseCannotVerifyPin                         AuthorizationAuthorizationResponse = "cannotVerifyPin"
	AuthorizationAuthorizationResponseCardAuthenticationFailed                AuthorizationAuthorizationResponse = "cardAuthenticationFailed"
	AuthorizationAuthorizationResponseCardTypeVerificationError               AuthorizationAuthorizationResponse = "cardTypeVerificationError"
	AuthorizationAuthorizationResponseCashRequestExceedsIssuerLimit           AuthorizationAuthorizationResponse = "cashRequestExceedsIssuerLimit"
	AuthorizationAuthorizationResponseCashServiceNotAvailable                 AuthorizationAuthorizationResponse = "cashServiceNotAvailable"
	AuthorizationAuthorizationResponseCidVerificationError                    AuthorizationAuthorizationResponse = "cidVerificationError"
	AuthorizationAuthorizationResponseContactCardIssuer                       AuthorizationAuthorizationResponse = "contactCardIssuer"
	AuthorizationAuthorizationResponseCryptographicFailure                    AuthorizationAuthorizationResponse = "cryptographicFailure"
	AuthorizationAuthorizationResponseDailyThresholdExceeded                  AuthorizationAuthorizationResponse = "dailyThresholdExceeded"
	AuthorizationAuthorizationResponseDeclineCvv2Failure                      AuthorizationAuthorizationResponse = "declineCvv2Failure"
	AuthorizationAuthorizationResponseDeny                                    AuthorizationAuthorizationResponse = "deny"
	AuthorizationAuthorizationResponseDenyAccountCanceled                     AuthorizationAuthorizationResponse = "denyAccountCanceled"
	AuthorizationAuthorizationResponseDenyClosedMerchant                      AuthorizationAuthorizationResponse = "denyClosedMerchant"
	AuthorizationAuthorizationResponseDenyNewCardIssued                       AuthorizationAuthorizationResponse = "denyNewCardIssued"
	AuthorizationAuthorizationResponseDenyPickUpCard                          AuthorizationAuthorizationResponse = "denyPickUpCard"
	AuthorizationAuthorizationResponseDestinationCannotBeFoundForRouting      AuthorizationAuthorizationResponse = "destinationCannotBeFoundForRouting"
	AuthorizationAuthorizationResponseDoNotHonor                              AuthorizationAuthorizationResponse = "doNotHonor"
	AuthorizationAuthorizationResponseDuplicateTransmissionDetected           AuthorizationAuthorizationResponse = "duplicateTransmissionDetected"
	AuthorizationAuthorizationResponseError                                   AuthorizationAuthorizationResponse = "error"
	AuthorizationAuthorizationResponseExceedsWithdrawalAmountLimit            AuthorizationAuthorizationResponse = "exceedsWithdrawalAmountLimit"
	AuthorizationAuthorizationResponseExpiredCard                             AuthorizationAuthorizationResponse = "expiredCard"
	AuthorizationAuthorizationResponseFileTemporarilyUnavailable              AuthorizationAuthorizationResponse = "fileTemporarilyUnavailable"
	AuthorizationAuthorizationResponseForceStip                               AuthorizationAuthorizationResponse = "forceStip"
	AuthorizationAuthorizationResponseFormatError                             AuthorizationAuthorizationResponse = "formatError"
	AuthorizationAuthorizationResponseForwardToIssuer                         AuthorizationAuthorizationResponse = "forwardToIssuer"
	AuthorizationAuthorizationResponseFunctionNotSupported                    AuthorizationAuthorizationResponse = "functionNotSupported"
	AuthorizationAuthorizationResponseHonorWithId                             AuthorizationAuthorizationResponse = "honorWithId"
	AuthorizationAuthorizationResponseIncorrectCvv                            AuthorizationAuthorizationResponse = "incorrectCvv"
	AuthorizationAuthorizationResponseIncorrectPin                            AuthorizationAuthorizationResponse = "incorrectPin"
	AuthorizationAuthorizationResponseIneligibleForResubmission               AuthorizationAuthorizationResponse = "ineligibleForResubmission"
	AuthorizationAuthorizationResponseInsufficientFunds                       AuthorizationAuthorizationResponse = "insufficientFunds"
	AuthorizationAuthorizationResponseInvalidAccount                          AuthorizationAuthorizationResponse = "invalidAccount"
	AuthorizationAuthorizationResponseInvalidAccountNumber                    AuthorizationAuthorizationResponse = "invalidAccountNumber"
	AuthorizationAuthorizationResponseInvalidAmount                           AuthorizationAuthorizationResponse = "invalidAmount"
	AuthorizationAuthorizationResponseInvalidAuthorizationLifeCycle           AuthorizationAuthorizationResponse = "invalidAuthorizationLifeCycle"
	AuthorizationAuthorizationResponseInvalidBillerInformation                AuthorizationAuthorizationResponse = "invalidBillerInformation"
	AuthorizationAuthorizationResponseInvalidCardSecurityCode                 AuthorizationAuthorizationResponse = "invalidCardSecurityCode"
	AuthorizationAuthorizationResponseInvalidCurrencyCode                     AuthorizationAuthorizationResponse = "invalidCurrencyCode"
	AuthorizationAuthorizationResponseInvalidMerchant                         AuthorizationAuthorizationResponse = "invalidMerchant"
	AuthorizationAuthorizationResponseInvalidResponse                         AuthorizationAuthorizationResponse = "invalidResponse"
	AuthorizationAuthorizationResponseInvalidTransaction                      AuthorizationAuthorizationResponse = "invalidTransaction"
	AuthorizationAuthorizationResponseIssuerNotAvailable                      AuthorizationAuthorizationResponse = "issuerNotAvailable"
	AuthorizationAuthorizationResponseIssuerTimeout                           AuthorizationAuthorizationResponse = "issuerTimeout"
	AuthorizationAuthorizationResponseIssuerUnavailable                       AuthorizationAuthorizationResponse = "issuerUnavailable"
	AuthorizationAuthorizationResponseNoActionTaken                           AuthorizationAuthorizationResponse = "noActionTaken"
	AuthorizationAuthorizationResponseNoCardRecord                            AuthorizationAuthorizationResponse = "noCardRecord"
	AuthorizationAuthorizationResponseNoCheckingAccount                       AuthorizationAuthorizationResponse = "noCheckingAccount"
	AuthorizationAuthorizationResponseNoCreditAccount                         AuthorizationAuthorizationResponse = "noCreditAccount"
	AuthorizationAuthorizationResponseNoFinancialImpact                       AuthorizationAuthorizationResponse = "noFinancialImpact"
	AuthorizationAuthorizationResponseNoReasonToDecline                       AuthorizationAuthorizationResponse = "noReasonToDecline"
	AuthorizationAuthorizationResponseNoSavingsAccount                        AuthorizationAuthorizationResponse = "noSavingsAccount"
	AuthorizationAuthorizationResponseNoSuchIssuer                            AuthorizationAuthorizationResponse = "noSuchIssuer"
	AuthorizationAuthorizationResponsePartialApproval                         AuthorizationAuthorizationResponse = "partialApproval"
	AuthorizationAuthorizationResponsePartialAuthorization                    AuthorizationAuthorizationResponse = "partialAuthorization"
	AuthorizationAuthorizationResponsePickUpCard                              AuthorizationAuthorizationResponse = "pickUpCard"
	AuthorizationAuthorizationResponsePickUpCardSpecialCondition              AuthorizationAuthorizationResponse = "pickUpCardSpecialCondition"
	AuthorizationAuthorizationResponsePinChangeRequestDeclined                AuthorizationAuthorizationResponse = "pinChangeRequestDeclined"
	AuthorizationAuthorizationResponsePinCryptographicErrorFound              AuthorizationAuthorizationResponse = "pinCryptographicErrorFound"
	AuthorizationAuthorizationResponsePinEntryTriesExceeded                   AuthorizationAuthorizationResponse = "pinEntryTriesExceeded"
	AuthorizationAuthorizationResponsePinNotChanged                           AuthorizationAuthorizationResponse = "pinNotChanged"
	AuthorizationAuthorizationResponsePleaseCallIssuer                        AuthorizationAuthorizationResponse = "pleaseCallIssuer"
	AuthorizationAuthorizationResponseReenterTransaction                      AuthorizationAuthorizationResponse = "reenterTransaction"
	AuthorizationAuthorizationResponseReferToCardIssuer                       AuthorizationAuthorizationResponse = "referToCardIssuer"
	AuthorizationAuthorizationResponseReferToCardIssuerSpecialCondition       AuthorizationAuthorizationResponse = "referToCardIssuerSpecialCondition"
	AuthorizationAuthorizationResponseRestrictedCard                          AuthorizationAuthorizationResponse = "restrictedCard"
	AuthorizationAuthorizationResponseReversal                                AuthorizationAuthorizationResponse = "reversal"
	AuthorizationAuthorizationResponseReversalDataInconsistent                AuthorizationAuthorizationResponse = "reversalDataInconsistent"
	AuthorizationAuthorizationResponseRevokeAllAuthorizationsOrder            AuthorizationAuthorizationResponse = "revokeAllAuthorizationsOrder"
	AuthorizationAuthorizationResponseScheduledTransactionstoppedByCardholder AuthorizationAuthorizationResponse = "scheduledTransactionstoppedByCardholder"
	AuthorizationAuthorizationResponseSecurityViolation                       AuthorizationAuthorizationResponse = "securityViolation"
	AuthorizationAuthorizationResponseSuccessful                              AuthorizationAuthorizationResponse = "successful"
	AuthorizationAuthorizationResponseSurchargeAmountNotPermitted             AuthorizationAuthorizationResponse = "surchargeAmountNotPermitted"
	AuthorizationAuthorizationResponseSuspectFraud                            AuthorizationAuthorizationResponse = "suspectFraud"
	AuthorizationAuthorizationResponseSystemMalfunction                       AuthorizationAuthorizationResponse = "systemMalfunction"
	AuthorizationAuthorizationResponseTransactionAmountExceedsApprovalAmount  AuthorizationAuthorizationResponse = "transactionAmountExceedsApprovalAmount"
	AuthorizationAuthorizationResponseTransactionCannotBeCompleted            AuthorizationAuthorizationResponse = "transactionCannotBeCompleted"
	AuthorizationAuthorizationResponseTransactionNotAllowedAtMerchant         AuthorizationAuthorizationResponse = "transactionNotAllowedAtMerchant"
	AuthorizationAuthorizationResponseTransactionNotAllowedAtTerminal         AuthorizationAuthorizationResponse = "transactionNotAllowedAtTerminal"
	AuthorizationAuthorizationResponseTransactionNotPermitted                 AuthorizationAuthorizationResponse = "transactionNotPermitted"
	AuthorizationAuthorizationResponseTransactionNotPermittedToCardholder     AuthorizationAuthorizationResponse = "transactionNotPermittedToCardholder"
	AuthorizationAuthorizationResponseUnableToGoOnline                        AuthorizationAuthorizationResponse = "unableToGoOnline"
	AuthorizationAuthorizationResponseUnableToLocateRecordInFile              AuthorizationAuthorizationResponse = "unableToLocateRecordInFile"
	AuthorizationAuthorizationResponseUnableToVerifyPin                       AuthorizationAuthorizationResponse = "unableToVerifyPin"
	AuthorizationAuthorizationResponseUnacceptablePin                         AuthorizationAuthorizationResponse = "unacceptablePin"
	AuthorizationAuthorizationResponseUnknown                                 AuthorizationAuthorizationResponse = "unknown"
	AuthorizationAuthorizationResponseUnsafePin                               AuthorizationAuthorizationResponse = "unsafePin"
)

func NewAuthorizationAuthorizationResponseFromString(s string) (AuthorizationAuthorizationResponse, error) {
	switch s {
	case "activityCountLimitExceeded":
		return AuthorizationAuthorizationResponseActivityCountLimitExceeded, nil
	case "alreadyReversed":
		return AuthorizationAuthorizationResponseAlreadyReversed, nil
	case "approved":
		return AuthorizationAuthorizationResponseApproved, nil
	case "approveVip":
		return AuthorizationAuthorizationResponseApproveVip, nil
	case "approveWithId":
		return AuthorizationAuthorizationResponseApproveWithId, nil
	case "cannotVerifyPin":
		return AuthorizationAuthorizationResponseCannotVerifyPin, nil
	case "cardAuthenticationFailed":
		return AuthorizationAuthorizationResponseCardAuthenticationFailed, nil
	case "cardTypeVerificationError":
		return AuthorizationAuthorizationResponseCardTypeVerificationError, nil
	case "cashRequestExceedsIssuerLimit":
		return AuthorizationAuthorizationResponseCashRequestExceedsIssuerLimit, nil
	case "cashServiceNotAvailable":
		return AuthorizationAuthorizationResponseCashServiceNotAvailable, nil
	case "cidVerificationError":
		return AuthorizationAuthorizationResponseCidVerificationError, nil
	case "contactCardIssuer":
		return AuthorizationAuthorizationResponseContactCardIssuer, nil
	case "cryptographicFailure":
		return AuthorizationAuthorizationResponseCryptographicFailure, nil
	case "dailyThresholdExceeded":
		return AuthorizationAuthorizationResponseDailyThresholdExceeded, nil
	case "declineCvv2Failure":
		return AuthorizationAuthorizationResponseDeclineCvv2Failure, nil
	case "deny":
		return AuthorizationAuthorizationResponseDeny, nil
	case "denyAccountCanceled":
		return AuthorizationAuthorizationResponseDenyAccountCanceled, nil
	case "denyClosedMerchant":
		return AuthorizationAuthorizationResponseDenyClosedMerchant, nil
	case "denyNewCardIssued":
		return AuthorizationAuthorizationResponseDenyNewCardIssued, nil
	case "denyPickUpCard":
		return AuthorizationAuthorizationResponseDenyPickUpCard, nil
	case "destinationCannotBeFoundForRouting":
		return AuthorizationAuthorizationResponseDestinationCannotBeFoundForRouting, nil
	case "doNotHonor":
		return AuthorizationAuthorizationResponseDoNotHonor, nil
	case "duplicateTransmissionDetected":
		return AuthorizationAuthorizationResponseDuplicateTransmissionDetected, nil
	case "error":
		return AuthorizationAuthorizationResponseError, nil
	case "exceedsWithdrawalAmountLimit":
		return AuthorizationAuthorizationResponseExceedsWithdrawalAmountLimit, nil
	case "expiredCard":
		return AuthorizationAuthorizationResponseExpiredCard, nil
	case "fileTemporarilyUnavailable":
		return AuthorizationAuthorizationResponseFileTemporarilyUnavailable, nil
	case "forceStip":
		return AuthorizationAuthorizationResponseForceStip, nil
	case "formatError":
		return AuthorizationAuthorizationResponseFormatError, nil
	case "forwardToIssuer":
		return AuthorizationAuthorizationResponseForwardToIssuer, nil
	case "functionNotSupported":
		return AuthorizationAuthorizationResponseFunctionNotSupported, nil
	case "honorWithId":
		return AuthorizationAuthorizationResponseHonorWithId, nil
	case "incorrectCvv":
		return AuthorizationAuthorizationResponseIncorrectCvv, nil
	case "incorrectPin":
		return AuthorizationAuthorizationResponseIncorrectPin, nil
	case "ineligibleForResubmission":
		return AuthorizationAuthorizationResponseIneligibleForResubmission, nil
	case "insufficientFunds":
		return AuthorizationAuthorizationResponseInsufficientFunds, nil
	case "invalidAccount":
		return AuthorizationAuthorizationResponseInvalidAccount, nil
	case "invalidAccountNumber":
		return AuthorizationAuthorizationResponseInvalidAccountNumber, nil
	case "invalidAmount":
		return AuthorizationAuthorizationResponseInvalidAmount, nil
	case "invalidAuthorizationLifeCycle":
		return AuthorizationAuthorizationResponseInvalidAuthorizationLifeCycle, nil
	case "invalidBillerInformation":
		return AuthorizationAuthorizationResponseInvalidBillerInformation, nil
	case "invalidCardSecurityCode":
		return AuthorizationAuthorizationResponseInvalidCardSecurityCode, nil
	case "invalidCurrencyCode":
		return AuthorizationAuthorizationResponseInvalidCurrencyCode, nil
	case "invalidMerchant":
		return AuthorizationAuthorizationResponseInvalidMerchant, nil
	case "invalidResponse":
		return AuthorizationAuthorizationResponseInvalidResponse, nil
	case "invalidTransaction":
		return AuthorizationAuthorizationResponseInvalidTransaction, nil
	case "issuerNotAvailable":
		return AuthorizationAuthorizationResponseIssuerNotAvailable, nil
	case "issuerTimeout":
		return AuthorizationAuthorizationResponseIssuerTimeout, nil
	case "issuerUnavailable":
		return AuthorizationAuthorizationResponseIssuerUnavailable, nil
	case "noActionTaken":
		return AuthorizationAuthorizationResponseNoActionTaken, nil
	case "noCardRecord":
		return AuthorizationAuthorizationResponseNoCardRecord, nil
	case "noCheckingAccount":
		return AuthorizationAuthorizationResponseNoCheckingAccount, nil
	case "noCreditAccount":
		return AuthorizationAuthorizationResponseNoCreditAccount, nil
	case "noFinancialImpact":
		return AuthorizationAuthorizationResponseNoFinancialImpact, nil
	case "noReasonToDecline":
		return AuthorizationAuthorizationResponseNoReasonToDecline, nil
	case "noSavingsAccount":
		return AuthorizationAuthorizationResponseNoSavingsAccount, nil
	case "noSuchIssuer":
		return AuthorizationAuthorizationResponseNoSuchIssuer, nil
	case "partialApproval":
		return AuthorizationAuthorizationResponsePartialApproval, nil
	case "partialAuthorization":
		return AuthorizationAuthorizationResponsePartialAuthorization, nil
	case "pickUpCard":
		return AuthorizationAuthorizationResponsePickUpCard, nil
	case "pickUpCardSpecialCondition":
		return AuthorizationAuthorizationResponsePickUpCardSpecialCondition, nil
	case "pinChangeRequestDeclined":
		return AuthorizationAuthorizationResponsePinChangeRequestDeclined, nil
	case "pinCryptographicErrorFound":
		return AuthorizationAuthorizationResponsePinCryptographicErrorFound, nil
	case "pinEntryTriesExceeded":
		return AuthorizationAuthorizationResponsePinEntryTriesExceeded, nil
	case "pinNotChanged":
		return AuthorizationAuthorizationResponsePinNotChanged, nil
	case "pleaseCallIssuer":
		return AuthorizationAuthorizationResponsePleaseCallIssuer, nil
	case "reenterTransaction":
		return AuthorizationAuthorizationResponseReenterTransaction, nil
	case "referToCardIssuer":
		return AuthorizationAuthorizationResponseReferToCardIssuer, nil
	case "referToCardIssuerSpecialCondition":
		return AuthorizationAuthorizationResponseReferToCardIssuerSpecialCondition, nil
	case "restrictedCard":
		return AuthorizationAuthorizationResponseRestrictedCard, nil
	case "reversal":
		return AuthorizationAuthorizationResponseReversal, nil
	case "reversalDataInconsistent":
		return AuthorizationAuthorizationResponseReversalDataInconsistent, nil
	case "revokeAllAuthorizationsOrder":
		return AuthorizationAuthorizationResponseRevokeAllAuthorizationsOrder, nil
	case "scheduledTransactionstoppedByCardholder":
		return AuthorizationAuthorizationResponseScheduledTransactionstoppedByCardholder, nil
	case "securityViolation":
		return AuthorizationAuthorizationResponseSecurityViolation, nil
	case "successful":
		return AuthorizationAuthorizationResponseSuccessful, nil
	case "surchargeAmountNotPermitted":
		return AuthorizationAuthorizationResponseSurchargeAmountNotPermitted, nil
	case "suspectFraud":
		return AuthorizationAuthorizationResponseSuspectFraud, nil
	case "systemMalfunction":
		return AuthorizationAuthorizationResponseSystemMalfunction, nil
	case "transactionAmountExceedsApprovalAmount":
		return AuthorizationAuthorizationResponseTransactionAmountExceedsApprovalAmount, nil
	case "transactionCannotBeCompleted":
		return AuthorizationAuthorizationResponseTransactionCannotBeCompleted, nil
	case "transactionNotAllowedAtMerchant":
		return AuthorizationAuthorizationResponseTransactionNotAllowedAtMerchant, nil
	case "transactionNotAllowedAtTerminal":
		return AuthorizationAuthorizationResponseTransactionNotAllowedAtTerminal, nil
	case "transactionNotPermitted":
		return AuthorizationAuthorizationResponseTransactionNotPermitted, nil
	case "transactionNotPermittedToCardholder":
		return AuthorizationAuthorizationResponseTransactionNotPermittedToCardholder, nil
	case "unableToGoOnline":
		return AuthorizationAuthorizationResponseUnableToGoOnline, nil
	case "unableToLocateRecordInFile":
		return AuthorizationAuthorizationResponseUnableToLocateRecordInFile, nil
	case "unableToVerifyPin":
		return AuthorizationAuthorizationResponseUnableToVerifyPin, nil
	case "unacceptablePin":
		return AuthorizationAuthorizationResponseUnacceptablePin, nil
	case "unknown":
		return AuthorizationAuthorizationResponseUnknown, nil
	case "unsafePin":
		return AuthorizationAuthorizationResponseUnsafePin, nil
	}
	var t AuthorizationAuthorizationResponse
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthorizationAuthorizationResponse) Ptr() *AuthorizationAuthorizationResponse {
	return &a
}

// Object that contains information about the authorization.
var (
	authorizationSummaryFieldAuthorizationId = big.NewInt(1 << 0)
	authorizationSummaryFieldCode            = big.NewInt(1 << 1)
	authorizationSummaryFieldAmount          = big.NewInt(1 << 2)
	authorizationSummaryFieldAvsResponseCode = big.NewInt(1 << 3)
	authorizationSummaryFieldLink            = big.NewInt(1 << 4)
)

type AuthorizationSummary struct {
	// Unique identifier of the authorization.
	AuthorizationId *int `json:"authorizationId,omitempty" url:"authorizationId,omitempty"`
	// Authorization code.
	//
	// **Note:** For returns, the card brands may not provide an authorization code.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// Authorization amount. We return the value in the currency's lowest denomination, for example, cents.
	Amount *int `json:"amount,omitempty" url:"amount,omitempty"`
	// Response code that indicates if the address matches the address registered to the customer.
	AvsResponseCode *string `json:"avsResponseCode,omitempty" url:"avsResponseCode,omitempty"`
	Link            *Link   `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AuthorizationSummary) GetAuthorizationId() *int {
	if a == nil {
		return nil
	}
	return a.AuthorizationId
}

func (a *AuthorizationSummary) GetCode() *string {
	if a == nil {
		return nil
	}
	return a.Code
}

func (a *AuthorizationSummary) GetAmount() *int {
	if a == nil {
		return nil
	}
	return a.Amount
}

func (a *AuthorizationSummary) GetAvsResponseCode() *string {
	if a == nil {
		return nil
	}
	return a.AvsResponseCode
}

func (a *AuthorizationSummary) GetLink() *Link {
	if a == nil {
		return nil
	}
	return a.Link
}

func (a *AuthorizationSummary) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AuthorizationSummary) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAuthorizationId sets the AuthorizationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AuthorizationSummary) SetAuthorizationId(authorizationId *int) {
	a.AuthorizationId = authorizationId
	a.require(authorizationSummaryFieldAuthorizationId)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AuthorizationSummary) SetCode(code *string) {
	a.Code = code
	a.require(authorizationSummaryFieldCode)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AuthorizationSummary) SetAmount(amount *int) {
	a.Amount = amount
	a.require(authorizationSummaryFieldAmount)
}

// SetAvsResponseCode sets the AvsResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AuthorizationSummary) SetAvsResponseCode(avsResponseCode *string) {
	a.AvsResponseCode = avsResponseCode
	a.require(authorizationSummaryFieldAvsResponseCode)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AuthorizationSummary) SetLink(link *Link) {
	a.Link = link
	a.require(authorizationSummaryFieldLink)
}

func (a *AuthorizationSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthorizationSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthorizationSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuthorizationSummary) MarshalJSON() ([]byte, error) {
	type embed AuthorizationSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AuthorizationSummary) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Indicates how the merchant batches their transactions.
var (
	automaticBatchCloseFieldBatchCloseTime = big.NewInt(1 << 0)
)

type AutomaticBatchClose struct {
	// Time that the batch automatically closes.
	BatchCloseTime *string `json:"batchCloseTime,omitempty" url:"batchCloseTime,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AutomaticBatchClose) GetBatchCloseTime() *string {
	if a == nil {
		return nil
	}
	return a.BatchCloseTime
}

func (a *AutomaticBatchClose) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutomaticBatchClose) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetBatchCloseTime sets the BatchCloseTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AutomaticBatchClose) SetBatchCloseTime(batchCloseTime *string) {
	a.BatchCloseTime = batchCloseTime
	a.require(automaticBatchCloseFieldBatchCloseTime)
}

func (a *AutomaticBatchClose) UnmarshalJSON(data []byte) error {
	type unmarshaler AutomaticBatchClose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutomaticBatchClose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutomaticBatchClose) MarshalJSON() ([]byte, error) {
	type embed AutomaticBatchClose
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AutomaticBatchClose) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	balanceFieldProcessingTerminalId = big.NewInt(1 << 0)
	balanceFieldOperator             = big.NewInt(1 << 1)
	balanceFieldCard                 = big.NewInt(1 << 2)
	balanceFieldResponseCode         = big.NewInt(1 << 3)
	balanceFieldResponseMessage      = big.NewInt(1 << 4)
)

type Balance struct {
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Operator who requested the balance inquiry.
	Operator *string `json:"operator,omitempty" url:"operator,omitempty"`
	Card     *Card   `json:"card" url:"card"`
	// Response from the processor.
	// - `A` - The processor approved the transaction.
	// - `D` - The processor declined the transaction.
	// - `E` - The processor received the transaction but will process the transaction later.
	// - `P` - The processor authorized a portion of the original amount of the transaction.
	// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
	// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
	ResponseCode *BalanceResponseCode `json:"responseCode,omitempty" url:"responseCode,omitempty"`
	// Response description from the payment processor, for example, Refer to Card Issuer.
	ResponseMessage *string `json:"responseMessage,omitempty" url:"responseMessage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Balance) GetProcessingTerminalId() string {
	if b == nil {
		return ""
	}
	return b.ProcessingTerminalId
}

func (b *Balance) GetOperator() *string {
	if b == nil {
		return nil
	}
	return b.Operator
}

func (b *Balance) GetCard() *Card {
	if b == nil {
		return nil
	}
	return b.Card
}

func (b *Balance) GetResponseCode() *BalanceResponseCode {
	if b == nil {
		return nil
	}
	return b.ResponseCode
}

func (b *Balance) GetResponseMessage() *string {
	if b == nil {
		return nil
	}
	return b.ResponseMessage
}

func (b *Balance) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Balance) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Balance) SetProcessingTerminalId(processingTerminalId string) {
	b.ProcessingTerminalId = processingTerminalId
	b.require(balanceFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Balance) SetOperator(operator *string) {
	b.Operator = operator
	b.require(balanceFieldOperator)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Balance) SetCard(card *Card) {
	b.Card = card
	b.require(balanceFieldCard)
}

// SetResponseCode sets the ResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Balance) SetResponseCode(responseCode *BalanceResponseCode) {
	b.ResponseCode = responseCode
	b.require(balanceFieldResponseCode)
}

// SetResponseMessage sets the ResponseMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Balance) SetResponseMessage(responseMessage *string) {
	b.ResponseMessage = responseMessage
	b.require(balanceFieldResponseMessage)
}

func (b *Balance) UnmarshalJSON(data []byte) error {
	type unmarshaler Balance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Balance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Balance) MarshalJSON() ([]byte, error) {
	type embed Balance
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *Balance) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Response from the processor.
// - `A` - The processor approved the transaction.
// - `D` - The processor declined the transaction.
// - `E` - The processor received the transaction but will process the transaction later.
// - `P` - The processor authorized a portion of the original amount of the transaction.
// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
type BalanceResponseCode string

const (
	BalanceResponseCodeA BalanceResponseCode = "A"
	BalanceResponseCodeD BalanceResponseCode = "D"
	BalanceResponseCodeE BalanceResponseCode = "E"
	BalanceResponseCodeP BalanceResponseCode = "P"
	BalanceResponseCodeR BalanceResponseCode = "R"
	BalanceResponseCodeC BalanceResponseCode = "C"
)

func NewBalanceResponseCodeFromString(s string) (BalanceResponseCode, error) {
	switch s {
	case "A":
		return BalanceResponseCodeA, nil
	case "D":
		return BalanceResponseCodeD, nil
	case "E":
		return BalanceResponseCodeE, nil
	case "P":
		return BalanceResponseCodeP, nil
	case "R":
		return BalanceResponseCodeR, nil
	case "C":
		return BalanceResponseCodeC, nil
	}
	var t BalanceResponseCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BalanceResponseCode) Ptr() *BalanceResponseCode {
	return &b
}

var (
	bankAccountVerificationResultFieldProcessingTerminalId = big.NewInt(1 << 0)
	bankAccountVerificationResultFieldVerified             = big.NewInt(1 << 1)
)

type BankAccountVerificationResult struct {
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Indicates if the customer's bank account details are valid.
	// - `true` - Account details are valid.
	// - `false` - Account details are not valid.
	Verified bool `json:"verified" url:"verified"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountVerificationResult) GetProcessingTerminalId() string {
	if b == nil {
		return ""
	}
	return b.ProcessingTerminalId
}

func (b *BankAccountVerificationResult) GetVerified() bool {
	if b == nil {
		return false
	}
	return b.Verified
}

func (b *BankAccountVerificationResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountVerificationResult) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccountVerificationResult) SetProcessingTerminalId(processingTerminalId string) {
	b.ProcessingTerminalId = processingTerminalId
	b.require(bankAccountVerificationResultFieldProcessingTerminalId)
}

// SetVerified sets the Verified field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccountVerificationResult) SetVerified(verified bool) {
	b.Verified = verified
	b.require(bankAccountVerificationResultFieldVerified)
}

func (b *BankAccountVerificationResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountVerificationResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountVerificationResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountVerificationResult) MarshalJSON() ([]byte, error) {
	type embed BankAccountVerificationResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankAccountVerificationResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the transaction.
var (
	bankTransferBreakdownFieldSubtotal = big.NewInt(1 << 0)
	bankTransferBreakdownFieldTip      = big.NewInt(1 << 1)
	bankTransferBreakdownFieldTaxes    = big.NewInt(1 << 2)
)

type BankTransferBreakdown struct {
	// Total amount of the transaction before tax and tip. The value is in the currency's lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Array of tax objects.
	Taxes []*RetrievedTax `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferBreakdown) GetSubtotal() int64 {
	if b == nil {
		return 0
	}
	return b.Subtotal
}

func (b *BankTransferBreakdown) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *BankTransferBreakdown) GetTaxes() []*RetrievedTax {
	if b == nil {
		return nil
	}
	return b.Taxes
}

func (b *BankTransferBreakdown) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferBreakdown) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferBreakdown) SetSubtotal(subtotal int64) {
	b.Subtotal = subtotal
	b.require(bankTransferBreakdownFieldSubtotal)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferBreakdown) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(bankTransferBreakdownFieldTip)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferBreakdown) SetTaxes(taxes []*RetrievedTax) {
	b.Taxes = taxes
	b.require(bankTransferBreakdownFieldTaxes)
}

func (b *BankTransferBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferBreakdown(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferBreakdown) MarshalJSON() ([]byte, error) {
	type embed BankTransferBreakdown
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferBreakdown) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the transaction.
var (
	bankTransferBreakdownBaseFieldSubtotal = big.NewInt(1 << 0)
	bankTransferBreakdownBaseFieldTip      = big.NewInt(1 << 1)
)

type BankTransferBreakdownBase struct {
	// Total amount of the transaction before tax and tip. The value is in the currency's lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferBreakdownBase) GetSubtotal() int64 {
	if b == nil {
		return 0
	}
	return b.Subtotal
}

func (b *BankTransferBreakdownBase) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *BankTransferBreakdownBase) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferBreakdownBase) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferBreakdownBase) SetSubtotal(subtotal int64) {
	b.Subtotal = subtotal
	b.require(bankTransferBreakdownBaseFieldSubtotal)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferBreakdownBase) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(bankTransferBreakdownBaseFieldTip)
}

func (b *BankTransferBreakdownBase) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferBreakdownBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferBreakdownBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferBreakdownBase) MarshalJSON() ([]byte, error) {
	type embed BankTransferBreakdownBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferBreakdownBase) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the customer.
var (
	bankTransferCustomerFieldNotificationLanguage = big.NewInt(1 << 0)
	bankTransferCustomerFieldContactMethods       = big.NewInt(1 << 1)
)

type BankTransferCustomer struct {
	// Customer's preferred notification language. This code follows the [ISO 639-1](https://www.iso.org/iso-639-language-code) standard.
	NotificationLanguage *BankTransferCustomerNotificationLanguage `json:"notificationLanguage,omitempty" url:"notificationLanguage,omitempty"`
	// Array of polymorphic objects, which contain contact information.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods,omitempty" url:"contactMethods,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferCustomer) GetNotificationLanguage() *BankTransferCustomerNotificationLanguage {
	if b == nil {
		return nil
	}
	return b.NotificationLanguage
}

func (b *BankTransferCustomer) GetContactMethods() []*ContactMethod {
	if b == nil {
		return nil
	}
	return b.ContactMethods
}

func (b *BankTransferCustomer) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferCustomer) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetNotificationLanguage sets the NotificationLanguage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferCustomer) SetNotificationLanguage(notificationLanguage *BankTransferCustomerNotificationLanguage) {
	b.NotificationLanguage = notificationLanguage
	b.require(bankTransferCustomerFieldNotificationLanguage)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferCustomer) SetContactMethods(contactMethods []*ContactMethod) {
	b.ContactMethods = contactMethods
	b.require(bankTransferCustomerFieldContactMethods)
}

func (b *BankTransferCustomer) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferCustomer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferCustomer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferCustomer) MarshalJSON() ([]byte, error) {
	type embed BankTransferCustomer
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferCustomer) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Customer's preferred notification language. This code follows the [ISO 639-1](https://www.iso.org/iso-639-language-code) standard.
type BankTransferCustomerNotificationLanguage string

const (
	BankTransferCustomerNotificationLanguageEn BankTransferCustomerNotificationLanguage = "en"
	BankTransferCustomerNotificationLanguageFr BankTransferCustomerNotificationLanguage = "fr"
)

func NewBankTransferCustomerNotificationLanguageFromString(s string) (BankTransferCustomerNotificationLanguage, error) {
	switch s {
	case "en":
		return BankTransferCustomerNotificationLanguageEn, nil
	case "fr":
		return BankTransferCustomerNotificationLanguageFr, nil
	}
	var t BankTransferCustomerNotificationLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankTransferCustomerNotificationLanguage) Ptr() *BankTransferCustomerNotificationLanguage {
	return &b
}

// Object that contains information about the sale and the customer's bank details.
var (
	bankTransferPaymentFieldPaymentId            = big.NewInt(1 << 0)
	bankTransferPaymentFieldProcessingTerminalId = big.NewInt(1 << 1)
	bankTransferPaymentFieldOrder                = big.NewInt(1 << 2)
	bankTransferPaymentFieldCustomer             = big.NewInt(1 << 3)
	bankTransferPaymentFieldBankAccount          = big.NewInt(1 << 4)
	bankTransferPaymentFieldRefunds              = big.NewInt(1 << 5)
	bankTransferPaymentFieldReturns              = big.NewInt(1 << 6)
	bankTransferPaymentFieldRepresentment        = big.NewInt(1 << 7)
	bankTransferPaymentFieldTransactionResult    = big.NewInt(1 << 8)
	bankTransferPaymentFieldCustomFields         = big.NewInt(1 << 9)
)

type BankTransferPayment struct {
	// Unique identifier that we assigned to the payment.
	PaymentId string `json:"paymentId" url:"paymentId"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string                    `json:"processingTerminalId" url:"processingTerminalId"`
	Order                *BankTransferPaymentOrder `json:"order" url:"order"`
	Customer             *BankTransferCustomer     `json:"customer,omitempty" url:"customer,omitempty"`
	// Polymorphic object that contains bank account information.
	// The value of the type field determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`pad` - Pre-authorized debit (PAD) details
	BankAccount *BankTransferPaymentBankAccount `json:"bankAccount" url:"bankAccount"`
	// List of refunds issued against the payment.
	Refunds []*RefundSummary `json:"refunds,omitempty" url:"refunds,omitempty"`
	// List of returns issued against the payment.
	Returns []*BankTransferReturnSummary `json:"returns,omitempty" url:"returns,omitempty"`
	// List of re-presented payments linked to the return.
	Representment     *PaymentSummary     `json:"representment,omitempty" url:"representment,omitempty"`
	TransactionResult *BankTransferResult `json:"transactionResult" url:"transactionResult"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferPayment) GetPaymentId() string {
	if b == nil {
		return ""
	}
	return b.PaymentId
}

func (b *BankTransferPayment) GetProcessingTerminalId() string {
	if b == nil {
		return ""
	}
	return b.ProcessingTerminalId
}

func (b *BankTransferPayment) GetOrder() *BankTransferPaymentOrder {
	if b == nil {
		return nil
	}
	return b.Order
}

func (b *BankTransferPayment) GetCustomer() *BankTransferCustomer {
	if b == nil {
		return nil
	}
	return b.Customer
}

func (b *BankTransferPayment) GetBankAccount() *BankTransferPaymentBankAccount {
	if b == nil {
		return nil
	}
	return b.BankAccount
}

func (b *BankTransferPayment) GetRefunds() []*RefundSummary {
	if b == nil {
		return nil
	}
	return b.Refunds
}

func (b *BankTransferPayment) GetReturns() []*BankTransferReturnSummary {
	if b == nil {
		return nil
	}
	return b.Returns
}

func (b *BankTransferPayment) GetRepresentment() *PaymentSummary {
	if b == nil {
		return nil
	}
	return b.Representment
}

func (b *BankTransferPayment) GetTransactionResult() *BankTransferResult {
	if b == nil {
		return nil
	}
	return b.TransactionResult
}

func (b *BankTransferPayment) GetCustomFields() []*CustomField {
	if b == nil {
		return nil
	}
	return b.CustomFields
}

func (b *BankTransferPayment) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferPayment) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetPaymentId(paymentId string) {
	b.PaymentId = paymentId
	b.require(bankTransferPaymentFieldPaymentId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetProcessingTerminalId(processingTerminalId string) {
	b.ProcessingTerminalId = processingTerminalId
	b.require(bankTransferPaymentFieldProcessingTerminalId)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetOrder(order *BankTransferPaymentOrder) {
	b.Order = order
	b.require(bankTransferPaymentFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetCustomer(customer *BankTransferCustomer) {
	b.Customer = customer
	b.require(bankTransferPaymentFieldCustomer)
}

// SetBankAccount sets the BankAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetBankAccount(bankAccount *BankTransferPaymentBankAccount) {
	b.BankAccount = bankAccount
	b.require(bankTransferPaymentFieldBankAccount)
}

// SetRefunds sets the Refunds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetRefunds(refunds []*RefundSummary) {
	b.Refunds = refunds
	b.require(bankTransferPaymentFieldRefunds)
}

// SetReturns sets the Returns field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetReturns(returns []*BankTransferReturnSummary) {
	b.Returns = returns
	b.require(bankTransferPaymentFieldReturns)
}

// SetRepresentment sets the Representment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetRepresentment(representment *PaymentSummary) {
	b.Representment = representment
	b.require(bankTransferPaymentFieldRepresentment)
}

// SetTransactionResult sets the TransactionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetTransactionResult(transactionResult *BankTransferResult) {
	b.TransactionResult = transactionResult
	b.require(bankTransferPaymentFieldTransactionResult)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPayment) SetCustomFields(customFields []*CustomField) {
	b.CustomFields = customFields
	b.require(bankTransferPaymentFieldCustomFields)
}

func (b *BankTransferPayment) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferPayment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferPayment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferPayment) MarshalJSON() ([]byte, error) {
	type embed BankTransferPayment
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferPayment) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Polymorphic object that contains bank account information.
// The value of the type field determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`pad` - Pre-authorized debit (PAD) details
type BankTransferPaymentBankAccount struct {
	Type string
	Ach  *AchBankAccount
	Pad  *PadBankAccount
}

func (b *BankTransferPaymentBankAccount) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BankTransferPaymentBankAccount) GetAch() *AchBankAccount {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BankTransferPaymentBankAccount) GetPad() *PadBankAccount {
	if b == nil {
		return nil
	}
	return b.Pad
}

func (b *BankTransferPaymentBankAccount) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(AchBankAccount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "pad":
		value := new(PadBankAccount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Pad = value
	}
	return nil
}

func (b BankTransferPaymentBankAccount) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(b.Ach, "type", "ach")
	}
	if b.Pad != nil {
		return internal.MarshalJSONWithExtraProperty(b.Pad, "type", "pad")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BankTransferPaymentBankAccountVisitor interface {
	VisitAch(*AchBankAccount) error
	VisitPad(*PadBankAccount) error
}

func (b *BankTransferPaymentBankAccount) Accept(visitor BankTransferPaymentBankAccountVisitor) error {
	if b.Ach != nil {
		return visitor.VisitAch(b.Ach)
	}
	if b.Pad != nil {
		return visitor.VisitPad(b.Pad)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BankTransferPaymentBankAccount) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Ach != nil {
		fields = append(fields, "ach")
	}
	if b.Pad != nil {
		fields = append(fields, "pad")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

// Object that contains information about the transaction.
var (
	bankTransferPaymentOrderFieldOrderId     = big.NewInt(1 << 0)
	bankTransferPaymentOrderFieldDateTime    = big.NewInt(1 << 1)
	bankTransferPaymentOrderFieldDescription = big.NewInt(1 << 2)
	bankTransferPaymentOrderFieldAmount      = big.NewInt(1 << 3)
	bankTransferPaymentOrderFieldCurrency    = big.NewInt(1 << 4)
	bankTransferPaymentOrderFieldBreakdown   = big.NewInt(1 << 5)
)

type BankTransferPaymentOrder struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// The processing date and time of the transaction represented as per [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// A brief description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The total amount in the currency's lowest denomination. For example, cents.
	Amount    *int64                 `json:"amount,omitempty" url:"amount,omitempty"`
	Currency  *Currency              `json:"currency,omitempty" url:"currency,omitempty"`
	Breakdown *BankTransferBreakdown `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferPaymentOrder) GetOrderId() *string {
	if b == nil {
		return nil
	}
	return b.OrderId
}

func (b *BankTransferPaymentOrder) GetDateTime() *time.Time {
	if b == nil {
		return nil
	}
	return b.DateTime
}

func (b *BankTransferPaymentOrder) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BankTransferPaymentOrder) GetAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.Amount
}

func (b *BankTransferPaymentOrder) GetCurrency() *Currency {
	if b == nil {
		return nil
	}
	return b.Currency
}

func (b *BankTransferPaymentOrder) GetBreakdown() *BankTransferBreakdown {
	if b == nil {
		return nil
	}
	return b.Breakdown
}

func (b *BankTransferPaymentOrder) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferPaymentOrder) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrder) SetOrderId(orderId *string) {
	b.OrderId = orderId
	b.require(bankTransferPaymentOrderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrder) SetDateTime(dateTime *time.Time) {
	b.DateTime = dateTime
	b.require(bankTransferPaymentOrderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrder) SetDescription(description *string) {
	b.Description = description
	b.require(bankTransferPaymentOrderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrder) SetAmount(amount *int64) {
	b.Amount = amount
	b.require(bankTransferPaymentOrderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrder) SetCurrency(currency *Currency) {
	b.Currency = currency
	b.require(bankTransferPaymentOrderFieldCurrency)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrder) SetBreakdown(breakdown *BankTransferBreakdown) {
	b.Breakdown = breakdown
	b.require(bankTransferPaymentOrderFieldBreakdown)
}

func (b *BankTransferPaymentOrder) UnmarshalJSON(data []byte) error {
	type embed BankTransferPaymentOrder
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankTransferPaymentOrder(unmarshaler.embed)
	b.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferPaymentOrder) MarshalJSON() ([]byte, error) {
	type embed BankTransferPaymentOrder
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*b),
		DateTime: internal.NewOptionalDateTime(b.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferPaymentOrder) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the transaction.
var (
	bankTransferPaymentOrderBaseFieldOrderId     = big.NewInt(1 << 0)
	bankTransferPaymentOrderBaseFieldDateTime    = big.NewInt(1 << 1)
	bankTransferPaymentOrderBaseFieldDescription = big.NewInt(1 << 2)
	bankTransferPaymentOrderBaseFieldAmount      = big.NewInt(1 << 3)
	bankTransferPaymentOrderBaseFieldCurrency    = big.NewInt(1 << 4)
)

type BankTransferPaymentOrderBase struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// The processing date and time of the transaction represented as per [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// A brief description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The total amount in the currency's lowest denomination. For example, cents.
	Amount   *int64    `json:"amount,omitempty" url:"amount,omitempty"`
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferPaymentOrderBase) GetOrderId() *string {
	if b == nil {
		return nil
	}
	return b.OrderId
}

func (b *BankTransferPaymentOrderBase) GetDateTime() *time.Time {
	if b == nil {
		return nil
	}
	return b.DateTime
}

func (b *BankTransferPaymentOrderBase) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BankTransferPaymentOrderBase) GetAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.Amount
}

func (b *BankTransferPaymentOrderBase) GetCurrency() *Currency {
	if b == nil {
		return nil
	}
	return b.Currency
}

func (b *BankTransferPaymentOrderBase) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferPaymentOrderBase) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrderBase) SetOrderId(orderId *string) {
	b.OrderId = orderId
	b.require(bankTransferPaymentOrderBaseFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrderBase) SetDateTime(dateTime *time.Time) {
	b.DateTime = dateTime
	b.require(bankTransferPaymentOrderBaseFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrderBase) SetDescription(description *string) {
	b.Description = description
	b.require(bankTransferPaymentOrderBaseFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrderBase) SetAmount(amount *int64) {
	b.Amount = amount
	b.require(bankTransferPaymentOrderBaseFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentOrderBase) SetCurrency(currency *Currency) {
	b.Currency = currency
	b.require(bankTransferPaymentOrderBaseFieldCurrency)
}

func (b *BankTransferPaymentOrderBase) UnmarshalJSON(data []byte) error {
	type embed BankTransferPaymentOrderBase
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankTransferPaymentOrderBase(unmarshaler.embed)
	b.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferPaymentOrderBase) MarshalJSON() ([]byte, error) {
	type embed BankTransferPaymentOrderBase
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*b),
		DateTime: internal.NewOptionalDateTime(b.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferPaymentOrderBase) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	bankTransferPaymentPaginatedListFieldLimit   = big.NewInt(1 << 0)
	bankTransferPaymentPaginatedListFieldCount   = big.NewInt(1 << 1)
	bankTransferPaymentPaginatedListFieldHasMore = big.NewInt(1 << 2)
	bankTransferPaymentPaginatedListFieldLinks   = big.NewInt(1 << 3)
	bankTransferPaymentPaginatedListFieldData    = big.NewInt(1 << 4)
)

type BankTransferPaymentPaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of payments.
	Data []*BankTransferPayment `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferPaymentPaginatedList) GetLimit() *int {
	if b == nil {
		return nil
	}
	return b.Limit
}

func (b *BankTransferPaymentPaginatedList) GetCount() *int {
	if b == nil {
		return nil
	}
	return b.Count
}

func (b *BankTransferPaymentPaginatedList) GetHasMore() *bool {
	if b == nil {
		return nil
	}
	return b.HasMore
}

func (b *BankTransferPaymentPaginatedList) GetLinks() []*Link {
	if b == nil {
		return nil
	}
	return b.Links
}

func (b *BankTransferPaymentPaginatedList) GetData() []*BankTransferPayment {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BankTransferPaymentPaginatedList) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferPaymentPaginatedList) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentPaginatedList) SetLimit(limit *int) {
	b.Limit = limit
	b.require(bankTransferPaymentPaginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentPaginatedList) SetCount(count *int) {
	b.Count = count
	b.require(bankTransferPaymentPaginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentPaginatedList) SetHasMore(hasMore *bool) {
	b.HasMore = hasMore
	b.require(bankTransferPaymentPaginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentPaginatedList) SetLinks(links []*Link) {
	b.Links = links
	b.require(bankTransferPaymentPaginatedListFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentPaginatedList) SetData(data []*BankTransferPayment) {
	b.Data = data
	b.require(bankTransferPaymentPaginatedListFieldData)
}

func (b *BankTransferPaymentPaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferPaymentPaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferPaymentPaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferPaymentPaginatedList) MarshalJSON() ([]byte, error) {
	type embed BankTransferPaymentPaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferPaymentPaginatedList) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the transaction.
var (
	bankTransferPaymentRequestOrderFieldOrderId     = big.NewInt(1 << 0)
	bankTransferPaymentRequestOrderFieldDateTime    = big.NewInt(1 << 1)
	bankTransferPaymentRequestOrderFieldDescription = big.NewInt(1 << 2)
	bankTransferPaymentRequestOrderFieldAmount      = big.NewInt(1 << 3)
	bankTransferPaymentRequestOrderFieldCurrency    = big.NewInt(1 << 4)
	bankTransferPaymentRequestOrderFieldBreakdown   = big.NewInt(1 << 5)
)

type BankTransferPaymentRequestOrder struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// The processing date and time of the transaction represented as per [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// A brief description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The total amount in the currency's lowest denomination. For example, cents.
	Amount    *int64                        `json:"amount,omitempty" url:"amount,omitempty"`
	Currency  *Currency                     `json:"currency,omitempty" url:"currency,omitempty"`
	Breakdown *BankTransferRequestBreakdown `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferPaymentRequestOrder) GetOrderId() *string {
	if b == nil {
		return nil
	}
	return b.OrderId
}

func (b *BankTransferPaymentRequestOrder) GetDateTime() *time.Time {
	if b == nil {
		return nil
	}
	return b.DateTime
}

func (b *BankTransferPaymentRequestOrder) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BankTransferPaymentRequestOrder) GetAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.Amount
}

func (b *BankTransferPaymentRequestOrder) GetCurrency() *Currency {
	if b == nil {
		return nil
	}
	return b.Currency
}

func (b *BankTransferPaymentRequestOrder) GetBreakdown() *BankTransferRequestBreakdown {
	if b == nil {
		return nil
	}
	return b.Breakdown
}

func (b *BankTransferPaymentRequestOrder) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferPaymentRequestOrder) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequestOrder) SetOrderId(orderId *string) {
	b.OrderId = orderId
	b.require(bankTransferPaymentRequestOrderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequestOrder) SetDateTime(dateTime *time.Time) {
	b.DateTime = dateTime
	b.require(bankTransferPaymentRequestOrderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequestOrder) SetDescription(description *string) {
	b.Description = description
	b.require(bankTransferPaymentRequestOrderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequestOrder) SetAmount(amount *int64) {
	b.Amount = amount
	b.require(bankTransferPaymentRequestOrderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequestOrder) SetCurrency(currency *Currency) {
	b.Currency = currency
	b.require(bankTransferPaymentRequestOrderFieldCurrency)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequestOrder) SetBreakdown(breakdown *BankTransferRequestBreakdown) {
	b.Breakdown = breakdown
	b.require(bankTransferPaymentRequestOrderFieldBreakdown)
}

func (b *BankTransferPaymentRequestOrder) UnmarshalJSON(data []byte) error {
	type embed BankTransferPaymentRequestOrder
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankTransferPaymentRequestOrder(unmarshaler.embed)
	b.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferPaymentRequestOrder) MarshalJSON() ([]byte, error) {
	type embed BankTransferPaymentRequestOrder
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*b),
		DateTime: internal.NewOptionalDateTime(b.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferPaymentRequestOrder) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	bankTransferRefundFieldRefundId             = big.NewInt(1 << 0)
	bankTransferRefundFieldProcessingTerminalId = big.NewInt(1 << 1)
	bankTransferRefundFieldOrder                = big.NewInt(1 << 2)
	bankTransferRefundFieldCustomer             = big.NewInt(1 << 3)
	bankTransferRefundFieldBankAccount          = big.NewInt(1 << 4)
	bankTransferRefundFieldPayment              = big.NewInt(1 << 5)
	bankTransferRefundFieldTransactionResult    = big.NewInt(1 << 6)
	bankTransferRefundFieldCustomFields         = big.NewInt(1 << 7)
)

type BankTransferRefund struct {
	// Unique identifier that our gateway assigned to the refund.
	RefundId string `json:"refundId" url:"refundId"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string                   `json:"processingTerminalId" url:"processingTerminalId"`
	Order                *BankTransferRefundOrder `json:"order" url:"order"`
	Customer             *BankTransferCustomer    `json:"customer,omitempty" url:"customer,omitempty"`
	// Polymorphic object that contains bank account information.
	//
	// The value of the type field determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`pad` - Pre-authorized debit (PAD) details
	BankAccount       *BankTransferRefundBankAccount `json:"bankAccount" url:"bankAccount"`
	Payment           *PaymentSummary                `json:"payment,omitempty" url:"payment,omitempty"`
	TransactionResult *BankTransferResult            `json:"transactionResult" url:"transactionResult"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferRefund) GetRefundId() string {
	if b == nil {
		return ""
	}
	return b.RefundId
}

func (b *BankTransferRefund) GetProcessingTerminalId() string {
	if b == nil {
		return ""
	}
	return b.ProcessingTerminalId
}

func (b *BankTransferRefund) GetOrder() *BankTransferRefundOrder {
	if b == nil {
		return nil
	}
	return b.Order
}

func (b *BankTransferRefund) GetCustomer() *BankTransferCustomer {
	if b == nil {
		return nil
	}
	return b.Customer
}

func (b *BankTransferRefund) GetBankAccount() *BankTransferRefundBankAccount {
	if b == nil {
		return nil
	}
	return b.BankAccount
}

func (b *BankTransferRefund) GetPayment() *PaymentSummary {
	if b == nil {
		return nil
	}
	return b.Payment
}

func (b *BankTransferRefund) GetTransactionResult() *BankTransferResult {
	if b == nil {
		return nil
	}
	return b.TransactionResult
}

func (b *BankTransferRefund) GetCustomFields() []*CustomField {
	if b == nil {
		return nil
	}
	return b.CustomFields
}

func (b *BankTransferRefund) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferRefund) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetRefundId sets the RefundId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetRefundId(refundId string) {
	b.RefundId = refundId
	b.require(bankTransferRefundFieldRefundId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetProcessingTerminalId(processingTerminalId string) {
	b.ProcessingTerminalId = processingTerminalId
	b.require(bankTransferRefundFieldProcessingTerminalId)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetOrder(order *BankTransferRefundOrder) {
	b.Order = order
	b.require(bankTransferRefundFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetCustomer(customer *BankTransferCustomer) {
	b.Customer = customer
	b.require(bankTransferRefundFieldCustomer)
}

// SetBankAccount sets the BankAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetBankAccount(bankAccount *BankTransferRefundBankAccount) {
	b.BankAccount = bankAccount
	b.require(bankTransferRefundFieldBankAccount)
}

// SetPayment sets the Payment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetPayment(payment *PaymentSummary) {
	b.Payment = payment
	b.require(bankTransferRefundFieldPayment)
}

// SetTransactionResult sets the TransactionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetTransactionResult(transactionResult *BankTransferResult) {
	b.TransactionResult = transactionResult
	b.require(bankTransferRefundFieldTransactionResult)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefund) SetCustomFields(customFields []*CustomField) {
	b.CustomFields = customFields
	b.require(bankTransferRefundFieldCustomFields)
}

func (b *BankTransferRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferRefund(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferRefund) MarshalJSON() ([]byte, error) {
	type embed BankTransferRefund
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferRefund) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Polymorphic object that contains bank account information.
//
// The value of the type field determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`pad` - Pre-authorized debit (PAD) details
type BankTransferRefundBankAccount struct {
	Type string
	Ach  *AchBankAccount
	Pad  *PadBankAccount
}

func (b *BankTransferRefundBankAccount) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BankTransferRefundBankAccount) GetAch() *AchBankAccount {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BankTransferRefundBankAccount) GetPad() *PadBankAccount {
	if b == nil {
		return nil
	}
	return b.Pad
}

func (b *BankTransferRefundBankAccount) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(AchBankAccount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "pad":
		value := new(PadBankAccount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Pad = value
	}
	return nil
}

func (b BankTransferRefundBankAccount) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(b.Ach, "type", "ach")
	}
	if b.Pad != nil {
		return internal.MarshalJSONWithExtraProperty(b.Pad, "type", "pad")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BankTransferRefundBankAccountVisitor interface {
	VisitAch(*AchBankAccount) error
	VisitPad(*PadBankAccount) error
}

func (b *BankTransferRefundBankAccount) Accept(visitor BankTransferRefundBankAccountVisitor) error {
	if b.Ach != nil {
		return visitor.VisitAch(b.Ach)
	}
	if b.Pad != nil {
		return visitor.VisitPad(b.Pad)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BankTransferRefundBankAccount) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Ach != nil {
		fields = append(fields, "ach")
	}
	if b.Pad != nil {
		fields = append(fields, "pad")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

// Object that contains information about the order.
var (
	bankTransferRefundOrderFieldOrderId     = big.NewInt(1 << 0)
	bankTransferRefundOrderFieldDateTime    = big.NewInt(1 << 1)
	bankTransferRefundOrderFieldDescription = big.NewInt(1 << 2)
	bankTransferRefundOrderFieldAmount      = big.NewInt(1 << 3)
	bankTransferRefundOrderFieldCurrency    = big.NewInt(1 << 4)
)

type BankTransferRefundOrder struct {
	// Unique identifier that the merchant assigned to the transaction.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Date and time that we processed the transaction. We return this value in the ISO 8601 format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the refund.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total amount of the transaction. The value is in the currency's lowest denomination, for example, cents.
	Amount   *int64    `json:"amount,omitempty" url:"amount,omitempty"`
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferRefundOrder) GetOrderId() *string {
	if b == nil {
		return nil
	}
	return b.OrderId
}

func (b *BankTransferRefundOrder) GetDateTime() *time.Time {
	if b == nil {
		return nil
	}
	return b.DateTime
}

func (b *BankTransferRefundOrder) GetDescription() *string {
	if b == nil {
		return nil
	}
	return b.Description
}

func (b *BankTransferRefundOrder) GetAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.Amount
}

func (b *BankTransferRefundOrder) GetCurrency() *Currency {
	if b == nil {
		return nil
	}
	return b.Currency
}

func (b *BankTransferRefundOrder) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferRefundOrder) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundOrder) SetOrderId(orderId *string) {
	b.OrderId = orderId
	b.require(bankTransferRefundOrderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundOrder) SetDateTime(dateTime *time.Time) {
	b.DateTime = dateTime
	b.require(bankTransferRefundOrderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundOrder) SetDescription(description *string) {
	b.Description = description
	b.require(bankTransferRefundOrderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundOrder) SetAmount(amount *int64) {
	b.Amount = amount
	b.require(bankTransferRefundOrderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundOrder) SetCurrency(currency *Currency) {
	b.Currency = currency
	b.require(bankTransferRefundOrderFieldCurrency)
}

func (b *BankTransferRefundOrder) UnmarshalJSON(data []byte) error {
	type embed BankTransferRefundOrder
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankTransferRefundOrder(unmarshaler.embed)
	b.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferRefundOrder) MarshalJSON() ([]byte, error) {
	type embed BankTransferRefundOrder
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*b),
		DateTime: internal.NewOptionalDateTime(b.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferRefundOrder) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	bankTransferRefundPaginatedListFieldLimit   = big.NewInt(1 << 0)
	bankTransferRefundPaginatedListFieldCount   = big.NewInt(1 << 1)
	bankTransferRefundPaginatedListFieldHasMore = big.NewInt(1 << 2)
	bankTransferRefundPaginatedListFieldLinks   = big.NewInt(1 << 3)
	bankTransferRefundPaginatedListFieldData    = big.NewInt(1 << 4)
)

type BankTransferRefundPaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of refund transactions.
	Data []*BankTransferRefund `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferRefundPaginatedList) GetLimit() *int {
	if b == nil {
		return nil
	}
	return b.Limit
}

func (b *BankTransferRefundPaginatedList) GetCount() *int {
	if b == nil {
		return nil
	}
	return b.Count
}

func (b *BankTransferRefundPaginatedList) GetHasMore() *bool {
	if b == nil {
		return nil
	}
	return b.HasMore
}

func (b *BankTransferRefundPaginatedList) GetLinks() []*Link {
	if b == nil {
		return nil
	}
	return b.Links
}

func (b *BankTransferRefundPaginatedList) GetData() []*BankTransferRefund {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BankTransferRefundPaginatedList) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferRefundPaginatedList) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundPaginatedList) SetLimit(limit *int) {
	b.Limit = limit
	b.require(bankTransferRefundPaginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundPaginatedList) SetCount(count *int) {
	b.Count = count
	b.require(bankTransferRefundPaginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundPaginatedList) SetHasMore(hasMore *bool) {
	b.HasMore = hasMore
	b.require(bankTransferRefundPaginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundPaginatedList) SetLinks(links []*Link) {
	b.Links = links
	b.require(bankTransferRefundPaginatedListFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRefundPaginatedList) SetData(data []*BankTransferRefund) {
	b.Data = data
	b.require(bankTransferRefundPaginatedListFieldData)
}

func (b *BankTransferRefundPaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferRefundPaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferRefundPaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferRefundPaginatedList) MarshalJSON() ([]byte, error) {
	type embed BankTransferRefundPaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferRefundPaginatedList) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the transaction.
var (
	bankTransferRequestBreakdownFieldSubtotal = big.NewInt(1 << 0)
	bankTransferRequestBreakdownFieldTip      = big.NewInt(1 << 1)
	bankTransferRequestBreakdownFieldTaxes    = big.NewInt(1 << 2)
)

type BankTransferRequestBreakdown struct {
	// Total amount of the transaction before tax and tip. The value is in the currency's lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Array of tax objects.
	Taxes []*TaxRate `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferRequestBreakdown) GetSubtotal() int64 {
	if b == nil {
		return 0
	}
	return b.Subtotal
}

func (b *BankTransferRequestBreakdown) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *BankTransferRequestBreakdown) GetTaxes() []*TaxRate {
	if b == nil {
		return nil
	}
	return b.Taxes
}

func (b *BankTransferRequestBreakdown) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferRequestBreakdown) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRequestBreakdown) SetSubtotal(subtotal int64) {
	b.Subtotal = subtotal
	b.require(bankTransferRequestBreakdownFieldSubtotal)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRequestBreakdown) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(bankTransferRequestBreakdownFieldTip)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferRequestBreakdown) SetTaxes(taxes []*TaxRate) {
	b.Taxes = taxes
	b.require(bankTransferRequestBreakdownFieldTaxes)
}

func (b *BankTransferRequestBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferRequestBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferRequestBreakdown(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferRequestBreakdown) MarshalJSON() ([]byte, error) {
	type embed BankTransferRequestBreakdown
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferRequestBreakdown) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the transaction.
var (
	bankTransferResultFieldType                  = big.NewInt(1 << 0)
	bankTransferResultFieldStatus                = big.NewInt(1 << 1)
	bankTransferResultFieldAuthorizedAmount      = big.NewInt(1 << 2)
	bankTransferResultFieldCurrency              = big.NewInt(1 << 3)
	bankTransferResultFieldResponseCode          = big.NewInt(1 << 4)
	bankTransferResultFieldResponseMessage       = big.NewInt(1 << 5)
	bankTransferResultFieldProcessorResponseCode = big.NewInt(1 << 6)
)

type BankTransferResult struct {
	// Type of transaction.
	Type BankTransferResultType `json:"type" url:"type"`
	// Status of the transaction.
	Status BankTransferResultStatus `json:"status" url:"status"`
	// Amount of the transaction.
	// **Note:** The amount is negative for a refund.
	AuthorizedAmount *int64   `json:"authorizedAmount,omitempty" url:"authorizedAmount,omitempty"`
	Currency         Currency `json:"currency" url:"currency"`
	// Response from the processor.
	// - `A` - The processor approved the transaction.
	// - `D` - The processor declined the transaction.
	ResponseCode string `json:"responseCode" url:"responseCode"`
	// Description of the response from the processor.
	ResponseMessage *string `json:"responseMessage,omitempty" url:"responseMessage,omitempty"`
	// Original response code that the processor sent.
	ProcessorResponseCode *string `json:"processorResponseCode,omitempty" url:"processorResponseCode,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferResult) GetType() BankTransferResultType {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BankTransferResult) GetStatus() BankTransferResultStatus {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BankTransferResult) GetAuthorizedAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.AuthorizedAmount
}

func (b *BankTransferResult) GetCurrency() Currency {
	if b == nil {
		return ""
	}
	return b.Currency
}

func (b *BankTransferResult) GetResponseCode() string {
	if b == nil {
		return ""
	}
	return b.ResponseCode
}

func (b *BankTransferResult) GetResponseMessage() *string {
	if b == nil {
		return nil
	}
	return b.ResponseMessage
}

func (b *BankTransferResult) GetProcessorResponseCode() *string {
	if b == nil {
		return nil
	}
	return b.ProcessorResponseCode
}

func (b *BankTransferResult) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferResult) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferResult) SetType(type_ BankTransferResultType) {
	b.Type = type_
	b.require(bankTransferResultFieldType)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferResult) SetStatus(status BankTransferResultStatus) {
	b.Status = status
	b.require(bankTransferResultFieldStatus)
}

// SetAuthorizedAmount sets the AuthorizedAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferResult) SetAuthorizedAmount(authorizedAmount *int64) {
	b.AuthorizedAmount = authorizedAmount
	b.require(bankTransferResultFieldAuthorizedAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferResult) SetCurrency(currency Currency) {
	b.Currency = currency
	b.require(bankTransferResultFieldCurrency)
}

// SetResponseCode sets the ResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferResult) SetResponseCode(responseCode string) {
	b.ResponseCode = responseCode
	b.require(bankTransferResultFieldResponseCode)
}

// SetResponseMessage sets the ResponseMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferResult) SetResponseMessage(responseMessage *string) {
	b.ResponseMessage = responseMessage
	b.require(bankTransferResultFieldResponseMessage)
}

// SetProcessorResponseCode sets the ProcessorResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferResult) SetProcessorResponseCode(processorResponseCode *string) {
	b.ProcessorResponseCode = processorResponseCode
	b.require(bankTransferResultFieldProcessorResponseCode)
}

func (b *BankTransferResult) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankTransferResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferResult) MarshalJSON() ([]byte, error) {
	type embed BankTransferResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferResult) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Status of the transaction.
type BankTransferResultStatus string

const (
	BankTransferResultStatusReady    BankTransferResultStatus = "ready"
	BankTransferResultStatusPending  BankTransferResultStatus = "pending"
	BankTransferResultStatusDeclined BankTransferResultStatus = "declined"
	BankTransferResultStatusComplete BankTransferResultStatus = "complete"
	BankTransferResultStatusAdmin    BankTransferResultStatus = "admin"
	BankTransferResultStatusReversal BankTransferResultStatus = "reversal"
	BankTransferResultStatusReturned BankTransferResultStatus = "returned"
)

func NewBankTransferResultStatusFromString(s string) (BankTransferResultStatus, error) {
	switch s {
	case "ready":
		return BankTransferResultStatusReady, nil
	case "pending":
		return BankTransferResultStatusPending, nil
	case "declined":
		return BankTransferResultStatusDeclined, nil
	case "complete":
		return BankTransferResultStatusComplete, nil
	case "admin":
		return BankTransferResultStatusAdmin, nil
	case "reversal":
		return BankTransferResultStatusReversal, nil
	case "returned":
		return BankTransferResultStatusReturned, nil
	}
	var t BankTransferResultStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankTransferResultStatus) Ptr() *BankTransferResultStatus {
	return &b
}

// Type of transaction.
type BankTransferResultType string

const (
	BankTransferResultTypePayment             BankTransferResultType = "payment"
	BankTransferResultTypeRefund              BankTransferResultType = "refund"
	BankTransferResultTypeUnreferencedRefund  BankTransferResultType = "unreferencedRefund"
	BankTransferResultTypeAccountVerification BankTransferResultType = "accountVerification"
)

func NewBankTransferResultTypeFromString(s string) (BankTransferResultType, error) {
	switch s {
	case "payment":
		return BankTransferResultTypePayment, nil
	case "refund":
		return BankTransferResultTypeRefund, nil
	case "unreferencedRefund":
		return BankTransferResultTypeUnreferencedRefund, nil
	case "accountVerification":
		return BankTransferResultTypeAccountVerification, nil
	}
	var t BankTransferResultType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankTransferResultType) Ptr() *BankTransferResultType {
	return &b
}

// Object that contains information about a return.
var (
	bankTransferReturnSummaryFieldPaymentId    = big.NewInt(1 << 0)
	bankTransferReturnSummaryFieldDate         = big.NewInt(1 << 1)
	bankTransferReturnSummaryFieldReturnCode   = big.NewInt(1 << 2)
	bankTransferReturnSummaryFieldReturnReason = big.NewInt(1 << 3)
	bankTransferReturnSummaryFieldRepresented  = big.NewInt(1 << 4)
	bankTransferReturnSummaryFieldLink         = big.NewInt(1 << 5)
)

type BankTransferReturnSummary struct {
	// Unique identifier that our gateway assigned to the payment.
	PaymentId string `json:"paymentId" url:"paymentId"`
	// The date that the check was returned.
	Date time.Time `json:"date" url:"date" format:"date"`
	// The NACHA return code.
	ReturnCode string `json:"returnCode" url:"returnCode"`
	// The reason why the check was returned.
	ReturnReason string `json:"returnReason" url:"returnReason"`
	// Indicates whether the return has been re-presented.
	Represented bool  `json:"represented" url:"represented"`
	Link        *Link `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankTransferReturnSummary) GetPaymentId() string {
	if b == nil {
		return ""
	}
	return b.PaymentId
}

func (b *BankTransferReturnSummary) GetDate() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.Date
}

func (b *BankTransferReturnSummary) GetReturnCode() string {
	if b == nil {
		return ""
	}
	return b.ReturnCode
}

func (b *BankTransferReturnSummary) GetReturnReason() string {
	if b == nil {
		return ""
	}
	return b.ReturnReason
}

func (b *BankTransferReturnSummary) GetRepresented() bool {
	if b == nil {
		return false
	}
	return b.Represented
}

func (b *BankTransferReturnSummary) GetLink() *Link {
	if b == nil {
		return nil
	}
	return b.Link
}

func (b *BankTransferReturnSummary) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankTransferReturnSummary) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferReturnSummary) SetPaymentId(paymentId string) {
	b.PaymentId = paymentId
	b.require(bankTransferReturnSummaryFieldPaymentId)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferReturnSummary) SetDate(date time.Time) {
	b.Date = date
	b.require(bankTransferReturnSummaryFieldDate)
}

// SetReturnCode sets the ReturnCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferReturnSummary) SetReturnCode(returnCode string) {
	b.ReturnCode = returnCode
	b.require(bankTransferReturnSummaryFieldReturnCode)
}

// SetReturnReason sets the ReturnReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferReturnSummary) SetReturnReason(returnReason string) {
	b.ReturnReason = returnReason
	b.require(bankTransferReturnSummaryFieldReturnReason)
}

// SetRepresented sets the Represented field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferReturnSummary) SetRepresented(represented bool) {
	b.Represented = represented
	b.require(bankTransferReturnSummaryFieldRepresented)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferReturnSummary) SetLink(link *Link) {
	b.Link = link
	b.require(bankTransferReturnSummaryFieldLink)
}

func (b *BankTransferReturnSummary) UnmarshalJSON(data []byte) error {
	type embed BankTransferReturnSummary
	var unmarshaler = struct {
		embed
		Date *internal.Date `json:"date"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BankTransferReturnSummary(unmarshaler.embed)
	b.Date = unmarshaler.Date.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankTransferReturnSummary) MarshalJSON() ([]byte, error) {
	type embed BankTransferReturnSummary
	var marshaler = struct {
		embed
		Date *internal.Date `json:"date"`
	}{
		embed: embed(*b),
		Date:  internal.NewDate(b.Date),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankTransferReturnSummary) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the base fees.
var (
	baseIntentFieldId              = big.NewInt(1 << 0)
	baseIntentFieldCreatedDate     = big.NewInt(1 << 1)
	baseIntentFieldLastUpdatedDate = big.NewInt(1 << 2)
	baseIntentFieldStatus          = big.NewInt(1 << 3)
	baseIntentFieldKey             = big.NewInt(1 << 4)
	baseIntentFieldMetadata        = big.NewInt(1 << 5)
)

type BaseIntent struct {
	// Unique identifier of the pricing intent.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Date and time that we received your request to create the pricing intent. We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date and time that the pricing intent was last modified. We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	LastUpdatedDate *time.Time `json:"lastUpdatedDate,omitempty" url:"lastUpdatedDate,omitempty"`
	// Status of the pricing intent. The value can be one of the following:
	// - `active` - We have approved the pricing intent.
	// - `pendingReview` - We have not yet reviewed the pricing intent.
	// - `rejected` - We have rejected the pricing intent.
	Status *BaseIntentStatus `json:"status,omitempty" url:"status,omitempty"`
	// Unique identifier that you can assign to the pricing intent for your own records.
	Key string `json:"key" url:"key"`
	// [Metadata](https://docs.payroc.com/api/metadata) object that contains your custom data.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseIntent) GetId() *string {
	if b == nil {
		return nil
	}
	return b.Id
}

func (b *BaseIntent) GetCreatedDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedDate
}

func (b *BaseIntent) GetLastUpdatedDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.LastUpdatedDate
}

func (b *BaseIntent) GetStatus() *BaseIntentStatus {
	if b == nil {
		return nil
	}
	return b.Status
}

func (b *BaseIntent) GetKey() string {
	if b == nil {
		return ""
	}
	return b.Key
}

func (b *BaseIntent) GetMetadata() map[string]string {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BaseIntent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseIntent) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseIntent) SetId(id *string) {
	b.Id = id
	b.require(baseIntentFieldId)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseIntent) SetCreatedDate(createdDate *time.Time) {
	b.CreatedDate = createdDate
	b.require(baseIntentFieldCreatedDate)
}

// SetLastUpdatedDate sets the LastUpdatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseIntent) SetLastUpdatedDate(lastUpdatedDate *time.Time) {
	b.LastUpdatedDate = lastUpdatedDate
	b.require(baseIntentFieldLastUpdatedDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseIntent) SetStatus(status *BaseIntentStatus) {
	b.Status = status
	b.require(baseIntentFieldStatus)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseIntent) SetKey(key string) {
	b.Key = key
	b.require(baseIntentFieldKey)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseIntent) SetMetadata(metadata map[string]string) {
	b.Metadata = metadata
	b.require(baseIntentFieldMetadata)
}

func (b *BaseIntent) UnmarshalJSON(data []byte) error {
	type embed BaseIntent
	var unmarshaler = struct {
		embed
		CreatedDate     *internal.DateTime `json:"createdDate,omitempty"`
		LastUpdatedDate *internal.DateTime `json:"lastUpdatedDate,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BaseIntent(unmarshaler.embed)
	b.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	b.LastUpdatedDate = unmarshaler.LastUpdatedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseIntent) MarshalJSON() ([]byte, error) {
	type embed BaseIntent
	var marshaler = struct {
		embed
		CreatedDate     *internal.DateTime `json:"createdDate,omitempty"`
		LastUpdatedDate *internal.DateTime `json:"lastUpdatedDate,omitempty"`
	}{
		embed:           embed(*b),
		CreatedDate:     internal.NewOptionalDateTime(b.CreatedDate),
		LastUpdatedDate: internal.NewOptionalDateTime(b.LastUpdatedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseIntent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Status of the pricing intent. The value can be one of the following:
// - `active` - We have approved the pricing intent.
// - `pendingReview` - We have not yet reviewed the pricing intent.
// - `rejected` - We have rejected the pricing intent.
type BaseIntentStatus string

const (
	BaseIntentStatusActive        BaseIntentStatus = "active"
	BaseIntentStatusPendingReview BaseIntentStatus = "pendingReview"
	BaseIntentStatusRejected      BaseIntentStatus = "rejected"
)

func NewBaseIntentStatusFromString(s string) (BaseIntentStatus, error) {
	switch s {
	case "active":
		return BaseIntentStatusActive, nil
	case "pendingReview":
		return BaseIntentStatusPendingReview, nil
	case "rejected":
		return BaseIntentStatusRejected, nil
	}
	var t BaseIntentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BaseIntentStatus) Ptr() *BaseIntentStatus {
	return &b
}

// Object that contains information about U.S. base fees.
var (
	baseUsFieldAddressVerification         = big.NewInt(1 << 0)
	baseUsFieldAnnualFee                   = big.NewInt(1 << 1)
	baseUsFieldRegulatoryAssistanceProgram = big.NewInt(1 << 2)
	baseUsFieldPciNonCompliance            = big.NewInt(1 << 3)
	baseUsFieldMerchantAdvantage           = big.NewInt(1 << 4)
	baseUsFieldPlatinumSecurity            = big.NewInt(1 << 5)
	baseUsFieldMaintenance                 = big.NewInt(1 << 6)
	baseUsFieldMinimum                     = big.NewInt(1 << 7)
	baseUsFieldVoiceAuthorization          = big.NewInt(1 << 8)
	baseUsFieldChargeback                  = big.NewInt(1 << 9)
	baseUsFieldRetrieval                   = big.NewInt(1 << 10)
	baseUsFieldBatch                       = big.NewInt(1 << 11)
	baseUsFieldEarlyTermination            = big.NewInt(1 << 12)
)

type BaseUs struct {
	// Fee for each address verification request. The value is in the currency's lowest denomination, for example, cents.
	AddressVerification *int `json:"addressVerification,omitempty" url:"addressVerification,omitempty"`
	// Object that contains information about the annual fee.
	AnnualFee *BaseUsAnnualFee `json:"annualFee" url:"annualFee"`
	// Annual fee for the regulatory assistance program. The value is in the currency's lowest denomination, for example, cents.
	RegulatoryAssistanceProgram *int `json:"regulatoryAssistanceProgram,omitempty" url:"regulatoryAssistanceProgram,omitempty"`
	// Fee that we apply each month if you aren't compliant with PCI standards. The value is in the currency's lowest denomination, for example, cents.
	PciNonCompliance *int `json:"pciNonCompliance,omitempty" url:"pciNonCompliance,omitempty"`
	// Monthly fee for Payroc Advantage. The value is in the currency's lowest denomination, for example, cents.
	MerchantAdvantage *int `json:"merchantAdvantage,omitempty" url:"merchantAdvantage,omitempty"`
	// Polymorphic object that contains billing details for Platinum Security.
	//
	// The value of the billingFrequency field determines which variant you should use:
	// -	`monthly` - We collect the fee for Platinum Security each month.
	// -	`annual` - We collect the fee for Platinum Security each year.
	PlatinumSecurity *BaseUsPlatinumSecurity `json:"platinumSecurity,omitempty" url:"platinumSecurity,omitempty"`
	// Monthly fee for maintenance. The value is in the currency's lowest denomination, for example, cents.
	Maintenance int `json:"maintenance" url:"maintenance"`
	// Monthly fee that we charge when the merchant doesn't meet the minimum fee amount. This monthly fee is in the currency's lowest denomination, for example, cents.
	Minimum int `json:"minimum" url:"minimum"`
	// Fee for each voice authorization. The value is in the currency's lowest denomination, for example, cents.
	VoiceAuthorization *int `json:"voiceAuthorization,omitempty" url:"voiceAuthorization,omitempty"`
	// Fee for each chargeback. The value is in the currency's lowest denomination, for example, cents.
	Chargeback *int `json:"chargeback,omitempty" url:"chargeback,omitempty"`
	// Fee for each retrieval. The value is in the currency's lowest denomination, for example, cents.
	Retrieval *int `json:"retrieval,omitempty" url:"retrieval,omitempty"`
	// Fee for each batch. The value is in the currency's lowest denomination, for example, cents.
	Batch int `json:"batch" url:"batch"`
	// Fee for early termination. The value is in the currency's lowest denomination, for example, cents.
	EarlyTermination *int `json:"earlyTermination,omitempty" url:"earlyTermination,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseUs) GetAddressVerification() *int {
	if b == nil {
		return nil
	}
	return b.AddressVerification
}

func (b *BaseUs) GetAnnualFee() *BaseUsAnnualFee {
	if b == nil {
		return nil
	}
	return b.AnnualFee
}

func (b *BaseUs) GetRegulatoryAssistanceProgram() *int {
	if b == nil {
		return nil
	}
	return b.RegulatoryAssistanceProgram
}

func (b *BaseUs) GetPciNonCompliance() *int {
	if b == nil {
		return nil
	}
	return b.PciNonCompliance
}

func (b *BaseUs) GetMerchantAdvantage() *int {
	if b == nil {
		return nil
	}
	return b.MerchantAdvantage
}

func (b *BaseUs) GetPlatinumSecurity() *BaseUsPlatinumSecurity {
	if b == nil {
		return nil
	}
	return b.PlatinumSecurity
}

func (b *BaseUs) GetMaintenance() int {
	if b == nil {
		return 0
	}
	return b.Maintenance
}

func (b *BaseUs) GetMinimum() int {
	if b == nil {
		return 0
	}
	return b.Minimum
}

func (b *BaseUs) GetVoiceAuthorization() *int {
	if b == nil {
		return nil
	}
	return b.VoiceAuthorization
}

func (b *BaseUs) GetChargeback() *int {
	if b == nil {
		return nil
	}
	return b.Chargeback
}

func (b *BaseUs) GetRetrieval() *int {
	if b == nil {
		return nil
	}
	return b.Retrieval
}

func (b *BaseUs) GetBatch() int {
	if b == nil {
		return 0
	}
	return b.Batch
}

func (b *BaseUs) GetEarlyTermination() *int {
	if b == nil {
		return nil
	}
	return b.EarlyTermination
}

func (b *BaseUs) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseUs) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetAddressVerification sets the AddressVerification field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetAddressVerification(addressVerification *int) {
	b.AddressVerification = addressVerification
	b.require(baseUsFieldAddressVerification)
}

// SetAnnualFee sets the AnnualFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetAnnualFee(annualFee *BaseUsAnnualFee) {
	b.AnnualFee = annualFee
	b.require(baseUsFieldAnnualFee)
}

// SetRegulatoryAssistanceProgram sets the RegulatoryAssistanceProgram field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetRegulatoryAssistanceProgram(regulatoryAssistanceProgram *int) {
	b.RegulatoryAssistanceProgram = regulatoryAssistanceProgram
	b.require(baseUsFieldRegulatoryAssistanceProgram)
}

// SetPciNonCompliance sets the PciNonCompliance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetPciNonCompliance(pciNonCompliance *int) {
	b.PciNonCompliance = pciNonCompliance
	b.require(baseUsFieldPciNonCompliance)
}

// SetMerchantAdvantage sets the MerchantAdvantage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetMerchantAdvantage(merchantAdvantage *int) {
	b.MerchantAdvantage = merchantAdvantage
	b.require(baseUsFieldMerchantAdvantage)
}

// SetPlatinumSecurity sets the PlatinumSecurity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetPlatinumSecurity(platinumSecurity *BaseUsPlatinumSecurity) {
	b.PlatinumSecurity = platinumSecurity
	b.require(baseUsFieldPlatinumSecurity)
}

// SetMaintenance sets the Maintenance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetMaintenance(maintenance int) {
	b.Maintenance = maintenance
	b.require(baseUsFieldMaintenance)
}

// SetMinimum sets the Minimum field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetMinimum(minimum int) {
	b.Minimum = minimum
	b.require(baseUsFieldMinimum)
}

// SetVoiceAuthorization sets the VoiceAuthorization field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetVoiceAuthorization(voiceAuthorization *int) {
	b.VoiceAuthorization = voiceAuthorization
	b.require(baseUsFieldVoiceAuthorization)
}

// SetChargeback sets the Chargeback field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetChargeback(chargeback *int) {
	b.Chargeback = chargeback
	b.require(baseUsFieldChargeback)
}

// SetRetrieval sets the Retrieval field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetRetrieval(retrieval *int) {
	b.Retrieval = retrieval
	b.require(baseUsFieldRetrieval)
}

// SetBatch sets the Batch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetBatch(batch int) {
	b.Batch = batch
	b.require(baseUsFieldBatch)
}

// SetEarlyTermination sets the EarlyTermination field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUs) SetEarlyTermination(earlyTermination *int) {
	b.EarlyTermination = earlyTermination
	b.require(baseUsFieldEarlyTermination)
}

func (b *BaseUs) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseUs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseUs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseUs) MarshalJSON() ([]byte, error) {
	type embed BaseUs
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseUs) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	baseUsAnnualFieldAmount = big.NewInt(1 << 0)
)

type BaseUsAnnual struct {
	// Fee for the Platinum Security, this is returned in the lowest unit of currency. For example, cents.
	Amount *int `json:"amount,omitempty" url:"amount,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseUsAnnual) GetAmount() *int {
	if b == nil {
		return nil
	}
	return b.Amount
}

func (b *BaseUsAnnual) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseUsAnnual) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUsAnnual) SetAmount(amount *int) {
	b.Amount = amount
	b.require(baseUsAnnualFieldAmount)
}

func (b *BaseUsAnnual) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseUsAnnual
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseUsAnnual(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseUsAnnual) MarshalJSON() ([]byte, error) {
	type embed BaseUsAnnual
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseUsAnnual) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the annual fee.
var (
	baseUsAnnualFeeFieldBillInMonth = big.NewInt(1 << 0)
	baseUsAnnualFeeFieldAmount      = big.NewInt(1 << 1)
)

type BaseUsAnnualFee struct {
	// Indicates whether we collect the annual fee in June or December.
	BillInMonth *BaseUsAnnualFeeBillInMonth `json:"billInMonth,omitempty" url:"billInMonth,omitempty"`
	// Annual fee. The value is in the currency's lowest denomination, for example, cents.
	Amount int `json:"amount" url:"amount"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseUsAnnualFee) GetBillInMonth() *BaseUsAnnualFeeBillInMonth {
	if b == nil {
		return nil
	}
	return b.BillInMonth
}

func (b *BaseUsAnnualFee) GetAmount() int {
	if b == nil {
		return 0
	}
	return b.Amount
}

func (b *BaseUsAnnualFee) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseUsAnnualFee) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetBillInMonth sets the BillInMonth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUsAnnualFee) SetBillInMonth(billInMonth *BaseUsAnnualFeeBillInMonth) {
	b.BillInMonth = billInMonth
	b.require(baseUsAnnualFeeFieldBillInMonth)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUsAnnualFee) SetAmount(amount int) {
	b.Amount = amount
	b.require(baseUsAnnualFeeFieldAmount)
}

func (b *BaseUsAnnualFee) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseUsAnnualFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseUsAnnualFee(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseUsAnnualFee) MarshalJSON() ([]byte, error) {
	type embed BaseUsAnnualFee
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseUsAnnualFee) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Indicates whether we collect the annual fee in June or December.
type BaseUsAnnualFeeBillInMonth string

const (
	BaseUsAnnualFeeBillInMonthJune     BaseUsAnnualFeeBillInMonth = "june"
	BaseUsAnnualFeeBillInMonthDecember BaseUsAnnualFeeBillInMonth = "december"
)

func NewBaseUsAnnualFeeBillInMonthFromString(s string) (BaseUsAnnualFeeBillInMonth, error) {
	switch s {
	case "june":
		return BaseUsAnnualFeeBillInMonthJune, nil
	case "december":
		return BaseUsAnnualFeeBillInMonthDecember, nil
	}
	var t BaseUsAnnualFeeBillInMonth
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BaseUsAnnualFeeBillInMonth) Ptr() *BaseUsAnnualFeeBillInMonth {
	return &b
}

var (
	baseUsMonthlyFieldAmount = big.NewInt(1 << 0)
)

type BaseUsMonthly struct {
	// Fee for Platinum Security. The value is in the currency's lowest denomination, for example, cents.
	Amount *int `json:"amount,omitempty" url:"amount,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseUsMonthly) GetAmount() *int {
	if b == nil {
		return nil
	}
	return b.Amount
}

func (b *BaseUsMonthly) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseUsMonthly) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseUsMonthly) SetAmount(amount *int) {
	b.Amount = amount
	b.require(baseUsMonthlyFieldAmount)
}

func (b *BaseUsMonthly) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseUsMonthly
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseUsMonthly(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseUsMonthly) MarshalJSON() ([]byte, error) {
	type embed BaseUsMonthly
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseUsMonthly) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Polymorphic object that contains billing details for Platinum Security.
//
// The value of the billingFrequency field determines which variant you should use:
// -	`monthly` - We collect the fee for Platinum Security each month.
// -	`annual` - We collect the fee for Platinum Security each year.
type BaseUsPlatinumSecurity struct {
	BillingFrequency string
	Monthly          *BaseUsMonthly
	Annual           *BaseUsAnnual
}

func (b *BaseUsPlatinumSecurity) GetBillingFrequency() string {
	if b == nil {
		return ""
	}
	return b.BillingFrequency
}

func (b *BaseUsPlatinumSecurity) GetMonthly() *BaseUsMonthly {
	if b == nil {
		return nil
	}
	return b.Monthly
}

func (b *BaseUsPlatinumSecurity) GetAnnual() *BaseUsAnnual {
	if b == nil {
		return nil
	}
	return b.Annual
}

func (b *BaseUsPlatinumSecurity) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		BillingFrequency string `json:"billingFrequency"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.BillingFrequency = unmarshaler.BillingFrequency
	if unmarshaler.BillingFrequency == "" {
		return fmt.Errorf("%T did not include discriminant billingFrequency", b)
	}
	switch unmarshaler.BillingFrequency {
	case "monthly":
		value := new(BaseUsMonthly)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Monthly = value
	case "annual":
		value := new(BaseUsAnnual)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Annual = value
	}
	return nil
}

func (b BaseUsPlatinumSecurity) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Monthly != nil {
		return internal.MarshalJSONWithExtraProperty(b.Monthly, "billingFrequency", "monthly")
	}
	if b.Annual != nil {
		return internal.MarshalJSONWithExtraProperty(b.Annual, "billingFrequency", "annual")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BaseUsPlatinumSecurityVisitor interface {
	VisitMonthly(*BaseUsMonthly) error
	VisitAnnual(*BaseUsAnnual) error
}

func (b *BaseUsPlatinumSecurity) Accept(visitor BaseUsPlatinumSecurityVisitor) error {
	if b.Monthly != nil {
		return visitor.VisitMonthly(b.Monthly)
	}
	if b.Annual != nil {
		return visitor.VisitAnnual(b.Annual)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BaseUsPlatinumSecurity) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Monthly != nil {
		fields = append(fields, "monthly")
	}
	if b.Annual != nil {
		fields = append(fields, "annual")
	}
	if len(fields) == 0 {
		if b.BillingFrequency != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.BillingFrequency)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.BillingFrequency != "" {
		field := fields[0]
		if b.BillingFrequency != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.BillingFrequency,
				b,
			)
		}
	}
	return nil
}

var (
	batchFieldBatchId          = big.NewInt(1 << 0)
	batchFieldDate             = big.NewInt(1 << 1)
	batchFieldCreatedDate      = big.NewInt(1 << 2)
	batchFieldLastModifiedDate = big.NewInt(1 << 3)
	batchFieldSaleAmount       = big.NewInt(1 << 4)
	batchFieldHeldAmount       = big.NewInt(1 << 5)
	batchFieldReturnAmount     = big.NewInt(1 << 6)
	batchFieldTransactionCount = big.NewInt(1 << 7)
	batchFieldCurrency         = big.NewInt(1 << 8)
	batchFieldMerchant         = big.NewInt(1 << 9)
	batchFieldLinks            = big.NewInt(1 << 10)
)

type Batch struct {
	// Unique identifier that we assigned to the batch.
	BatchId *int `json:"batchId,omitempty" url:"batchId,omitempty"`
	// Date that the merchant submitted the batch. The format of this value is **YYYY-MM-DD**.
	Date *time.Time `json:"date,omitempty" url:"date,omitempty" format:"date"`
	// Date that we created a record for the batch. The format of this value is **YYYY-MM-DD**.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty" format:"date"`
	// Date that the batch was last changed. The format of this value is **YYYY-MM-DD**.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty" format:"date"`
	// Total value of sales in the batch. We return the value in the currency's lowest denomination, for example, cents.
	SaleAmount *int64 `json:"saleAmount,omitempty" url:"saleAmount,omitempty"`
	// Total value of authorizations in the batch. We return the value in the currency's lowest denomination, for example, cents.
	HeldAmount *int64 `json:"heldAmount,omitempty" url:"heldAmount,omitempty"`
	// Total value of returns in the batch. We return the value in the currency's lowest denomination, for example, cents.
	ReturnAmount *int64 `json:"returnAmount,omitempty" url:"returnAmount,omitempty"`
	// Total number of transactions in the batch.
	TransactionCount *int64 `json:"transactionCount,omitempty" url:"transactionCount,omitempty"`
	// Currency of the transactions in the batch. The value for the currency follows the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) standard.
	Currency *string          `json:"currency,omitempty" url:"currency,omitempty"`
	Merchant *MerchantSummary `json:"merchant,omitempty" url:"merchant,omitempty"`
	Links    []*Link          `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Batch) GetBatchId() *int {
	if b == nil {
		return nil
	}
	return b.BatchId
}

func (b *Batch) GetDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.Date
}

func (b *Batch) GetCreatedDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedDate
}

func (b *Batch) GetLastModifiedDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.LastModifiedDate
}

func (b *Batch) GetSaleAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.SaleAmount
}

func (b *Batch) GetHeldAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.HeldAmount
}

func (b *Batch) GetReturnAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.ReturnAmount
}

func (b *Batch) GetTransactionCount() *int64 {
	if b == nil {
		return nil
	}
	return b.TransactionCount
}

func (b *Batch) GetCurrency() *string {
	if b == nil {
		return nil
	}
	return b.Currency
}

func (b *Batch) GetMerchant() *MerchantSummary {
	if b == nil {
		return nil
	}
	return b.Merchant
}

func (b *Batch) GetLinks() []*Link {
	if b == nil {
		return nil
	}
	return b.Links
}

func (b *Batch) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Batch) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetBatchId sets the BatchId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetBatchId(batchId *int) {
	b.BatchId = batchId
	b.require(batchFieldBatchId)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetDate(date *time.Time) {
	b.Date = date
	b.require(batchFieldDate)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetCreatedDate(createdDate *time.Time) {
	b.CreatedDate = createdDate
	b.require(batchFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetLastModifiedDate(lastModifiedDate *time.Time) {
	b.LastModifiedDate = lastModifiedDate
	b.require(batchFieldLastModifiedDate)
}

// SetSaleAmount sets the SaleAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetSaleAmount(saleAmount *int64) {
	b.SaleAmount = saleAmount
	b.require(batchFieldSaleAmount)
}

// SetHeldAmount sets the HeldAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetHeldAmount(heldAmount *int64) {
	b.HeldAmount = heldAmount
	b.require(batchFieldHeldAmount)
}

// SetReturnAmount sets the ReturnAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetReturnAmount(returnAmount *int64) {
	b.ReturnAmount = returnAmount
	b.require(batchFieldReturnAmount)
}

// SetTransactionCount sets the TransactionCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetTransactionCount(transactionCount *int64) {
	b.TransactionCount = transactionCount
	b.require(batchFieldTransactionCount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetCurrency(currency *string) {
	b.Currency = currency
	b.require(batchFieldCurrency)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetMerchant(merchant *MerchantSummary) {
	b.Merchant = merchant
	b.require(batchFieldMerchant)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Batch) SetLinks(links []*Link) {
	b.Links = links
	b.require(batchFieldLinks)
}

func (b *Batch) UnmarshalJSON(data []byte) error {
	type embed Batch
	var unmarshaler = struct {
		embed
		Date             *internal.Date `json:"date,omitempty"`
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Batch(unmarshaler.embed)
	b.Date = unmarshaler.Date.TimePtr()
	b.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	b.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Batch) MarshalJSON() ([]byte, error) {
	type embed Batch
	var marshaler = struct {
		embed
		Date             *internal.Date `json:"date,omitempty"`
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*b),
		Date:             internal.NewOptionalDate(b.Date),
		CreatedDate:      internal.NewOptionalDate(b.CreatedDate),
		LastModifiedDate: internal.NewOptionalDate(b.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *Batch) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the batch. If we can't match a dispute to a batch, we don't return 'batch' object.
var (
	batchSummaryFieldBatchId = big.NewInt(1 << 0)
	batchSummaryFieldDate    = big.NewInt(1 << 1)
	batchSummaryFieldCycle   = big.NewInt(1 << 2)
	batchSummaryFieldLink    = big.NewInt(1 << 3)
)

type BatchSummary struct {
	// Unique identifier of the batch.
	BatchId *int `json:"batchId,omitempty" url:"batchId,omitempty"`
	// Date that the merchant submitted the batch.
	Date *time.Time `json:"date,omitempty" url:"date,omitempty" format:"date"`
	// Indicates the cycle that contains the batch.
	Cycle *string `json:"cycle,omitempty" url:"cycle,omitempty"`
	Link  *Link   `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchSummary) GetBatchId() *int {
	if b == nil {
		return nil
	}
	return b.BatchId
}

func (b *BatchSummary) GetDate() *time.Time {
	if b == nil {
		return nil
	}
	return b.Date
}

func (b *BatchSummary) GetCycle() *string {
	if b == nil {
		return nil
	}
	return b.Cycle
}

func (b *BatchSummary) GetLink() *Link {
	if b == nil {
		return nil
	}
	return b.Link
}

func (b *BatchSummary) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchSummary) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetBatchId sets the BatchId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BatchSummary) SetBatchId(batchId *int) {
	b.BatchId = batchId
	b.require(batchSummaryFieldBatchId)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BatchSummary) SetDate(date *time.Time) {
	b.Date = date
	b.require(batchSummaryFieldDate)
}

// SetCycle sets the Cycle field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BatchSummary) SetCycle(cycle *string) {
	b.Cycle = cycle
	b.require(batchSummaryFieldCycle)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BatchSummary) SetLink(link *Link) {
	b.Link = link
	b.require(batchSummaryFieldLink)
}

func (b *BatchSummary) UnmarshalJSON(data []byte) error {
	type embed BatchSummary
	var unmarshaler = struct {
		embed
		Date *internal.Date `json:"date,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BatchSummary(unmarshaler.embed)
	b.Date = unmarshaler.Date.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchSummary) MarshalJSON() ([]byte, error) {
	type embed BatchSummary
	var marshaler = struct {
		embed
		Date *internal.Date `json:"date,omitempty"`
	}{
		embed: embed(*b),
		Date:  internal.NewOptionalDate(b.Date),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BatchSummary) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	breakdownFieldSubtotal       = big.NewInt(1 << 0)
	breakdownFieldCashbackAmount = big.NewInt(1 << 1)
	breakdownFieldTip            = big.NewInt(1 << 2)
	breakdownFieldSurcharge      = big.NewInt(1 << 3)
	breakdownFieldDualPricing    = big.NewInt(1 << 4)
	breakdownFieldTaxes          = big.NewInt(1 << 5)
)

type Breakdown struct {
	// Amount of the transaction before tax and fees. The value is in the currency’s lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Amount of cashback for the transaction.
	CashbackAmount *int64 `json:"cashbackAmount,omitempty" url:"cashbackAmount,omitempty"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Object that contains surcharge information for the transaction.
	Surcharge *Surcharge `json:"surcharge,omitempty" url:"surcharge,omitempty"`
	// Object that contains dual pricing information for the transaction.
	DualPricing *DualPricing `json:"dualPricing,omitempty" url:"dualPricing,omitempty"`
	// List of taxes.
	Taxes []*RetrievedTax `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Breakdown) GetSubtotal() int64 {
	if b == nil {
		return 0
	}
	return b.Subtotal
}

func (b *Breakdown) GetCashbackAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.CashbackAmount
}

func (b *Breakdown) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *Breakdown) GetSurcharge() *Surcharge {
	if b == nil {
		return nil
	}
	return b.Surcharge
}

func (b *Breakdown) GetDualPricing() *DualPricing {
	if b == nil {
		return nil
	}
	return b.DualPricing
}

func (b *Breakdown) GetTaxes() []*RetrievedTax {
	if b == nil {
		return nil
	}
	return b.Taxes
}

func (b *Breakdown) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Breakdown) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Breakdown) SetSubtotal(subtotal int64) {
	b.Subtotal = subtotal
	b.require(breakdownFieldSubtotal)
}

// SetCashbackAmount sets the CashbackAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Breakdown) SetCashbackAmount(cashbackAmount *int64) {
	b.CashbackAmount = cashbackAmount
	b.require(breakdownFieldCashbackAmount)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Breakdown) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(breakdownFieldTip)
}

// SetSurcharge sets the Surcharge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Breakdown) SetSurcharge(surcharge *Surcharge) {
	b.Surcharge = surcharge
	b.require(breakdownFieldSurcharge)
}

// SetDualPricing sets the DualPricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Breakdown) SetDualPricing(dualPricing *DualPricing) {
	b.DualPricing = dualPricing
	b.require(breakdownFieldDualPricing)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Breakdown) SetTaxes(taxes []*RetrievedTax) {
	b.Taxes = taxes
	b.require(breakdownFieldTaxes)
}

func (b *Breakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler Breakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Breakdown(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Breakdown) MarshalJSON() ([]byte, error) {
	type embed Breakdown
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *Breakdown) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the tip amount of a transaction.
var (
	breakdownAdjustmentFieldTip = big.NewInt(1 << 0)
)

type BreakdownAdjustment struct {
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BreakdownAdjustment) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *BreakdownAdjustment) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BreakdownAdjustment) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownAdjustment) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(breakdownAdjustmentFieldTip)
}

func (b *BreakdownAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler BreakdownAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BreakdownAdjustment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BreakdownAdjustment) MarshalJSON() ([]byte, error) {
	type embed BreakdownAdjustment
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BreakdownAdjustment) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the breakdown of the transaction.
var (
	breakdownBaseFieldSubtotal       = big.NewInt(1 << 0)
	breakdownBaseFieldCashbackAmount = big.NewInt(1 << 1)
	breakdownBaseFieldTip            = big.NewInt(1 << 2)
	breakdownBaseFieldSurcharge      = big.NewInt(1 << 3)
	breakdownBaseFieldDualPricing    = big.NewInt(1 << 4)
)

type BreakdownBase struct {
	// Amount of the transaction before tax and fees. The value is in the currency’s lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Amount of cashback for the transaction.
	CashbackAmount *int64 `json:"cashbackAmount,omitempty" url:"cashbackAmount,omitempty"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Object that contains surcharge information for the transaction.
	Surcharge *Surcharge `json:"surcharge,omitempty" url:"surcharge,omitempty"`
	// Object that contains dual pricing information for the transaction.
	DualPricing *DualPricing `json:"dualPricing,omitempty" url:"dualPricing,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BreakdownBase) GetSubtotal() int64 {
	if b == nil {
		return 0
	}
	return b.Subtotal
}

func (b *BreakdownBase) GetCashbackAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.CashbackAmount
}

func (b *BreakdownBase) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *BreakdownBase) GetSurcharge() *Surcharge {
	if b == nil {
		return nil
	}
	return b.Surcharge
}

func (b *BreakdownBase) GetDualPricing() *DualPricing {
	if b == nil {
		return nil
	}
	return b.DualPricing
}

func (b *BreakdownBase) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BreakdownBase) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownBase) SetSubtotal(subtotal int64) {
	b.Subtotal = subtotal
	b.require(breakdownBaseFieldSubtotal)
}

// SetCashbackAmount sets the CashbackAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownBase) SetCashbackAmount(cashbackAmount *int64) {
	b.CashbackAmount = cashbackAmount
	b.require(breakdownBaseFieldCashbackAmount)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownBase) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(breakdownBaseFieldTip)
}

// SetSurcharge sets the Surcharge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownBase) SetSurcharge(surcharge *Surcharge) {
	b.Surcharge = surcharge
	b.require(breakdownBaseFieldSurcharge)
}

// SetDualPricing sets the DualPricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownBase) SetDualPricing(dualPricing *DualPricing) {
	b.DualPricing = dualPricing
	b.require(breakdownBaseFieldDualPricing)
}

func (b *BreakdownBase) UnmarshalJSON(data []byte) error {
	type unmarshaler BreakdownBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BreakdownBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BreakdownBase) MarshalJSON() ([]byte, error) {
	type embed BreakdownBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BreakdownBase) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	breakdownForPaymentInstructionsFieldSubtotal       = big.NewInt(1 << 0)
	breakdownForPaymentInstructionsFieldCashbackAmount = big.NewInt(1 << 1)
	breakdownForPaymentInstructionsFieldTip            = big.NewInt(1 << 2)
	breakdownForPaymentInstructionsFieldSurcharge      = big.NewInt(1 << 3)
	breakdownForPaymentInstructionsFieldDualPricing    = big.NewInt(1 << 4)
	breakdownForPaymentInstructionsFieldTaxes          = big.NewInt(1 << 5)
)

type BreakdownForPaymentInstructions struct {
	// Amount of the transaction before tax and fees. The value is in the currency’s lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Amount of cashback for the transaction.
	CashbackAmount *int64 `json:"cashbackAmount,omitempty" url:"cashbackAmount,omitempty"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Object that contains surcharge information for the transaction.
	Surcharge *Surcharge `json:"surcharge,omitempty" url:"surcharge,omitempty"`
	// Object that contains dual pricing information for the transaction.
	DualPricing *DualPricing `json:"dualPricing,omitempty" url:"dualPricing,omitempty"`
	// List of taxes.
	Taxes []*TaxRate `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BreakdownForPaymentInstructions) GetSubtotal() int64 {
	if b == nil {
		return 0
	}
	return b.Subtotal
}

func (b *BreakdownForPaymentInstructions) GetCashbackAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.CashbackAmount
}

func (b *BreakdownForPaymentInstructions) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *BreakdownForPaymentInstructions) GetSurcharge() *Surcharge {
	if b == nil {
		return nil
	}
	return b.Surcharge
}

func (b *BreakdownForPaymentInstructions) GetDualPricing() *DualPricing {
	if b == nil {
		return nil
	}
	return b.DualPricing
}

func (b *BreakdownForPaymentInstructions) GetTaxes() []*TaxRate {
	if b == nil {
		return nil
	}
	return b.Taxes
}

func (b *BreakdownForPaymentInstructions) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BreakdownForPaymentInstructions) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownForPaymentInstructions) SetSubtotal(subtotal int64) {
	b.Subtotal = subtotal
	b.require(breakdownForPaymentInstructionsFieldSubtotal)
}

// SetCashbackAmount sets the CashbackAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownForPaymentInstructions) SetCashbackAmount(cashbackAmount *int64) {
	b.CashbackAmount = cashbackAmount
	b.require(breakdownForPaymentInstructionsFieldCashbackAmount)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownForPaymentInstructions) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(breakdownForPaymentInstructionsFieldTip)
}

// SetSurcharge sets the Surcharge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownForPaymentInstructions) SetSurcharge(surcharge *Surcharge) {
	b.Surcharge = surcharge
	b.require(breakdownForPaymentInstructionsFieldSurcharge)
}

// SetDualPricing sets the DualPricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownForPaymentInstructions) SetDualPricing(dualPricing *DualPricing) {
	b.DualPricing = dualPricing
	b.require(breakdownForPaymentInstructionsFieldDualPricing)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownForPaymentInstructions) SetTaxes(taxes []*TaxRate) {
	b.Taxes = taxes
	b.require(breakdownForPaymentInstructionsFieldTaxes)
}

func (b *BreakdownForPaymentInstructions) UnmarshalJSON(data []byte) error {
	type unmarshaler BreakdownForPaymentInstructions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BreakdownForPaymentInstructions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BreakdownForPaymentInstructions) MarshalJSON() ([]byte, error) {
	type embed BreakdownForPaymentInstructions
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BreakdownForPaymentInstructions) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	breakdownRequestFieldSubtotal       = big.NewInt(1 << 0)
	breakdownRequestFieldCashbackAmount = big.NewInt(1 << 1)
	breakdownRequestFieldTip            = big.NewInt(1 << 2)
	breakdownRequestFieldSurcharge      = big.NewInt(1 << 3)
	breakdownRequestFieldDualPricing    = big.NewInt(1 << 4)
	breakdownRequestFieldTaxes          = big.NewInt(1 << 5)
)

type BreakdownRequest struct {
	// Amount of the transaction before tax and fees. The value is in the currency’s lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Amount of cashback for the transaction.
	CashbackAmount *int64 `json:"cashbackAmount,omitempty" url:"cashbackAmount,omitempty"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Object that contains surcharge information for the transaction.
	Surcharge *Surcharge `json:"surcharge,omitempty" url:"surcharge,omitempty"`
	// Object that contains dual pricing information for the transaction.
	DualPricing *DualPricing `json:"dualPricing,omitempty" url:"dualPricing,omitempty"`
	// Array of polymorphic tax objects, which contain information about a tax.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`amount` - Tax is a fixed amount.
	// -	`rate` - Tax is a percentage.
	Taxes []*Tax `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BreakdownRequest) GetSubtotal() int64 {
	if b == nil {
		return 0
	}
	return b.Subtotal
}

func (b *BreakdownRequest) GetCashbackAmount() *int64 {
	if b == nil {
		return nil
	}
	return b.CashbackAmount
}

func (b *BreakdownRequest) GetTip() *Tip {
	if b == nil {
		return nil
	}
	return b.Tip
}

func (b *BreakdownRequest) GetSurcharge() *Surcharge {
	if b == nil {
		return nil
	}
	return b.Surcharge
}

func (b *BreakdownRequest) GetDualPricing() *DualPricing {
	if b == nil {
		return nil
	}
	return b.DualPricing
}

func (b *BreakdownRequest) GetTaxes() []*Tax {
	if b == nil {
		return nil
	}
	return b.Taxes
}

func (b *BreakdownRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BreakdownRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownRequest) SetSubtotal(subtotal int64) {
	b.Subtotal = subtotal
	b.require(breakdownRequestFieldSubtotal)
}

// SetCashbackAmount sets the CashbackAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownRequest) SetCashbackAmount(cashbackAmount *int64) {
	b.CashbackAmount = cashbackAmount
	b.require(breakdownRequestFieldCashbackAmount)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownRequest) SetTip(tip *Tip) {
	b.Tip = tip
	b.require(breakdownRequestFieldTip)
}

// SetSurcharge sets the Surcharge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownRequest) SetSurcharge(surcharge *Surcharge) {
	b.Surcharge = surcharge
	b.require(breakdownRequestFieldSurcharge)
}

// SetDualPricing sets the DualPricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownRequest) SetDualPricing(dualPricing *DualPricing) {
	b.DualPricing = dualPricing
	b.require(breakdownRequestFieldDualPricing)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BreakdownRequest) SetTaxes(taxes []*Tax) {
	b.Taxes = taxes
	b.require(breakdownRequestFieldTaxes)
}

func (b *BreakdownRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BreakdownRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BreakdownRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BreakdownRequest) MarshalJSON() ([]byte, error) {
	type embed BreakdownRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BreakdownRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Object that contains information about the business.
var (
	businessFieldName               = big.NewInt(1 << 0)
	businessFieldTaxId              = big.NewInt(1 << 1)
	businessFieldOrganizationType   = big.NewInt(1 << 2)
	businessFieldCountryOfOperation = big.NewInt(1 << 3)
	businessFieldAddresses          = big.NewInt(1 << 4)
	businessFieldContactMethods     = big.NewInt(1 << 5)
)

type Business struct {
	// Legal name of the business.
	Name string `json:"name" url:"name"`
	// Tax ID of the business.
	TaxId string `json:"taxId" url:"taxId"`
	// Type of organization.
	OrganizationType BusinessOrganizationType `json:"organizationType" url:"organizationType"`
	// Two-digit code for the country that the business operates in. The format follows the [ISO-3166](https://www.iso.org/iso-3166-country-codes.html) standard.
	CountryOfOperation *BusinessCountryOfOperation `json:"countryOfOperation,omitempty" url:"countryOfOperation,omitempty"`
	// Array of polymorphic objects that contain address information for the business.
	Addresses []*LegalAddress `json:"addresses" url:"addresses"`
	// Array of polymorphic objects, which contain contact information.
	//
	// **Note:** You must provide an email address.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods" url:"contactMethods"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Business) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *Business) GetTaxId() string {
	if b == nil {
		return ""
	}
	return b.TaxId
}

func (b *Business) GetOrganizationType() BusinessOrganizationType {
	if b == nil {
		return ""
	}
	return b.OrganizationType
}

func (b *Business) GetCountryOfOperation() *BusinessCountryOfOperation {
	if b == nil {
		return nil
	}
	return b.CountryOfOperation
}

func (b *Business) GetAddresses() []*LegalAddress {
	if b == nil {
		return nil
	}
	return b.Addresses
}

func (b *Business) GetContactMethods() []*ContactMethod {
	if b == nil {
		return nil
	}
	return b.ContactMethods
}

func (b *Business) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Business) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Business) SetName(name string) {
	b.Name = name
	b.require(businessFieldName)
}

// SetTaxId sets the TaxId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Business) SetTaxId(taxId string) {
	b.TaxId = taxId
	b.require(businessFieldTaxId)
}

// SetOrganizationType sets the OrganizationType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Business) SetOrganizationType(organizationType BusinessOrganizationType) {
	b.OrganizationType = organizationType
	b.require(businessFieldOrganizationType)
}

// SetCountryOfOperation sets the CountryOfOperation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Business) SetCountryOfOperation(countryOfOperation *BusinessCountryOfOperation) {
	b.CountryOfOperation = countryOfOperation
	b.require(businessFieldCountryOfOperation)
}

// SetAddresses sets the Addresses field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Business) SetAddresses(addresses []*LegalAddress) {
	b.Addresses = addresses
	b.require(businessFieldAddresses)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *Business) SetContactMethods(contactMethods []*ContactMethod) {
	b.ContactMethods = contactMethods
	b.require(businessFieldContactMethods)
}

func (b *Business) UnmarshalJSON(data []byte) error {
	type unmarshaler Business
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Business(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Business) MarshalJSON() ([]byte, error) {
	type embed Business
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *Business) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Two-digit code for the country that the business operates in. The format follows the [ISO-3166](https://www.iso.org/iso-3166-country-codes.html) standard.
type BusinessCountryOfOperation string

const (
	BusinessCountryOfOperationUs BusinessCountryOfOperation = "US"
)

func NewBusinessCountryOfOperationFromString(s string) (BusinessCountryOfOperation, error) {
	switch s {
	case "US":
		return BusinessCountryOfOperationUs, nil
	}
	var t BusinessCountryOfOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessCountryOfOperation) Ptr() *BusinessCountryOfOperation {
	return &b
}

// Type of organization.
type BusinessOrganizationType string

const (
	BusinessOrganizationTypePrivateCorporation BusinessOrganizationType = "privateCorporation"
	BusinessOrganizationTypePublicCorporation  BusinessOrganizationType = "publicCorporation"
	BusinessOrganizationTypeNonProfit          BusinessOrganizationType = "nonProfit"
	BusinessOrganizationTypePrivateLlc         BusinessOrganizationType = "privateLlc"
	BusinessOrganizationTypePublicLlc          BusinessOrganizationType = "publicLlc"
	BusinessOrganizationTypePrivatePartnership BusinessOrganizationType = "privatePartnership"
	BusinessOrganizationTypePublicPartnership  BusinessOrganizationType = "publicPartnership"
	BusinessOrganizationTypeSoleProprietor     BusinessOrganizationType = "soleProprietor"
)

func NewBusinessOrganizationTypeFromString(s string) (BusinessOrganizationType, error) {
	switch s {
	case "privateCorporation":
		return BusinessOrganizationTypePrivateCorporation, nil
	case "publicCorporation":
		return BusinessOrganizationTypePublicCorporation, nil
	case "nonProfit":
		return BusinessOrganizationTypeNonProfit, nil
	case "privateLlc":
		return BusinessOrganizationTypePrivateLlc, nil
	case "publicLlc":
		return BusinessOrganizationTypePublicLlc, nil
	case "privatePartnership":
		return BusinessOrganizationTypePrivatePartnership, nil
	case "publicPartnership":
		return BusinessOrganizationTypePublicPartnership, nil
	case "soleProprietor":
		return BusinessOrganizationTypeSoleProprietor, nil
	}
	var t BusinessOrganizationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessOrganizationType) Ptr() *BusinessOrganizationType {
	return &b
}

// Object that contains the details of the payment card.
var (
	cardFieldType                = big.NewInt(1 << 0)
	cardFieldEntryMethod         = big.NewInt(1 << 1)
	cardFieldCardholderName      = big.NewInt(1 << 2)
	cardFieldCardholderSignature = big.NewInt(1 << 3)
	cardFieldCardNumber          = big.NewInt(1 << 4)
	cardFieldExpiryDate          = big.NewInt(1 << 5)
	cardFieldSecureToken         = big.NewInt(1 << 6)
	cardFieldSecurityChecks      = big.NewInt(1 << 7)
	cardFieldEmvTags             = big.NewInt(1 << 8)
	cardFieldBalances            = big.NewInt(1 << 9)
)

type Card struct {
	// Card brand of the card, for example, Visa.
	Type string `json:"type" url:"type"`
	// Method that the device used to capture the card details.
	EntryMethod CardEntryMethod `json:"entryMethod" url:"entryMethod"`
	// Cardholder’s name.
	CardholderName *string `json:"cardholderName,omitempty" url:"cardholderName,omitempty"`
	// Cardholder’s signature.
	CardholderSignature *string `json:"cardholderSignature,omitempty" url:"cardholderSignature,omitempty"`
	// Card number. In the response, our gateway shows only the first six digits and the last four digits of the card number, for example, 500165******0000.
	CardNumber string `json:"cardNumber" url:"cardNumber"`
	// Expiry date of the customer's card. The format is in **MMYY**.
	ExpiryDate     string              `json:"expiryDate" url:"expiryDate"`
	SecureToken    *SecureTokenSummary `json:"secureToken,omitempty" url:"secureToken,omitempty"`
	SecurityChecks *SecurityCheck      `json:"securityChecks,omitempty" url:"securityChecks,omitempty"`
	// Array of emvTag objects.
	EmvTags []*EmvTag `json:"emvTags,omitempty" url:"emvTags,omitempty"`
	// Array of cardBalance objects. Our gateway returns this array only when the customer uses an Electronic Benefit Transfer (EBT) card.
	Balances []*CardBalance `json:"balances,omitempty" url:"balances,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Card) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *Card) GetEntryMethod() CardEntryMethod {
	if c == nil {
		return ""
	}
	return c.EntryMethod
}

func (c *Card) GetCardholderName() *string {
	if c == nil {
		return nil
	}
	return c.CardholderName
}

func (c *Card) GetCardholderSignature() *string {
	if c == nil {
		return nil
	}
	return c.CardholderSignature
}

func (c *Card) GetCardNumber() string {
	if c == nil {
		return ""
	}
	return c.CardNumber
}

func (c *Card) GetExpiryDate() string {
	if c == nil {
		return ""
	}
	return c.ExpiryDate
}

func (c *Card) GetSecureToken() *SecureTokenSummary {
	if c == nil {
		return nil
	}
	return c.SecureToken
}

func (c *Card) GetSecurityChecks() *SecurityCheck {
	if c == nil {
		return nil
	}
	return c.SecurityChecks
}

func (c *Card) GetEmvTags() []*EmvTag {
	if c == nil {
		return nil
	}
	return c.EmvTags
}

func (c *Card) GetBalances() []*CardBalance {
	if c == nil {
		return nil
	}
	return c.Balances
}

func (c *Card) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Card) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetType(type_ string) {
	c.Type = type_
	c.require(cardFieldType)
}

// SetEntryMethod sets the EntryMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetEntryMethod(entryMethod CardEntryMethod) {
	c.EntryMethod = entryMethod
	c.require(cardFieldEntryMethod)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetCardholderName(cardholderName *string) {
	c.CardholderName = cardholderName
	c.require(cardFieldCardholderName)
}

// SetCardholderSignature sets the CardholderSignature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetCardholderSignature(cardholderSignature *string) {
	c.CardholderSignature = cardholderSignature
	c.require(cardFieldCardholderSignature)
}

// SetCardNumber sets the CardNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetCardNumber(cardNumber string) {
	c.CardNumber = cardNumber
	c.require(cardFieldCardNumber)
}

// SetExpiryDate sets the ExpiryDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetExpiryDate(expiryDate string) {
	c.ExpiryDate = expiryDate
	c.require(cardFieldExpiryDate)
}

// SetSecureToken sets the SecureToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetSecureToken(secureToken *SecureTokenSummary) {
	c.SecureToken = secureToken
	c.require(cardFieldSecureToken)
}

// SetSecurityChecks sets the SecurityChecks field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetSecurityChecks(securityChecks *SecurityCheck) {
	c.SecurityChecks = securityChecks
	c.require(cardFieldSecurityChecks)
}

// SetEmvTags sets the EmvTags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetEmvTags(emvTags []*EmvTag) {
	c.EmvTags = emvTags
	c.require(cardFieldEmvTags)
}

// SetBalances sets the Balances field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Card) SetBalances(balances []*CardBalance) {
	c.Balances = balances
	c.require(cardFieldBalances)
}

func (c *Card) UnmarshalJSON(data []byte) error {
	type unmarshaler Card
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Card(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Card) MarshalJSON() ([]byte, error) {
	type embed Card
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *Card) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains information about the total funds available in the card.
var (
	cardBalanceFieldBenefitCategory = big.NewInt(1 << 0)
	cardBalanceFieldAmount          = big.NewInt(1 << 1)
	cardBalanceFieldCurrency        = big.NewInt(1 << 2)
)

type CardBalance struct {
	// Indicates if the balance relates to an EBT Cash account or EBT SNAP account.
	// - `cash` – EBT Cash
	// - `foodStamp` – EBT SNAP
	BenefitCategory CardBalanceBenefitCategory `json:"benefitCategory" url:"benefitCategory"`
	// Current balance of the account. This value is in the currency's lowest denomination, for example, cents.
	Amount   int64    `json:"amount" url:"amount"`
	Currency Currency `json:"currency" url:"currency"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardBalance) GetBenefitCategory() CardBalanceBenefitCategory {
	if c == nil {
		return ""
	}
	return c.BenefitCategory
}

func (c *CardBalance) GetAmount() int64 {
	if c == nil {
		return 0
	}
	return c.Amount
}

func (c *CardBalance) GetCurrency() Currency {
	if c == nil {
		return ""
	}
	return c.Currency
}

func (c *CardBalance) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardBalance) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetBenefitCategory sets the BenefitCategory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardBalance) SetBenefitCategory(benefitCategory CardBalanceBenefitCategory) {
	c.BenefitCategory = benefitCategory
	c.require(cardBalanceFieldBenefitCategory)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardBalance) SetAmount(amount int64) {
	c.Amount = amount
	c.require(cardBalanceFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardBalance) SetCurrency(currency Currency) {
	c.Currency = currency
	c.require(cardBalanceFieldCurrency)
}

func (c *CardBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler CardBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardBalance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardBalance) MarshalJSON() ([]byte, error) {
	type embed CardBalance
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CardBalance) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates if the balance relates to an EBT Cash account or EBT SNAP account.
// - `cash` – EBT Cash
// - `foodStamp` – EBT SNAP
type CardBalanceBenefitCategory string

const (
	CardBalanceBenefitCategoryCash      CardBalanceBenefitCategory = "cash"
	CardBalanceBenefitCategoryFoodStamp CardBalanceBenefitCategory = "foodStamp"
)

func NewCardBalanceBenefitCategoryFromString(s string) (CardBalanceBenefitCategory, error) {
	switch s {
	case "cash":
		return CardBalanceBenefitCategoryCash, nil
	case "foodStamp":
		return CardBalanceBenefitCategoryFoodStamp, nil
	}
	var t CardBalanceBenefitCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBalanceBenefitCategory) Ptr() *CardBalanceBenefitCategory {
	return &c
}

// Object that contains information about the card's bank identification number (BIN).
var (
	cardBinPayloadFieldBin = big.NewInt(1 << 0)
)

type CardBinPayload struct {
	Bin string `json:"bin" url:"bin"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardBinPayload) GetBin() string {
	if c == nil {
		return ""
	}
	return c.Bin
}

func (c *CardBinPayload) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardBinPayload) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetBin sets the Bin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardBinPayload) SetBin(bin string) {
	c.Bin = bin
	c.require(cardBinPayloadFieldBin)
}

func (c *CardBinPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler CardBinPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardBinPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardBinPayload) MarshalJSON() ([]byte, error) {
	type embed CardBinPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CardBinPayload) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Method that the device used to capture the card details.
type CardEntryMethod string

const (
	CardEntryMethodIcc            CardEntryMethod = "icc"
	CardEntryMethodKeyed          CardEntryMethod = "keyed"
	CardEntryMethodSwiped         CardEntryMethod = "swiped"
	CardEntryMethodSwipedFallback CardEntryMethod = "swipedFallback"
	CardEntryMethodContactlessIcc CardEntryMethod = "contactlessIcc"
	CardEntryMethodContactlessMsr CardEntryMethod = "contactlessMsr"
)

func NewCardEntryMethodFromString(s string) (CardEntryMethod, error) {
	switch s {
	case "icc":
		return CardEntryMethodIcc, nil
	case "keyed":
		return CardEntryMethodKeyed, nil
	case "swiped":
		return CardEntryMethodSwiped, nil
	case "swipedFallback":
		return CardEntryMethodSwipedFallback, nil
	case "contactlessIcc":
		return CardEntryMethodContactlessIcc, nil
	case "contactlessMsr":
		return CardEntryMethodContactlessMsr, nil
	}
	var t CardEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardEntryMethod) Ptr() *CardEntryMethod {
	return &c
}

// Object that contains information about the card.
var (
	cardInfoFieldType        = big.NewInt(1 << 0)
	cardInfoFieldCardNumber  = big.NewInt(1 << 1)
	cardInfoFieldCountry     = big.NewInt(1 << 2)
	cardInfoFieldCurrency    = big.NewInt(1 << 3)
	cardInfoFieldDebit       = big.NewInt(1 << 4)
	cardInfoFieldSurcharging = big.NewInt(1 << 5)
)

type CardInfo struct {
	// Card brand of the card, for example, Visa.
	Type string `json:"type" url:"type"`
	// Masked card number. Our gateway shows only the first six digits and the last four digits of the card number, for example, 548010******5929.
	CardNumber string `json:"cardNumber" url:"cardNumber"`
	// Country of the issuing bank. The value for the country follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
	Country  *string   `json:"country,omitempty" url:"country,omitempty"`
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	// Indicates if the card is a debit card.
	Debit       *bool        `json:"debit,omitempty" url:"debit,omitempty"`
	Surcharging *Surcharging `json:"surcharging,omitempty" url:"surcharging,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardInfo) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CardInfo) GetCardNumber() string {
	if c == nil {
		return ""
	}
	return c.CardNumber
}

func (c *CardInfo) GetCountry() *string {
	if c == nil {
		return nil
	}
	return c.Country
}

func (c *CardInfo) GetCurrency() *Currency {
	if c == nil {
		return nil
	}
	return c.Currency
}

func (c *CardInfo) GetDebit() *bool {
	if c == nil {
		return nil
	}
	return c.Debit
}

func (c *CardInfo) GetSurcharging() *Surcharging {
	if c == nil {
		return nil
	}
	return c.Surcharging
}

func (c *CardInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardInfo) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardInfo) SetType(type_ string) {
	c.Type = type_
	c.require(cardInfoFieldType)
}

// SetCardNumber sets the CardNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardInfo) SetCardNumber(cardNumber string) {
	c.CardNumber = cardNumber
	c.require(cardInfoFieldCardNumber)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardInfo) SetCountry(country *string) {
	c.Country = country
	c.require(cardInfoFieldCountry)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardInfo) SetCurrency(currency *Currency) {
	c.Currency = currency
	c.require(cardInfoFieldCurrency)
}

// SetDebit sets the Debit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardInfo) SetDebit(debit *bool) {
	c.Debit = debit
	c.require(cardInfoFieldDebit)
}

// SetSurcharging sets the Surcharging field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardInfo) SetSurcharging(surcharging *Surcharging) {
	c.Surcharging = surcharging
	c.require(cardInfoFieldSurcharging)
}

func (c *CardInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CardInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardInfo) MarshalJSON() ([]byte, error) {
	type embed CardInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CardInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains information about the customer’s payment card.
var (
	cardPayloadFieldAccountType = big.NewInt(1 << 0)
	cardPayloadFieldCardDetails = big.NewInt(1 << 1)
)

type CardPayload struct {
	// Indicates the customer’s account type.
	//
	// **Note:** Send a value for accountType only for bank account details.
	AccountType *CardPayloadAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`
	// Polymorphic object that contains payment card information.
	//
	// The value of the entryMethod parameter determines which variant you should use:
	// - `raw` - Unencrypted payment data directly from the device.
	// - `icc` - Payment data that the device captured from the chip.
	// - `keyed` - Payment data that the merchant entered manually.
	// - `swiped` - Payment data that the device captured from the magnetic strip.
	CardDetails *CardPayloadCardDetails `json:"cardDetails" url:"cardDetails"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardPayload) GetAccountType() *CardPayloadAccountType {
	if c == nil {
		return nil
	}
	return c.AccountType
}

func (c *CardPayload) GetCardDetails() *CardPayloadCardDetails {
	if c == nil {
		return nil
	}
	return c.CardDetails
}

func (c *CardPayload) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardPayload) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardPayload) SetAccountType(accountType *CardPayloadAccountType) {
	c.AccountType = accountType
	c.require(cardPayloadFieldAccountType)
}

// SetCardDetails sets the CardDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardPayload) SetCardDetails(cardDetails *CardPayloadCardDetails) {
	c.CardDetails = cardDetails
	c.require(cardPayloadFieldCardDetails)
}

func (c *CardPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler CardPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardPayload) MarshalJSON() ([]byte, error) {
	type embed CardPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CardPayload) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the customer’s account type.
//
// **Note:** Send a value for accountType only for bank account details.
type CardPayloadAccountType string

const (
	CardPayloadAccountTypeChecking CardPayloadAccountType = "checking"
	CardPayloadAccountTypeSavings  CardPayloadAccountType = "savings"
)

func NewCardPayloadAccountTypeFromString(s string) (CardPayloadAccountType, error) {
	switch s {
	case "checking":
		return CardPayloadAccountTypeChecking, nil
	case "savings":
		return CardPayloadAccountTypeSavings, nil
	}
	var t CardPayloadAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardPayloadAccountType) Ptr() *CardPayloadAccountType {
	return &c
}

// Polymorphic object that contains payment card information.
//
// The value of the entryMethod parameter determines which variant you should use:
// - `raw` - Unencrypted payment data directly from the device.
// - `icc` - Payment data that the device captured from the chip.
// - `keyed` - Payment data that the merchant entered manually.
// - `swiped` - Payment data that the device captured from the magnetic strip.
type CardPayloadCardDetails struct {
	EntryMethod string
	Raw         *RawCardDetails
	Icc         *IccCardDetails
	Keyed       *KeyedCardDetails
	Swiped      *SwipedCardDetails
}

func (c *CardPayloadCardDetails) GetEntryMethod() string {
	if c == nil {
		return ""
	}
	return c.EntryMethod
}

func (c *CardPayloadCardDetails) GetRaw() *RawCardDetails {
	if c == nil {
		return nil
	}
	return c.Raw
}

func (c *CardPayloadCardDetails) GetIcc() *IccCardDetails {
	if c == nil {
		return nil
	}
	return c.Icc
}

func (c *CardPayloadCardDetails) GetKeyed() *KeyedCardDetails {
	if c == nil {
		return nil
	}
	return c.Keyed
}

func (c *CardPayloadCardDetails) GetSwiped() *SwipedCardDetails {
	if c == nil {
		return nil
	}
	return c.Swiped
}

func (c *CardPayloadCardDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EntryMethod string `json:"entryMethod"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.EntryMethod = unmarshaler.EntryMethod
	if unmarshaler.EntryMethod == "" {
		return fmt.Errorf("%T did not include discriminant entryMethod", c)
	}
	switch unmarshaler.EntryMethod {
	case "raw":
		value := new(RawCardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Raw = value
	case "icc":
		value := new(IccCardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Icc = value
	case "keyed":
		value := new(KeyedCardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Keyed = value
	case "swiped":
		value := new(SwipedCardDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Swiped = value
	}
	return nil
}

func (c CardPayloadCardDetails) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Raw != nil {
		return internal.MarshalJSONWithExtraProperty(c.Raw, "entryMethod", "raw")
	}
	if c.Icc != nil {
		return internal.MarshalJSONWithExtraProperty(c.Icc, "entryMethod", "icc")
	}
	if c.Keyed != nil {
		return internal.MarshalJSONWithExtraProperty(c.Keyed, "entryMethod", "keyed")
	}
	if c.Swiped != nil {
		return internal.MarshalJSONWithExtraProperty(c.Swiped, "entryMethod", "swiped")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CardPayloadCardDetailsVisitor interface {
	VisitRaw(*RawCardDetails) error
	VisitIcc(*IccCardDetails) error
	VisitKeyed(*KeyedCardDetails) error
	VisitSwiped(*SwipedCardDetails) error
}

func (c *CardPayloadCardDetails) Accept(visitor CardPayloadCardDetailsVisitor) error {
	if c.Raw != nil {
		return visitor.VisitRaw(c.Raw)
	}
	if c.Icc != nil {
		return visitor.VisitIcc(c.Icc)
	}
	if c.Keyed != nil {
		return visitor.VisitKeyed(c.Keyed)
	}
	if c.Swiped != nil {
		return visitor.VisitSwiped(c.Swiped)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *CardPayloadCardDetails) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Raw != nil {
		fields = append(fields, "raw")
	}
	if c.Icc != nil {
		fields = append(fields, "icc")
	}
	if c.Keyed != nil {
		fields = append(fields, "keyed")
	}
	if c.Swiped != nil {
		fields = append(fields, "swiped")
	}
	if len(fields) == 0 {
		if c.EntryMethod != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.EntryMethod)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.EntryMethod != "" {
		field := fields[0]
		if c.EntryMethod != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.EntryMethod,
				c,
			)
		}
	}
	return nil
}

// Object that contains the customer's card details.
var (
	cardSourceFieldCardholderName = big.NewInt(1 << 0)
	cardSourceFieldCardNumber     = big.NewInt(1 << 1)
	cardSourceFieldExpiryDate     = big.NewInt(1 << 2)
	cardSourceFieldCardType       = big.NewInt(1 << 3)
	cardSourceFieldCurrency       = big.NewInt(1 << 4)
	cardSourceFieldDebit          = big.NewInt(1 << 5)
	cardSourceFieldSurcharging    = big.NewInt(1 << 6)
)

type CardSource struct {
	// Cardholder's name.
	CardholderName string `json:"cardholderName" url:"cardholderName"`
	// Primary account number of the customer's card.
	CardNumber string `json:"cardNumber" url:"cardNumber"`
	// Expiry date of the customer's card.
	ExpiryDate *string `json:"expiryDate,omitempty" url:"expiryDate,omitempty"`
	// Card brand of the card, for example, Visa.
	CardType *string   `json:"cardType,omitempty" url:"cardType,omitempty"`
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	// Indicates if the card is a debit card.
	Debit       *bool        `json:"debit,omitempty" url:"debit,omitempty"`
	Surcharging *Surcharging `json:"surcharging,omitempty" url:"surcharging,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardSource) GetCardholderName() string {
	if c == nil {
		return ""
	}
	return c.CardholderName
}

func (c *CardSource) GetCardNumber() string {
	if c == nil {
		return ""
	}
	return c.CardNumber
}

func (c *CardSource) GetExpiryDate() *string {
	if c == nil {
		return nil
	}
	return c.ExpiryDate
}

func (c *CardSource) GetCardType() *string {
	if c == nil {
		return nil
	}
	return c.CardType
}

func (c *CardSource) GetCurrency() *Currency {
	if c == nil {
		return nil
	}
	return c.Currency
}

func (c *CardSource) GetDebit() *bool {
	if c == nil {
		return nil
	}
	return c.Debit
}

func (c *CardSource) GetSurcharging() *Surcharging {
	if c == nil {
		return nil
	}
	return c.Surcharging
}

func (c *CardSource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardSource) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSource) SetCardholderName(cardholderName string) {
	c.CardholderName = cardholderName
	c.require(cardSourceFieldCardholderName)
}

// SetCardNumber sets the CardNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSource) SetCardNumber(cardNumber string) {
	c.CardNumber = cardNumber
	c.require(cardSourceFieldCardNumber)
}

// SetExpiryDate sets the ExpiryDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSource) SetExpiryDate(expiryDate *string) {
	c.ExpiryDate = expiryDate
	c.require(cardSourceFieldExpiryDate)
}

// SetCardType sets the CardType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSource) SetCardType(cardType *string) {
	c.CardType = cardType
	c.require(cardSourceFieldCardType)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSource) SetCurrency(currency *Currency) {
	c.Currency = currency
	c.require(cardSourceFieldCurrency)
}

// SetDebit sets the Debit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSource) SetDebit(debit *bool) {
	c.Debit = debit
	c.require(cardSourceFieldDebit)
}

// SetSurcharging sets the Surcharging field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSource) SetSurcharging(surcharging *Surcharging) {
	c.Surcharging = surcharging
	c.require(cardSourceFieldSurcharging)
}

func (c *CardSource) UnmarshalJSON(data []byte) error {
	type unmarshaler CardSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardSource) MarshalJSON() ([]byte, error) {
	type embed CardSource
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CardSource) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains information about the card.
var (
	cardSummaryFieldCardNumber           = big.NewInt(1 << 0)
	cardSummaryFieldType                 = big.NewInt(1 << 1)
	cardSummaryFieldCvvPresenceIndicator = big.NewInt(1 << 2)
	cardSummaryFieldAvsRequest           = big.NewInt(1 << 3)
	cardSummaryFieldAvsResponse          = big.NewInt(1 << 4)
)

type CardSummary struct {
	// Masked card number. Our gateway shows only the first six digits and the last four digits of the card number, for example, `500165******0000`.
	CardNumber *string `json:"cardNumber,omitempty" url:"cardNumber,omitempty"`
	// Card type, for example, Visa.
	//
	// **Note:** If we can’t match a dispute to a transaction, we don’t return a type object.
	Type *CardSummaryType `json:"type,omitempty" url:"type,omitempty"`
	// Indicates whether the cardholder provided the Card Verification Value (CVV).
	CvvPresenceIndicator *bool `json:"cvvPresenceIndicator,omitempty" url:"cvvPresenceIndicator,omitempty"`
	// Indicates whether the merchant used the Address Verification Service (AVS) to verify the cardholder's address.
	AvsRequest *bool `json:"avsRequest,omitempty" url:"avsRequest,omitempty"`
	// Response from the Address Verification Service (AVS).
	AvsResponse *string `json:"avsResponse,omitempty" url:"avsResponse,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardSummary) GetCardNumber() *string {
	if c == nil {
		return nil
	}
	return c.CardNumber
}

func (c *CardSummary) GetType() *CardSummaryType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardSummary) GetCvvPresenceIndicator() *bool {
	if c == nil {
		return nil
	}
	return c.CvvPresenceIndicator
}

func (c *CardSummary) GetAvsRequest() *bool {
	if c == nil {
		return nil
	}
	return c.AvsRequest
}

func (c *CardSummary) GetAvsResponse() *string {
	if c == nil {
		return nil
	}
	return c.AvsResponse
}

func (c *CardSummary) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardSummary) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetCardNumber sets the CardNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSummary) SetCardNumber(cardNumber *string) {
	c.CardNumber = cardNumber
	c.require(cardSummaryFieldCardNumber)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSummary) SetType(type_ *CardSummaryType) {
	c.Type = type_
	c.require(cardSummaryFieldType)
}

// SetCvvPresenceIndicator sets the CvvPresenceIndicator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSummary) SetCvvPresenceIndicator(cvvPresenceIndicator *bool) {
	c.CvvPresenceIndicator = cvvPresenceIndicator
	c.require(cardSummaryFieldCvvPresenceIndicator)
}

// SetAvsRequest sets the AvsRequest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSummary) SetAvsRequest(avsRequest *bool) {
	c.AvsRequest = avsRequest
	c.require(cardSummaryFieldAvsRequest)
}

// SetAvsResponse sets the AvsResponse field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardSummary) SetAvsResponse(avsResponse *string) {
	c.AvsResponse = avsResponse
	c.require(cardSummaryFieldAvsResponse)
}

func (c *CardSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler CardSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardSummary) MarshalJSON() ([]byte, error) {
	type embed CardSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CardSummary) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Card type, for example, Visa.
//
// **Note:** If we can’t match a dispute to a transaction, we don’t return a type object.
type CardSummaryType string

const (
	CardSummaryTypeVisa             CardSummaryType = "visa"
	CardSummaryTypeMasterCard       CardSummaryType = "masterCard"
	CardSummaryTypeDiscover         CardSummaryType = "discover"
	CardSummaryTypeDebit            CardSummaryType = "debit"
	CardSummaryTypeEbt              CardSummaryType = "ebt"
	CardSummaryTypeWrightExpress    CardSummaryType = "wrightExpress"
	CardSummaryTypeVoyager          CardSummaryType = "voyager"
	CardSummaryTypeAmex             CardSummaryType = "amex"
	CardSummaryTypePrivateLabel     CardSummaryType = "privateLabel"
	CardSummaryTypeStoredValue      CardSummaryType = "storedValue"
	CardSummaryTypeDiscoverRetained CardSummaryType = "discoverRetained"
	CardSummaryTypeJcbNonSettled    CardSummaryType = "jcbNonSettled"
	CardSummaryTypeDinersClub       CardSummaryType = "dinersClub"
	CardSummaryTypeAmexOptBlue      CardSummaryType = "amexOptBlue"
	CardSummaryTypeFuelman          CardSummaryType = "fuelman"
	CardSummaryTypeUnknown          CardSummaryType = "unknown"
)

func NewCardSummaryTypeFromString(s string) (CardSummaryType, error) {
	switch s {
	case "visa":
		return CardSummaryTypeVisa, nil
	case "masterCard":
		return CardSummaryTypeMasterCard, nil
	case "discover":
		return CardSummaryTypeDiscover, nil
	case "debit":
		return CardSummaryTypeDebit, nil
	case "ebt":
		return CardSummaryTypeEbt, nil
	case "wrightExpress":
		return CardSummaryTypeWrightExpress, nil
	case "voyager":
		return CardSummaryTypeVoyager, nil
	case "amex":
		return CardSummaryTypeAmex, nil
	case "privateLabel":
		return CardSummaryTypePrivateLabel, nil
	case "storedValue":
		return CardSummaryTypeStoredValue, nil
	case "discoverRetained":
		return CardSummaryTypeDiscoverRetained, nil
	case "jcbNonSettled":
		return CardSummaryTypeJcbNonSettled, nil
	case "dinersClub":
		return CardSummaryTypeDinersClub, nil
	case "amexOptBlue":
		return CardSummaryTypeAmexOptBlue, nil
	case "fuelman":
		return CardSummaryTypeFuelman, nil
	case "unknown":
		return CardSummaryTypeUnknown, nil
	}
	var t CardSummaryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardSummaryType) Ptr() *CardSummaryType {
	return &c
}

var (
	cardVerificationResultFieldOperator             = big.NewInt(1 << 0)
	cardVerificationResultFieldProcessingTerminalId = big.NewInt(1 << 1)
	cardVerificationResultFieldCard                 = big.NewInt(1 << 2)
	cardVerificationResultFieldVerified             = big.NewInt(1 << 3)
	cardVerificationResultFieldTransactionResult    = big.NewInt(1 << 4)
)

type CardVerificationResult struct {
	// Operator who requested to verify the card.
	Operator *string `json:"operator,omitempty" url:"operator,omitempty"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	Card                 *Card  `json:"card,omitempty" url:"card,omitempty"`
	// Indicates if the card details are valid:
	//
	// - `true` - Card details are valid.
	// - `false` - Card details are not valid.
	Verified          bool               `json:"verified" url:"verified"`
	TransactionResult *TransactionResult `json:"transactionResult,omitempty" url:"transactionResult,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardVerificationResult) GetOperator() *string {
	if c == nil {
		return nil
	}
	return c.Operator
}

func (c *CardVerificationResult) GetProcessingTerminalId() string {
	if c == nil {
		return ""
	}
	return c.ProcessingTerminalId
}

func (c *CardVerificationResult) GetCard() *Card {
	if c == nil {
		return nil
	}
	return c.Card
}

func (c *CardVerificationResult) GetVerified() bool {
	if c == nil {
		return false
	}
	return c.Verified
}

func (c *CardVerificationResult) GetTransactionResult() *TransactionResult {
	if c == nil {
		return nil
	}
	return c.TransactionResult
}

func (c *CardVerificationResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardVerificationResult) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardVerificationResult) SetOperator(operator *string) {
	c.Operator = operator
	c.require(cardVerificationResultFieldOperator)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardVerificationResult) SetProcessingTerminalId(processingTerminalId string) {
	c.ProcessingTerminalId = processingTerminalId
	c.require(cardVerificationResultFieldProcessingTerminalId)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardVerificationResult) SetCard(card *Card) {
	c.Card = card
	c.require(cardVerificationResultFieldCard)
}

// SetVerified sets the Verified field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardVerificationResult) SetVerified(verified bool) {
	c.Verified = verified
	c.require(cardVerificationResultFieldVerified)
}

// SetTransactionResult sets the TransactionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CardVerificationResult) SetTransactionResult(transactionResult *TransactionResult) {
	c.TransactionResult = transactionResult
	c.require(cardVerificationResultFieldTransactionResult)
}

func (c *CardVerificationResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CardVerificationResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardVerificationResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardVerificationResult) MarshalJSON() ([]byte, error) {
	type embed CardVerificationResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CardVerificationResult) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains information about the choice rate. We return this only if the value for offered was `true`.
var (
	choiceRateFieldApplied = big.NewInt(1 << 0)
	choiceRateFieldRate    = big.NewInt(1 << 1)
	choiceRateFieldAmount  = big.NewInt(1 << 2)
)

type ChoiceRate struct {
	// Indicates if the merchant applies a choice rate to the transaction amount.
	//
	// Our gateway adds a choice rate to the transaction when the merchant offers an alternative payment type, but the customer chooses to pay by card.
	Applied bool `json:"applied" url:"applied"`
	// If the customer used a card to pay for the transaction, this value indicates the percentage that our gateway added to the transaction amount.
	// **Note:** Our gateway returns a value for **rate** only if the value for **applied** in the request is `true`.
	Rate float64 `json:"rate" url:"rate"`
	// If the customer used a card to pay for the transaction, this value indicates the amount that our gateway added to the transaction amount. This value is in the currency’s lowest denomination, for example, cents.
	// **Note:** Our gateway returns a value for **amount** only if the value for **applied** in the request is `true`.
	Amount int64 `json:"amount" url:"amount"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChoiceRate) GetApplied() bool {
	if c == nil {
		return false
	}
	return c.Applied
}

func (c *ChoiceRate) GetRate() float64 {
	if c == nil {
		return 0
	}
	return c.Rate
}

func (c *ChoiceRate) GetAmount() int64 {
	if c == nil {
		return 0
	}
	return c.Amount
}

func (c *ChoiceRate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChoiceRate) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetApplied sets the Applied field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChoiceRate) SetApplied(applied bool) {
	c.Applied = applied
	c.require(choiceRateFieldApplied)
}

// SetRate sets the Rate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChoiceRate) SetRate(rate float64) {
	c.Rate = rate
	c.require(choiceRateFieldRate)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChoiceRate) SetAmount(amount int64) {
	c.Amount = amount
	c.require(choiceRateFieldAmount)
}

func (c *ChoiceRate) UnmarshalJSON(data []byte) error {
	type unmarshaler ChoiceRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChoiceRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChoiceRate) MarshalJSON() ([]byte, error) {
	type embed ChoiceRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChoiceRate) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	commonFundingFieldStatus                = big.NewInt(1 << 0)
	commonFundingFieldFundingSchedule       = big.NewInt(1 << 1)
	commonFundingFieldAcceleratedFundingFee = big.NewInt(1 << 2)
	commonFundingFieldDailyDiscount         = big.NewInt(1 << 3)
)

type CommonFunding struct {
	// Indicates if the processing account can receive funds.
	Status *CommonFundingStatus `json:"status,omitempty" url:"status,omitempty"`
	// Indicates when funds are sent to the funding account.
	//
	// If you send a value of `sameDay` or `nextDay`, provide a value for acceleratedFundingFee.
	//
	// **Note:** If you send a value of `sameday`, funding includes all transactions the merchant ran before the ACH cut-off time.
	FundingSchedule *CommonFundingFundingSchedule `json:"fundingSchedule,omitempty" url:"fundingSchedule,omitempty"`
	// Monthly fee in cents for accelerated funding. The value is in the currency's lowest denomination, for example, cents.
	//
	// We apply this fee if the value for fundingSchedule is `sameday` or `nextday`.
	AcceleratedFundingFee *int `json:"acceleratedFundingFee,omitempty" url:"acceleratedFundingFee,omitempty"`
	// Indicates if we collect fees from the merchant's account each day.
	DailyDiscount *bool `json:"dailyDiscount,omitempty" url:"dailyDiscount,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CommonFunding) GetStatus() *CommonFundingStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CommonFunding) GetFundingSchedule() *CommonFundingFundingSchedule {
	if c == nil {
		return nil
	}
	return c.FundingSchedule
}

func (c *CommonFunding) GetAcceleratedFundingFee() *int {
	if c == nil {
		return nil
	}
	return c.AcceleratedFundingFee
}

func (c *CommonFunding) GetDailyDiscount() *bool {
	if c == nil {
		return nil
	}
	return c.DailyDiscount
}

func (c *CommonFunding) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CommonFunding) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CommonFunding) SetStatus(status *CommonFundingStatus) {
	c.Status = status
	c.require(commonFundingFieldStatus)
}

// SetFundingSchedule sets the FundingSchedule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CommonFunding) SetFundingSchedule(fundingSchedule *CommonFundingFundingSchedule) {
	c.FundingSchedule = fundingSchedule
	c.require(commonFundingFieldFundingSchedule)
}

// SetAcceleratedFundingFee sets the AcceleratedFundingFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CommonFunding) SetAcceleratedFundingFee(acceleratedFundingFee *int) {
	c.AcceleratedFundingFee = acceleratedFundingFee
	c.require(commonFundingFieldAcceleratedFundingFee)
}

// SetDailyDiscount sets the DailyDiscount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CommonFunding) SetDailyDiscount(dailyDiscount *bool) {
	c.DailyDiscount = dailyDiscount
	c.require(commonFundingFieldDailyDiscount)
}

func (c *CommonFunding) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonFunding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonFunding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonFunding) MarshalJSON() ([]byte, error) {
	type embed CommonFunding
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CommonFunding) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates when funds are sent to the funding account.
//
// If you send a value of `sameDay` or `nextDay`, provide a value for acceleratedFundingFee.
//
// **Note:** If you send a value of `sameday`, funding includes all transactions the merchant ran before the ACH cut-off time.
type CommonFundingFundingSchedule string

const (
	CommonFundingFundingScheduleStandard CommonFundingFundingSchedule = "standard"
	CommonFundingFundingScheduleNextday  CommonFundingFundingSchedule = "nextday"
	CommonFundingFundingScheduleSameday  CommonFundingFundingSchedule = "sameday"
)

func NewCommonFundingFundingScheduleFromString(s string) (CommonFundingFundingSchedule, error) {
	switch s {
	case "standard":
		return CommonFundingFundingScheduleStandard, nil
	case "nextday":
		return CommonFundingFundingScheduleNextday, nil
	case "sameday":
		return CommonFundingFundingScheduleSameday, nil
	}
	var t CommonFundingFundingSchedule
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CommonFundingFundingSchedule) Ptr() *CommonFundingFundingSchedule {
	return &c
}

// Indicates if the processing account can receive funds.
type CommonFundingStatus string

const (
	CommonFundingStatusEnabled  CommonFundingStatus = "enabled"
	CommonFundingStatusDisabled CommonFundingStatus = "disabled"
)

func NewCommonFundingStatusFromString(s string) (CommonFundingStatus, error) {
	switch s {
	case "enabled":
		return CommonFundingStatusEnabled, nil
	case "disabled":
		return CommonFundingStatusDisabled, nil
	}
	var t CommonFundingStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CommonFundingStatus) Ptr() *CommonFundingStatus {
	return &c
}

// Indicates how the device communicates with its host.
type CommunicationType string

const (
	CommunicationTypeBluetooth CommunicationType = "bluetooth"
	CommunicationTypeCellular  CommunicationType = "cellular"
	CommunicationTypeEthernet  CommunicationType = "ethernet"
	CommunicationTypeWifi      CommunicationType = "wifi"
)

func NewCommunicationTypeFromString(s string) (CommunicationType, error) {
	switch s {
	case "bluetooth":
		return CommunicationTypeBluetooth, nil
	case "cellular":
		return CommunicationTypeCellular, nil
	case "ethernet":
		return CommunicationTypeEthernet, nil
	case "wifi":
		return CommunicationTypeWifi, nil
	}
	var t CommunicationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CommunicationType) Ptr() *CommunicationType {
	return &c
}

// Object that contains information about ConsumerChoice.
var (
	consumerChoiceFieldFees = big.NewInt(1 << 0)
)

type ConsumerChoice struct {
	// Object that contains information about the fees.
	Fees *ConsumerChoiceFees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConsumerChoice) GetFees() *ConsumerChoiceFees {
	if c == nil {
		return nil
	}
	return c.Fees
}

func (c *ConsumerChoice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConsumerChoice) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConsumerChoice) SetFees(fees *ConsumerChoiceFees) {
	c.Fees = fees
	c.require(consumerChoiceFieldFees)
}

func (c *ConsumerChoice) UnmarshalJSON(data []byte) error {
	type unmarshaler ConsumerChoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConsumerChoice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConsumerChoice) MarshalJSON() ([]byte, error) {
	type embed ConsumerChoice
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConsumerChoice) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains information about the fees.
var (
	consumerChoiceFeesFieldMonthlySubscription        = big.NewInt(1 << 0)
	consumerChoiceFeesFieldVolume                     = big.NewInt(1 << 1)
	consumerChoiceFeesFieldPinDebit                   = big.NewInt(1 << 2)
	consumerChoiceFeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	consumerChoiceFeesFieldSpecialityCards            = big.NewInt(1 << 4)
)

type ConsumerChoiceFees struct {
	// Fee for the monthly subscription for the processing plan. The value is in the currency's lowest denomination, for example, cents.
	MonthlySubscription Amount `json:"monthlySubscription" url:"monthlySubscription"`
	// Merchant-authorized percentage on non-cash transactions.
	Volume                     Percentage                  `json:"volume" url:"volume"`
	PinDebit                   *PinDebit                   `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	SpecialityCards            *SpecialityCards            `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConsumerChoiceFees) GetMonthlySubscription() Amount {
	if c == nil {
		return 0
	}
	return c.MonthlySubscription
}

func (c *ConsumerChoiceFees) GetVolume() Percentage {
	if c == nil {
		return 0
	}
	return c.Volume
}

func (c *ConsumerChoiceFees) GetPinDebit() *PinDebit {
	if c == nil {
		return nil
	}
	return c.PinDebit
}

func (c *ConsumerChoiceFees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if c == nil {
		return nil
	}
	return c.ElectronicBenefitsTransfer
}

func (c *ConsumerChoiceFees) GetSpecialityCards() *SpecialityCards {
	if c == nil {
		return nil
	}
	return c.SpecialityCards
}

func (c *ConsumerChoiceFees) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConsumerChoiceFees) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetMonthlySubscription sets the MonthlySubscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConsumerChoiceFees) SetMonthlySubscription(monthlySubscription Amount) {
	c.MonthlySubscription = monthlySubscription
	c.require(consumerChoiceFeesFieldMonthlySubscription)
}

// SetVolume sets the Volume field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConsumerChoiceFees) SetVolume(volume Percentage) {
	c.Volume = volume
	c.require(consumerChoiceFeesFieldVolume)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConsumerChoiceFees) SetPinDebit(pinDebit *PinDebit) {
	c.PinDebit = pinDebit
	c.require(consumerChoiceFeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConsumerChoiceFees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	c.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	c.require(consumerChoiceFeesFieldElectronicBenefitsTransfer)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConsumerChoiceFees) SetSpecialityCards(specialityCards *SpecialityCards) {
	c.SpecialityCards = specialityCards
	c.require(consumerChoiceFeesFieldSpecialityCards)
}

func (c *ConsumerChoiceFees) UnmarshalJSON(data []byte) error {
	type unmarshaler ConsumerChoiceFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConsumerChoiceFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConsumerChoiceFees) MarshalJSON() ([]byte, error) {
	type embed ConsumerChoiceFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConsumerChoiceFees) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contactFieldContactId      = big.NewInt(1 << 0)
	contactFieldType           = big.NewInt(1 << 1)
	contactFieldFirstName      = big.NewInt(1 << 2)
	contactFieldMiddleName     = big.NewInt(1 << 3)
	contactFieldLastName       = big.NewInt(1 << 4)
	contactFieldIdentifiers    = big.NewInt(1 << 5)
	contactFieldContactMethods = big.NewInt(1 << 6)
)

type Contact struct {
	// Unique identifier of the contact.
	ContactId *int `json:"contactId,omitempty" url:"contactId,omitempty"`
	// Type of contact.
	Type ContactType `json:"type" url:"type"`
	// Contact's first name.
	FirstName string `json:"firstName" url:"firstName"`
	// Contact's middle name.
	MiddleName *string `json:"middleName,omitempty" url:"middleName,omitempty"`
	// Contact's last name.
	LastName string `json:"lastName" url:"lastName"`
	// Array of identifier objects.
	Identifiers []*Identifier `json:"identifiers" url:"identifiers"`
	// Array of polymorphic objects, which contain contact information.
	//
	// **Note:** If you are adding information about an owner, you must provide at least an email address. If you are adding information about a contact, you must provide at least a contact number.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods" url:"contactMethods"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Contact) GetContactId() *int {
	if c == nil {
		return nil
	}
	return c.ContactId
}

func (c *Contact) GetType() ContactType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *Contact) GetFirstName() string {
	if c == nil {
		return ""
	}
	return c.FirstName
}

func (c *Contact) GetMiddleName() *string {
	if c == nil {
		return nil
	}
	return c.MiddleName
}

func (c *Contact) GetLastName() string {
	if c == nil {
		return ""
	}
	return c.LastName
}

func (c *Contact) GetIdentifiers() []*Identifier {
	if c == nil {
		return nil
	}
	return c.Identifiers
}

func (c *Contact) GetContactMethods() []*ContactMethod {
	if c == nil {
		return nil
	}
	return c.ContactMethods
}

func (c *Contact) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Contact) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContactId sets the ContactId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Contact) SetContactId(contactId *int) {
	c.ContactId = contactId
	c.require(contactFieldContactId)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Contact) SetType(type_ ContactType) {
	c.Type = type_
	c.require(contactFieldType)
}

// SetFirstName sets the FirstName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Contact) SetFirstName(firstName string) {
	c.FirstName = firstName
	c.require(contactFieldFirstName)
}

// SetMiddleName sets the MiddleName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Contact) SetMiddleName(middleName *string) {
	c.MiddleName = middleName
	c.require(contactFieldMiddleName)
}

// SetLastName sets the LastName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Contact) SetLastName(lastName string) {
	c.LastName = lastName
	c.require(contactFieldLastName)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Contact) SetIdentifiers(identifiers []*Identifier) {
	c.Identifiers = identifiers
	c.require(contactFieldIdentifiers)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Contact) SetContactMethods(contactMethods []*ContactMethod) {
	c.ContactMethods = contactMethods
	c.require(contactFieldContactMethods)
}

func (c *Contact) UnmarshalJSON(data []byte) error {
	type unmarshaler Contact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Contact(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Contact) MarshalJSON() ([]byte, error) {
	type embed Contact
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *Contact) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContactMethod struct {
	Type   string
	Email  *ContactMethodEmail
	Phone  *ContactMethodPhone
	Mobile *ContactMethodMobile
	Fax    *ContactMethodFax
}

func (c *ContactMethod) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ContactMethod) GetEmail() *ContactMethodEmail {
	if c == nil {
		return nil
	}
	return c.Email
}

func (c *ContactMethod) GetPhone() *ContactMethodPhone {
	if c == nil {
		return nil
	}
	return c.Phone
}

func (c *ContactMethod) GetMobile() *ContactMethodMobile {
	if c == nil {
		return nil
	}
	return c.Mobile
}

func (c *ContactMethod) GetFax() *ContactMethodFax {
	if c == nil {
		return nil
	}
	return c.Fax
}

func (c *ContactMethod) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "email":
		value := new(ContactMethodEmail)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Email = value
	case "phone":
		value := new(ContactMethodPhone)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Phone = value
	case "mobile":
		value := new(ContactMethodMobile)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Mobile = value
	case "fax":
		value := new(ContactMethodFax)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Fax = value
	}
	return nil
}

func (c ContactMethod) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Email != nil {
		return internal.MarshalJSONWithExtraProperty(c.Email, "type", "email")
	}
	if c.Phone != nil {
		return internal.MarshalJSONWithExtraProperty(c.Phone, "type", "phone")
	}
	if c.Mobile != nil {
		return internal.MarshalJSONWithExtraProperty(c.Mobile, "type", "mobile")
	}
	if c.Fax != nil {
		return internal.MarshalJSONWithExtraProperty(c.Fax, "type", "fax")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ContactMethodVisitor interface {
	VisitEmail(*ContactMethodEmail) error
	VisitPhone(*ContactMethodPhone) error
	VisitMobile(*ContactMethodMobile) error
	VisitFax(*ContactMethodFax) error
}

func (c *ContactMethod) Accept(visitor ContactMethodVisitor) error {
	if c.Email != nil {
		return visitor.VisitEmail(c.Email)
	}
	if c.Phone != nil {
		return visitor.VisitPhone(c.Phone)
	}
	if c.Mobile != nil {
		return visitor.VisitMobile(c.Mobile)
	}
	if c.Fax != nil {
		return visitor.VisitFax(c.Fax)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ContactMethod) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Email != nil {
		fields = append(fields, "email")
	}
	if c.Phone != nil {
		fields = append(fields, "phone")
	}
	if c.Mobile != nil {
		fields = append(fields, "mobile")
	}
	if c.Fax != nil {
		fields = append(fields, "fax")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

var (
	contactMethodEmailFieldValue = big.NewInt(1 << 0)
)

type ContactMethodEmail struct {
	// Email address.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContactMethodEmail) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *ContactMethodEmail) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContactMethodEmail) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContactMethodEmail) SetValue(value string) {
	c.Value = value
	c.require(contactMethodEmailFieldValue)
}

func (c *ContactMethodEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactMethodEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactMethodEmail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactMethodEmail) MarshalJSON() ([]byte, error) {
	type embed ContactMethodEmail
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContactMethodEmail) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contactMethodFaxFieldValue = big.NewInt(1 << 0)
)

type ContactMethodFax struct {
	// Fax number.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContactMethodFax) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *ContactMethodFax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContactMethodFax) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContactMethodFax) SetValue(value string) {
	c.Value = value
	c.require(contactMethodFaxFieldValue)
}

func (c *ContactMethodFax) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactMethodFax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactMethodFax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactMethodFax) MarshalJSON() ([]byte, error) {
	type embed ContactMethodFax
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContactMethodFax) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contactMethodMobileFieldValue = big.NewInt(1 << 0)
)

type ContactMethodMobile struct {
	// Mobile number.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContactMethodMobile) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *ContactMethodMobile) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContactMethodMobile) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContactMethodMobile) SetValue(value string) {
	c.Value = value
	c.require(contactMethodMobileFieldValue)
}

func (c *ContactMethodMobile) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactMethodMobile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactMethodMobile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactMethodMobile) MarshalJSON() ([]byte, error) {
	type embed ContactMethodMobile
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContactMethodMobile) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contactMethodPhoneFieldValue = big.NewInt(1 << 0)
)

type ContactMethodPhone struct {
	// Phone number.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContactMethodPhone) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *ContactMethodPhone) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContactMethodPhone) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContactMethodPhone) SetValue(value string) {
	c.Value = value
	c.require(contactMethodPhoneFieldValue)
}

func (c *ContactMethodPhone) UnmarshalJSON(data []byte) error {
	type unmarshaler ContactMethodPhone
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContactMethodPhone(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContactMethodPhone) MarshalJSON() ([]byte, error) {
	type embed ContactMethodPhone
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContactMethodPhone) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Type of contact.
type ContactType string

const (
	ContactTypeManager        ContactType = "manager"
	ContactTypeRepresentative ContactType = "representative"
	ContactTypeOthers         ContactType = "others"
)

func NewContactTypeFromString(s string) (ContactType, error) {
	switch s {
	case "manager":
		return ContactTypeManager, nil
	case "representative":
		return ContactTypeRepresentative, nil
	case "others":
		return ContactTypeOthers, nil
	}
	var t ContactType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContactType) Ptr() *ContactType {
	return &c
}

// Object that contains information about the convenience fee for the transaction.
var (
	convenienceFeeFieldAmount = big.NewInt(1 << 0)
)

type ConvenienceFee struct {
	// If the merchant added a convenience fee, this value indicates the amount of the convenience fee
	// in the currency’s lowest denomination, for example, cents.
	Amount int64 `json:"amount" url:"amount"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConvenienceFee) GetAmount() int64 {
	if c == nil {
		return 0
	}
	return c.Amount
}

func (c *ConvenienceFee) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConvenienceFee) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConvenienceFee) SetAmount(amount int64) {
	c.Amount = amount
	c.require(convenienceFeeFieldAmount)
}

func (c *ConvenienceFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ConvenienceFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConvenienceFee(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConvenienceFee) MarshalJSON() ([]byte, error) {
	type embed ConvenienceFee
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConvenienceFee) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains information about the funding schedule of the processing account.
var (
	createFundingFieldStatus                = big.NewInt(1 << 0)
	createFundingFieldFundingSchedule       = big.NewInt(1 << 1)
	createFundingFieldAcceleratedFundingFee = big.NewInt(1 << 2)
	createFundingFieldDailyDiscount         = big.NewInt(1 << 3)
	createFundingFieldFundingAccounts       = big.NewInt(1 << 4)
)

type CreateFunding struct {
	// Indicates if the processing account can receive funds.
	Status *CommonFundingStatus `json:"status,omitempty" url:"status,omitempty"`
	// Indicates when funds are sent to the funding account.
	//
	// If you send a value of `sameDay` or `nextDay`, provide a value for acceleratedFundingFee.
	//
	// **Note:** If you send a value of `sameday`, funding includes all transactions the merchant ran before the ACH cut-off time.
	FundingSchedule *CommonFundingFundingSchedule `json:"fundingSchedule,omitempty" url:"fundingSchedule,omitempty"`
	// Monthly fee in cents for accelerated funding. The value is in the currency's lowest denomination, for example, cents.
	//
	// We apply this fee if the value for fundingSchedule is `sameday` or `nextday`.
	AcceleratedFundingFee *int `json:"acceleratedFundingFee,omitempty" url:"acceleratedFundingFee,omitempty"`
	// Indicates if we collect fees from the merchant's account each day.
	DailyDiscount *bool `json:"dailyDiscount,omitempty" url:"dailyDiscount,omitempty"`
	// Array of fundingAccounts objects.
	FundingAccounts []*FundingAccount `json:"fundingAccounts,omitempty" url:"fundingAccounts,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateFunding) GetStatus() *CommonFundingStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CreateFunding) GetFundingSchedule() *CommonFundingFundingSchedule {
	if c == nil {
		return nil
	}
	return c.FundingSchedule
}

func (c *CreateFunding) GetAcceleratedFundingFee() *int {
	if c == nil {
		return nil
	}
	return c.AcceleratedFundingFee
}

func (c *CreateFunding) GetDailyDiscount() *bool {
	if c == nil {
		return nil
	}
	return c.DailyDiscount
}

func (c *CreateFunding) GetFundingAccounts() []*FundingAccount {
	if c == nil {
		return nil
	}
	return c.FundingAccounts
}

func (c *CreateFunding) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFunding) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateFunding) SetStatus(status *CommonFundingStatus) {
	c.Status = status
	c.require(createFundingFieldStatus)
}

// SetFundingSchedule sets the FundingSchedule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateFunding) SetFundingSchedule(fundingSchedule *CommonFundingFundingSchedule) {
	c.FundingSchedule = fundingSchedule
	c.require(createFundingFieldFundingSchedule)
}

// SetAcceleratedFundingFee sets the AcceleratedFundingFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateFunding) SetAcceleratedFundingFee(acceleratedFundingFee *int) {
	c.AcceleratedFundingFee = acceleratedFundingFee
	c.require(createFundingFieldAcceleratedFundingFee)
}

// SetDailyDiscount sets the DailyDiscount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateFunding) SetDailyDiscount(dailyDiscount *bool) {
	c.DailyDiscount = dailyDiscount
	c.require(createFundingFieldDailyDiscount)
}

// SetFundingAccounts sets the FundingAccounts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateFunding) SetFundingAccounts(fundingAccounts []*FundingAccount) {
	c.FundingAccounts = fundingAccounts
	c.require(createFundingFieldFundingAccounts)
}

func (c *CreateFunding) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFunding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFunding(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateFunding) MarshalJSON() ([]byte, error) {
	type embed CreateFunding
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateFunding) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	createProcessingAccountFieldProcessingAccountId      = big.NewInt(1 << 0)
	createProcessingAccountFieldDoingBusinessAs          = big.NewInt(1 << 1)
	createProcessingAccountFieldOwners                   = big.NewInt(1 << 2)
	createProcessingAccountFieldWebsite                  = big.NewInt(1 << 3)
	createProcessingAccountFieldBusinessType             = big.NewInt(1 << 4)
	createProcessingAccountFieldCategoryCode             = big.NewInt(1 << 5)
	createProcessingAccountFieldMerchandiseOrServiceSold = big.NewInt(1 << 6)
	createProcessingAccountFieldBusinessStartDate        = big.NewInt(1 << 7)
	createProcessingAccountFieldTimezone                 = big.NewInt(1 << 8)
	createProcessingAccountFieldAddress                  = big.NewInt(1 << 9)
	createProcessingAccountFieldContactMethods           = big.NewInt(1 << 10)
	createProcessingAccountFieldProcessing               = big.NewInt(1 << 11)
	createProcessingAccountFieldFunding                  = big.NewInt(1 << 12)
	createProcessingAccountFieldPricing                  = big.NewInt(1 << 13)
	createProcessingAccountFieldSignature                = big.NewInt(1 << 14)
	createProcessingAccountFieldContacts                 = big.NewInt(1 << 15)
	createProcessingAccountFieldMetadata                 = big.NewInt(1 << 16)
)

type CreateProcessingAccount struct {
	// Unique identifier of the processing account.
	ProcessingAccountId *string `json:"processingAccountId,omitempty" url:"processingAccountId,omitempty"`
	// Trading name of the business.
	DoingBusinessAs string `json:"doingBusinessAs" url:"doingBusinessAs"`
	// Collection of individuals that are responsible for a processing account. When you create a processing account, you must indicate at least one owner as either of the following:
	//
	// - **Control prong** - An individual who has a significant equity stake in the business and can make decisions for the processing account. You can add only one control prong to a processing account.
	// - **Authorized signatory** - An individual who doesn't have an equity stake in the business but can make decisions for the processing account.
	Owners []*Owner `json:"owners" url:"owners"`
	// Website address of the business.
	Website *string `json:"website,omitempty" url:"website,omitempty"`
	// Type of business.
	BusinessType CreateProcessingAccountBusinessType `json:"businessType" url:"businessType"`
	// Merchant Category Code (MCC) for the type of business.
	CategoryCode int `json:"categoryCode" url:"categoryCode"`
	// Description of the services or merchandise sold by the business.
	MerchandiseOrServiceSold string `json:"merchandiseOrServiceSold" url:"merchandiseOrServiceSold"`
	// Date that the business was established. The format of the value is **YYYY-MM-DD**.
	BusinessStartDate time.Time `json:"businessStartDate" url:"businessStartDate" format:"date"`
	Timezone          Timezone  `json:"timezone" url:"timezone"`
	// Polymorphic object that contains address information for the processing account.
	Address *Address `json:"address" url:"address"`
	// Array of polymorphic objects, which contain contact information.
	//
	// **Note:** You must provide an email address.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number.
	ContactMethods []*ContactMethod `json:"contactMethods" url:"contactMethods"`
	Processing     *Processing      `json:"processing" url:"processing"`
	Funding        *CreateFunding   `json:"funding" url:"funding"`
	Pricing        *Pricing         `json:"pricing" url:"pricing"`
	Signature      *Signature       `json:"signature" url:"signature"`
	// Array of contact objects.
	Contacts []*Contact `json:"contacts,omitempty" url:"contacts,omitempty"`
	// Object that you can send to include custom data in the request. For more information about how to use metadata, go to [Metadata](https://docs.payroc.com/api/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateProcessingAccount) GetProcessingAccountId() *string {
	if c == nil {
		return nil
	}
	return c.ProcessingAccountId
}

func (c *CreateProcessingAccount) GetDoingBusinessAs() string {
	if c == nil {
		return ""
	}
	return c.DoingBusinessAs
}

func (c *CreateProcessingAccount) GetOwners() []*Owner {
	if c == nil {
		return nil
	}
	return c.Owners
}

func (c *CreateProcessingAccount) GetWebsite() *string {
	if c == nil {
		return nil
	}
	return c.Website
}

func (c *CreateProcessingAccount) GetBusinessType() CreateProcessingAccountBusinessType {
	if c == nil {
		return ""
	}
	return c.BusinessType
}

func (c *CreateProcessingAccount) GetCategoryCode() int {
	if c == nil {
		return 0
	}
	return c.CategoryCode
}

func (c *CreateProcessingAccount) GetMerchandiseOrServiceSold() string {
	if c == nil {
		return ""
	}
	return c.MerchandiseOrServiceSold
}

func (c *CreateProcessingAccount) GetBusinessStartDate() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.BusinessStartDate
}

func (c *CreateProcessingAccount) GetTimezone() Timezone {
	if c == nil {
		return ""
	}
	return c.Timezone
}

func (c *CreateProcessingAccount) GetAddress() *Address {
	if c == nil {
		return nil
	}
	return c.Address
}

func (c *CreateProcessingAccount) GetContactMethods() []*ContactMethod {
	if c == nil {
		return nil
	}
	return c.ContactMethods
}

func (c *CreateProcessingAccount) GetProcessing() *Processing {
	if c == nil {
		return nil
	}
	return c.Processing
}

func (c *CreateProcessingAccount) GetFunding() *CreateFunding {
	if c == nil {
		return nil
	}
	return c.Funding
}

func (c *CreateProcessingAccount) GetPricing() *Pricing {
	if c == nil {
		return nil
	}
	return c.Pricing
}

func (c *CreateProcessingAccount) GetSignature() *Signature {
	if c == nil {
		return nil
	}
	return c.Signature
}

func (c *CreateProcessingAccount) GetContacts() []*Contact {
	if c == nil {
		return nil
	}
	return c.Contacts
}

func (c *CreateProcessingAccount) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CreateProcessingAccount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateProcessingAccount) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetProcessingAccountId sets the ProcessingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetProcessingAccountId(processingAccountId *string) {
	c.ProcessingAccountId = processingAccountId
	c.require(createProcessingAccountFieldProcessingAccountId)
}

// SetDoingBusinessAs sets the DoingBusinessAs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetDoingBusinessAs(doingBusinessAs string) {
	c.DoingBusinessAs = doingBusinessAs
	c.require(createProcessingAccountFieldDoingBusinessAs)
}

// SetOwners sets the Owners field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetOwners(owners []*Owner) {
	c.Owners = owners
	c.require(createProcessingAccountFieldOwners)
}

// SetWebsite sets the Website field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetWebsite(website *string) {
	c.Website = website
	c.require(createProcessingAccountFieldWebsite)
}

// SetBusinessType sets the BusinessType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetBusinessType(businessType CreateProcessingAccountBusinessType) {
	c.BusinessType = businessType
	c.require(createProcessingAccountFieldBusinessType)
}

// SetCategoryCode sets the CategoryCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetCategoryCode(categoryCode int) {
	c.CategoryCode = categoryCode
	c.require(createProcessingAccountFieldCategoryCode)
}

// SetMerchandiseOrServiceSold sets the MerchandiseOrServiceSold field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetMerchandiseOrServiceSold(merchandiseOrServiceSold string) {
	c.MerchandiseOrServiceSold = merchandiseOrServiceSold
	c.require(createProcessingAccountFieldMerchandiseOrServiceSold)
}

// SetBusinessStartDate sets the BusinessStartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetBusinessStartDate(businessStartDate time.Time) {
	c.BusinessStartDate = businessStartDate
	c.require(createProcessingAccountFieldBusinessStartDate)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetTimezone(timezone Timezone) {
	c.Timezone = timezone
	c.require(createProcessingAccountFieldTimezone)
}

// SetAddress sets the Address field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetAddress(address *Address) {
	c.Address = address
	c.require(createProcessingAccountFieldAddress)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetContactMethods(contactMethods []*ContactMethod) {
	c.ContactMethods = contactMethods
	c.require(createProcessingAccountFieldContactMethods)
}

// SetProcessing sets the Processing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetProcessing(processing *Processing) {
	c.Processing = processing
	c.require(createProcessingAccountFieldProcessing)
}

// SetFunding sets the Funding field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetFunding(funding *CreateFunding) {
	c.Funding = funding
	c.require(createProcessingAccountFieldFunding)
}

// SetPricing sets the Pricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetPricing(pricing *Pricing) {
	c.Pricing = pricing
	c.require(createProcessingAccountFieldPricing)
}

// SetSignature sets the Signature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetSignature(signature *Signature) {
	c.Signature = signature
	c.require(createProcessingAccountFieldSignature)
}

// SetContacts sets the Contacts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetContacts(contacts []*Contact) {
	c.Contacts = contacts
	c.require(createProcessingAccountFieldContacts)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateProcessingAccount) SetMetadata(metadata map[string]string) {
	c.Metadata = metadata
	c.require(createProcessingAccountFieldMetadata)
}

func (c *CreateProcessingAccount) UnmarshalJSON(data []byte) error {
	type embed CreateProcessingAccount
	var unmarshaler = struct {
		embed
		BusinessStartDate *internal.Date `json:"businessStartDate"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CreateProcessingAccount(unmarshaler.embed)
	c.BusinessStartDate = unmarshaler.BusinessStartDate.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateProcessingAccount) MarshalJSON() ([]byte, error) {
	type embed CreateProcessingAccount
	var marshaler = struct {
		embed
		BusinessStartDate *internal.Date `json:"businessStartDate"`
	}{
		embed:             embed(*c),
		BusinessStartDate: internal.NewDate(c.BusinessStartDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateProcessingAccount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Type of business.
type CreateProcessingAccountBusinessType string

const (
	CreateProcessingAccountBusinessTypeRetail       CreateProcessingAccountBusinessType = "retail"
	CreateProcessingAccountBusinessTypeRestaurant   CreateProcessingAccountBusinessType = "restaurant"
	CreateProcessingAccountBusinessTypeInternet     CreateProcessingAccountBusinessType = "internet"
	CreateProcessingAccountBusinessTypeMoto         CreateProcessingAccountBusinessType = "moto"
	CreateProcessingAccountBusinessTypeLodging      CreateProcessingAccountBusinessType = "lodging"
	CreateProcessingAccountBusinessTypeNotForProfit CreateProcessingAccountBusinessType = "notForProfit"
)

func NewCreateProcessingAccountBusinessTypeFromString(s string) (CreateProcessingAccountBusinessType, error) {
	switch s {
	case "retail":
		return CreateProcessingAccountBusinessTypeRetail, nil
	case "restaurant":
		return CreateProcessingAccountBusinessTypeRestaurant, nil
	case "internet":
		return CreateProcessingAccountBusinessTypeInternet, nil
	case "moto":
		return CreateProcessingAccountBusinessTypeMoto, nil
	case "lodging":
		return CreateProcessingAccountBusinessTypeLodging, nil
	case "notForProfit":
		return CreateProcessingAccountBusinessTypeNotForProfit, nil
	}
	var t CreateProcessingAccountBusinessType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateProcessingAccountBusinessType) Ptr() *CreateProcessingAccountBusinessType {
	return &c
}

// Currency of the transaction. The value for the currency follows the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) standard.
type Currency string

const (
	CurrencyAed Currency = "AED"
	CurrencyAfn Currency = "AFN"
	CurrencyAll Currency = "ALL"
	CurrencyAmd Currency = "AMD"
	CurrencyAng Currency = "ANG"
	CurrencyAoa Currency = "AOA"
	CurrencyArs Currency = "ARS"
	CurrencyAud Currency = "AUD"
	CurrencyAwg Currency = "AWG"
	CurrencyAzn Currency = "AZN"
	CurrencyBam Currency = "BAM"
	CurrencyBbd Currency = "BBD"
	CurrencyBdt Currency = "BDT"
	CurrencyBgn Currency = "BGN"
	CurrencyBhd Currency = "BHD"
	CurrencyBif Currency = "BIF"
	CurrencyBmd Currency = "BMD"
	CurrencyBnd Currency = "BND"
	CurrencyBob Currency = "BOB"
	CurrencyBov Currency = "BOV"
	CurrencyBrl Currency = "BRL"
	CurrencyBsd Currency = "BSD"
	CurrencyBtn Currency = "BTN"
	CurrencyBwp Currency = "BWP"
	CurrencyByr Currency = "BYR"
	CurrencyBzd Currency = "BZD"
	CurrencyCad Currency = "CAD"
	CurrencyCdf Currency = "CDF"
	CurrencyChe Currency = "CHE"
	CurrencyChf Currency = "CHF"
	CurrencyChw Currency = "CHW"
	CurrencyClf Currency = "CLF"
	CurrencyClp Currency = "CLP"
	CurrencyCny Currency = "CNY"
	CurrencyCop Currency = "COP"
	CurrencyCou Currency = "COU"
	CurrencyCrc Currency = "CRC"
	CurrencyCuc Currency = "CUC"
	CurrencyCup Currency = "CUP"
	CurrencyCve Currency = "CVE"
	CurrencyCzk Currency = "CZK"
	CurrencyDjf Currency = "DJF"
	CurrencyDkk Currency = "DKK"
	CurrencyDop Currency = "DOP"
	CurrencyDzd Currency = "DZD"
	CurrencyEgp Currency = "EGP"
	CurrencyErn Currency = "ERN"
	CurrencyEtb Currency = "ETB"
	CurrencyEur Currency = "EUR"
	CurrencyFjd Currency = "FJD"
	CurrencyFkp Currency = "FKP"
	CurrencyGbp Currency = "GBP"
	CurrencyGel Currency = "GEL"
	CurrencyGhs Currency = "GHS"
	CurrencyGip Currency = "GIP"
	CurrencyGmd Currency = "GMD"
	CurrencyGnf Currency = "GNF"
	CurrencyGtq Currency = "GTQ"
	CurrencyGyd Currency = "GYD"
	CurrencyHkd Currency = "HKD"
	CurrencyHnl Currency = "HNL"
	CurrencyHrk Currency = "HRK"
	CurrencyHtg Currency = "HTG"
	CurrencyHuf Currency = "HUF"
	CurrencyIdr Currency = "IDR"
	CurrencyIls Currency = "ILS"
	CurrencyInr Currency = "INR"
	CurrencyIqd Currency = "IQD"
	CurrencyIrr Currency = "IRR"
	CurrencyIsk Currency = "ISK"
	CurrencyJmd Currency = "JMD"
	CurrencyJod Currency = "JOD"
	CurrencyJpy Currency = "JPY"
	CurrencyKes Currency = "KES"
	CurrencyKgs Currency = "KGS"
	CurrencyKhr Currency = "KHR"
	CurrencyKmf Currency = "KMF"
	CurrencyKpw Currency = "KPW"
	CurrencyKrw Currency = "KRW"
	CurrencyKwd Currency = "KWD"
	CurrencyKyd Currency = "KYD"
	CurrencyKzt Currency = "KZT"
	CurrencyLak Currency = "LAK"
	CurrencyLbp Currency = "LBP"
	CurrencyLkr Currency = "LKR"
	CurrencyLrd Currency = "LRD"
	CurrencyLsl Currency = "LSL"
	CurrencyLtl Currency = "LTL"
	CurrencyLvl Currency = "LVL"
	CurrencyLyd Currency = "LYD"
	CurrencyMad Currency = "MAD"
	CurrencyMdl Currency = "MDL"
	CurrencyMga Currency = "MGA"
	CurrencyMkd Currency = "MKD"
	CurrencyMmk Currency = "MMK"
	CurrencyMnt Currency = "MNT"
	CurrencyMop Currency = "MOP"
	CurrencyMro Currency = "MRO"
	CurrencyMru Currency = "MRU"
	CurrencyMur Currency = "MUR"
	CurrencyMvr Currency = "MVR"
	CurrencyMwk Currency = "MWK"
	CurrencyMxn Currency = "MXN"
	CurrencyMxv Currency = "MXV"
	CurrencyMyr Currency = "MYR"
	CurrencyMzn Currency = "MZN"
	CurrencyNad Currency = "NAD"
	CurrencyNgn Currency = "NGN"
	CurrencyNio Currency = "NIO"
	CurrencyNok Currency = "NOK"
	CurrencyNpr Currency = "NPR"
	CurrencyNzd Currency = "NZD"
	CurrencyOmr Currency = "OMR"
	CurrencyPab Currency = "PAB"
	CurrencyPen Currency = "PEN"
	CurrencyPgk Currency = "PGK"
	CurrencyPhp Currency = "PHP"
	CurrencyPkr Currency = "PKR"
	CurrencyPln Currency = "PLN"
	CurrencyPyg Currency = "PYG"
	CurrencyQar Currency = "QAR"
	CurrencyRon Currency = "RON"
	CurrencyRsd Currency = "RSD"
	CurrencyRub Currency = "RUB"
	CurrencyRwf Currency = "RWF"
	CurrencySar Currency = "SAR"
	CurrencySbd Currency = "SBD"
	CurrencyScr Currency = "SCR"
	CurrencySdg Currency = "SDG"
	CurrencySek Currency = "SEK"
	CurrencySgd Currency = "SGD"
	CurrencyShp Currency = "SHP"
	CurrencySll Currency = "SLL"
	CurrencySos Currency = "SOS"
	CurrencySrd Currency = "SRD"
	CurrencySsp Currency = "SSP"
	CurrencyStd Currency = "STD"
	CurrencyStn Currency = "STN"
	CurrencySvc Currency = "SVC"
	CurrencySyp Currency = "SYP"
	CurrencySzl Currency = "SZL"
	CurrencyThb Currency = "THB"
	CurrencyTjs Currency = "TJS"
	CurrencyTmt Currency = "TMT"
	CurrencyTnd Currency = "TND"
	CurrencyTop Currency = "TOP"
	CurrencyTry Currency = "TRY"
	CurrencyTtd Currency = "TTD"
	CurrencyTwd Currency = "TWD"
	CurrencyTzs Currency = "TZS"
	CurrencyUah Currency = "UAH"
	CurrencyUgx Currency = "UGX"
	CurrencyUsd Currency = "USD"
	CurrencyUsn Currency = "USN"
	CurrencyUss Currency = "USS"
	CurrencyUyi Currency = "UYI"
	CurrencyUyu Currency = "UYU"
	CurrencyUzs Currency = "UZS"
	CurrencyVef Currency = "VEF"
	CurrencyVes Currency = "VES"
	CurrencyVnd Currency = "VND"
	CurrencyVuv Currency = "VUV"
	CurrencyWst Currency = "WST"
	CurrencyXaf Currency = "XAF"
	CurrencyXcd Currency = "XCD"
	CurrencyXof Currency = "XOF"
	CurrencyXpf Currency = "XPF"
	CurrencyYer Currency = "YER"
	CurrencyZar Currency = "ZAR"
	CurrencyZmw Currency = "ZMW"
	CurrencyZwl Currency = "ZWL"
)

func NewCurrencyFromString(s string) (Currency, error) {
	switch s {
	case "AED":
		return CurrencyAed, nil
	case "AFN":
		return CurrencyAfn, nil
	case "ALL":
		return CurrencyAll, nil
	case "AMD":
		return CurrencyAmd, nil
	case "ANG":
		return CurrencyAng, nil
	case "AOA":
		return CurrencyAoa, nil
	case "ARS":
		return CurrencyArs, nil
	case "AUD":
		return CurrencyAud, nil
	case "AWG":
		return CurrencyAwg, nil
	case "AZN":
		return CurrencyAzn, nil
	case "BAM":
		return CurrencyBam, nil
	case "BBD":
		return CurrencyBbd, nil
	case "BDT":
		return CurrencyBdt, nil
	case "BGN":
		return CurrencyBgn, nil
	case "BHD":
		return CurrencyBhd, nil
	case "BIF":
		return CurrencyBif, nil
	case "BMD":
		return CurrencyBmd, nil
	case "BND":
		return CurrencyBnd, nil
	case "BOB":
		return CurrencyBob, nil
	case "BOV":
		return CurrencyBov, nil
	case "BRL":
		return CurrencyBrl, nil
	case "BSD":
		return CurrencyBsd, nil
	case "BTN":
		return CurrencyBtn, nil
	case "BWP":
		return CurrencyBwp, nil
	case "BYR":
		return CurrencyByr, nil
	case "BZD":
		return CurrencyBzd, nil
	case "CAD":
		return CurrencyCad, nil
	case "CDF":
		return CurrencyCdf, nil
	case "CHE":
		return CurrencyChe, nil
	case "CHF":
		return CurrencyChf, nil
	case "CHW":
		return CurrencyChw, nil
	case "CLF":
		return CurrencyClf, nil
	case "CLP":
		return CurrencyClp, nil
	case "CNY":
		return CurrencyCny, nil
	case "COP":
		return CurrencyCop, nil
	case "COU":
		return CurrencyCou, nil
	case "CRC":
		return CurrencyCrc, nil
	case "CUC":
		return CurrencyCuc, nil
	case "CUP":
		return CurrencyCup, nil
	case "CVE":
		return CurrencyCve, nil
	case "CZK":
		return CurrencyCzk, nil
	case "DJF":
		return CurrencyDjf, nil
	case "DKK":
		return CurrencyDkk, nil
	case "DOP":
		return CurrencyDop, nil
	case "DZD":
		return CurrencyDzd, nil
	case "EGP":
		return CurrencyEgp, nil
	case "ERN":
		return CurrencyErn, nil
	case "ETB":
		return CurrencyEtb, nil
	case "EUR":
		return CurrencyEur, nil
	case "FJD":
		return CurrencyFjd, nil
	case "FKP":
		return CurrencyFkp, nil
	case "GBP":
		return CurrencyGbp, nil
	case "GEL":
		return CurrencyGel, nil
	case "GHS":
		return CurrencyGhs, nil
	case "GIP":
		return CurrencyGip, nil
	case "GMD":
		return CurrencyGmd, nil
	case "GNF":
		return CurrencyGnf, nil
	case "GTQ":
		return CurrencyGtq, nil
	case "GYD":
		return CurrencyGyd, nil
	case "HKD":
		return CurrencyHkd, nil
	case "HNL":
		return CurrencyHnl, nil
	case "HRK":
		return CurrencyHrk, nil
	case "HTG":
		return CurrencyHtg, nil
	case "HUF":
		return CurrencyHuf, nil
	case "IDR":
		return CurrencyIdr, nil
	case "ILS":
		return CurrencyIls, nil
	case "INR":
		return CurrencyInr, nil
	case "IQD":
		return CurrencyIqd, nil
	case "IRR":
		return CurrencyIrr, nil
	case "ISK":
		return CurrencyIsk, nil
	case "JMD":
		return CurrencyJmd, nil
	case "JOD":
		return CurrencyJod, nil
	case "JPY":
		return CurrencyJpy, nil
	case "KES":
		return CurrencyKes, nil
	case "KGS":
		return CurrencyKgs, nil
	case "KHR":
		return CurrencyKhr, nil
	case "KMF":
		return CurrencyKmf, nil
	case "KPW":
		return CurrencyKpw, nil
	case "KRW":
		return CurrencyKrw, nil
	case "KWD":
		return CurrencyKwd, nil
	case "KYD":
		return CurrencyKyd, nil
	case "KZT":
		return CurrencyKzt, nil
	case "LAK":
		return CurrencyLak, nil
	case "LBP":
		return CurrencyLbp, nil
	case "LKR":
		return CurrencyLkr, nil
	case "LRD":
		return CurrencyLrd, nil
	case "LSL":
		return CurrencyLsl, nil
	case "LTL":
		return CurrencyLtl, nil
	case "LVL":
		return CurrencyLvl, nil
	case "LYD":
		return CurrencyLyd, nil
	case "MAD":
		return CurrencyMad, nil
	case "MDL":
		return CurrencyMdl, nil
	case "MGA":
		return CurrencyMga, nil
	case "MKD":
		return CurrencyMkd, nil
	case "MMK":
		return CurrencyMmk, nil
	case "MNT":
		return CurrencyMnt, nil
	case "MOP":
		return CurrencyMop, nil
	case "MRO":
		return CurrencyMro, nil
	case "MRU":
		return CurrencyMru, nil
	case "MUR":
		return CurrencyMur, nil
	case "MVR":
		return CurrencyMvr, nil
	case "MWK":
		return CurrencyMwk, nil
	case "MXN":
		return CurrencyMxn, nil
	case "MXV":
		return CurrencyMxv, nil
	case "MYR":
		return CurrencyMyr, nil
	case "MZN":
		return CurrencyMzn, nil
	case "NAD":
		return CurrencyNad, nil
	case "NGN":
		return CurrencyNgn, nil
	case "NIO":
		return CurrencyNio, nil
	case "NOK":
		return CurrencyNok, nil
	case "NPR":
		return CurrencyNpr, nil
	case "NZD":
		return CurrencyNzd, nil
	case "OMR":
		return CurrencyOmr, nil
	case "PAB":
		return CurrencyPab, nil
	case "PEN":
		return CurrencyPen, nil
	case "PGK":
		return CurrencyPgk, nil
	case "PHP":
		return CurrencyPhp, nil
	case "PKR":
		return CurrencyPkr, nil
	case "PLN":
		return CurrencyPln, nil
	case "PYG":
		return CurrencyPyg, nil
	case "QAR":
		return CurrencyQar, nil
	case "RON":
		return CurrencyRon, nil
	case "RSD":
		return CurrencyRsd, nil
	case "RUB":
		return CurrencyRub, nil
	case "RWF":
		return CurrencyRwf, nil
	case "SAR":
		return CurrencySar, nil
	case "SBD":
		return CurrencySbd, nil
	case "SCR":
		return CurrencyScr, nil
	case "SDG":
		return CurrencySdg, nil
	case "SEK":
		return CurrencySek, nil
	case "SGD":
		return CurrencySgd, nil
	case "SHP":
		return CurrencyShp, nil
	case "SLL":
		return CurrencySll, nil
	case "SOS":
		return CurrencySos, nil
	case "SRD":
		return CurrencySrd, nil
	case "SSP":
		return CurrencySsp, nil
	case "STD":
		return CurrencyStd, nil
	case "STN":
		return CurrencyStn, nil
	case "SVC":
		return CurrencySvc, nil
	case "SYP":
		return CurrencySyp, nil
	case "SZL":
		return CurrencySzl, nil
	case "THB":
		return CurrencyThb, nil
	case "TJS":
		return CurrencyTjs, nil
	case "TMT":
		return CurrencyTmt, nil
	case "TND":
		return CurrencyTnd, nil
	case "TOP":
		return CurrencyTop, nil
	case "TRY":
		return CurrencyTry, nil
	case "TTD":
		return CurrencyTtd, nil
	case "TWD":
		return CurrencyTwd, nil
	case "TZS":
		return CurrencyTzs, nil
	case "UAH":
		return CurrencyUah, nil
	case "UGX":
		return CurrencyUgx, nil
	case "USD":
		return CurrencyUsd, nil
	case "USN":
		return CurrencyUsn, nil
	case "USS":
		return CurrencyUss, nil
	case "UYI":
		return CurrencyUyi, nil
	case "UYU":
		return CurrencyUyu, nil
	case "UZS":
		return CurrencyUzs, nil
	case "VEF":
		return CurrencyVef, nil
	case "VES":
		return CurrencyVes, nil
	case "VND":
		return CurrencyVnd, nil
	case "VUV":
		return CurrencyVuv, nil
	case "WST":
		return CurrencyWst, nil
	case "XAF":
		return CurrencyXaf, nil
	case "XCD":
		return CurrencyXcd, nil
	case "XOF":
		return CurrencyXof, nil
	case "XPF":
		return CurrencyXpf, nil
	case "YER":
		return CurrencyYer, nil
	case "ZAR":
		return CurrencyZar, nil
	case "ZMW":
		return CurrencyZmw, nil
	case "ZWL":
		return CurrencyZwl, nil
	}
	var t Currency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Currency) Ptr() *Currency {
	return &c
}

var (
	customFieldFieldName  = big.NewInt(1 << 0)
	customFieldFieldValue = big.NewInt(1 << 1)
)

type CustomField struct {
	// Name of the custom field.
	Name string `json:"name" url:"name"`
	// Value for the custom field.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomField) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CustomField) GetValue() string {
	if c == nil {
		return ""
	}
	return c.Value
}

func (c *CustomField) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomField) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomField) SetName(name string) {
	c.Name = name
	c.require(customFieldFieldName)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomField) SetValue(value string) {
	c.Value = value
	c.require(customFieldFieldValue)
}

func (c *CustomField) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomField) MarshalJSON() ([]byte, error) {
	type embed CustomField
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CustomField) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains the customer's contact details and address information.
var (
	customerFieldFirstName            = big.NewInt(1 << 0)
	customerFieldLastName             = big.NewInt(1 << 1)
	customerFieldDateOfBirth          = big.NewInt(1 << 2)
	customerFieldReferenceNumber      = big.NewInt(1 << 3)
	customerFieldBillingAddress       = big.NewInt(1 << 4)
	customerFieldShippingAddress      = big.NewInt(1 << 5)
	customerFieldContactMethods       = big.NewInt(1 << 6)
	customerFieldNotificationLanguage = big.NewInt(1 << 7)
)

type Customer struct {
	// Customer's first name.
	FirstName *string `json:"firstName,omitempty" url:"firstName,omitempty"`
	// Customer's last name.
	LastName *string `json:"lastName,omitempty" url:"lastName,omitempty"`
	// Customer's date of birth. The format for this value is **YYYY-MM-DD**.
	DateOfBirth *time.Time `json:"dateOfBirth,omitempty" url:"dateOfBirth,omitempty" format:"date"`
	// Identifier of the transaction, also known as a customer code.
	//
	// For requests, you must send a value for **referenceNumber** if the customer provides one.
	ReferenceNumber *string `json:"referenceNumber,omitempty" url:"referenceNumber,omitempty"`
	// Object that contains information about the address that the card is registered to.
	BillingAddress  *Address  `json:"billingAddress,omitempty" url:"billingAddress,omitempty"`
	ShippingAddress *Shipping `json:"shippingAddress,omitempty" url:"shippingAddress,omitempty"`
	// Array of polymorphic objects, which contain contact information.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods,omitempty" url:"contactMethods,omitempty"`
	// Language that the customer uses for notifications. This code follows the [ISO 639-1](https://www.iso.org/iso-639-language-code) alpha-2 standard.
	NotificationLanguage *CustomerNotificationLanguage `json:"notificationLanguage,omitempty" url:"notificationLanguage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Customer) GetFirstName() *string {
	if c == nil {
		return nil
	}
	return c.FirstName
}

func (c *Customer) GetLastName() *string {
	if c == nil {
		return nil
	}
	return c.LastName
}

func (c *Customer) GetDateOfBirth() *time.Time {
	if c == nil {
		return nil
	}
	return c.DateOfBirth
}

func (c *Customer) GetReferenceNumber() *string {
	if c == nil {
		return nil
	}
	return c.ReferenceNumber
}

func (c *Customer) GetBillingAddress() *Address {
	if c == nil {
		return nil
	}
	return c.BillingAddress
}

func (c *Customer) GetShippingAddress() *Shipping {
	if c == nil {
		return nil
	}
	return c.ShippingAddress
}

func (c *Customer) GetContactMethods() []*ContactMethod {
	if c == nil {
		return nil
	}
	return c.ContactMethods
}

func (c *Customer) GetNotificationLanguage() *CustomerNotificationLanguage {
	if c == nil {
		return nil
	}
	return c.NotificationLanguage
}

func (c *Customer) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Customer) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetFirstName sets the FirstName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetFirstName(firstName *string) {
	c.FirstName = firstName
	c.require(customerFieldFirstName)
}

// SetLastName sets the LastName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetLastName(lastName *string) {
	c.LastName = lastName
	c.require(customerFieldLastName)
}

// SetDateOfBirth sets the DateOfBirth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetDateOfBirth(dateOfBirth *time.Time) {
	c.DateOfBirth = dateOfBirth
	c.require(customerFieldDateOfBirth)
}

// SetReferenceNumber sets the ReferenceNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetReferenceNumber(referenceNumber *string) {
	c.ReferenceNumber = referenceNumber
	c.require(customerFieldReferenceNumber)
}

// SetBillingAddress sets the BillingAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetBillingAddress(billingAddress *Address) {
	c.BillingAddress = billingAddress
	c.require(customerFieldBillingAddress)
}

// SetShippingAddress sets the ShippingAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetShippingAddress(shippingAddress *Shipping) {
	c.ShippingAddress = shippingAddress
	c.require(customerFieldShippingAddress)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetContactMethods(contactMethods []*ContactMethod) {
	c.ContactMethods = contactMethods
	c.require(customerFieldContactMethods)
}

// SetNotificationLanguage sets the NotificationLanguage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Customer) SetNotificationLanguage(notificationLanguage *CustomerNotificationLanguage) {
	c.NotificationLanguage = notificationLanguage
	c.require(customerFieldNotificationLanguage)
}

func (c *Customer) UnmarshalJSON(data []byte) error {
	type embed Customer
	var unmarshaler = struct {
		embed
		DateOfBirth *internal.Date `json:"dateOfBirth,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Customer(unmarshaler.embed)
	c.DateOfBirth = unmarshaler.DateOfBirth.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Customer) MarshalJSON() ([]byte, error) {
	type embed Customer
	var marshaler = struct {
		embed
		DateOfBirth *internal.Date `json:"dateOfBirth,omitempty"`
	}{
		embed:       embed(*c),
		DateOfBirth: internal.NewOptionalDate(c.DateOfBirth),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *Customer) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Object that contains information about the adjustment to the transaction. Send this object if the merchant is adjusting the customer’s contact details.
var (
	customerAdjustmentFieldShippingAddress = big.NewInt(1 << 0)
	customerAdjustmentFieldContactMethods  = big.NewInt(1 << 1)
)

type CustomerAdjustment struct {
	ShippingAddress *Shipping `json:"shippingAddress,omitempty" url:"shippingAddress,omitempty"`
	// Array of polymorphic objects, which contain contact information.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods,omitempty" url:"contactMethods,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerAdjustment) GetShippingAddress() *Shipping {
	if c == nil {
		return nil
	}
	return c.ShippingAddress
}

func (c *CustomerAdjustment) GetContactMethods() []*ContactMethod {
	if c == nil {
		return nil
	}
	return c.ContactMethods
}

func (c *CustomerAdjustment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerAdjustment) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetShippingAddress sets the ShippingAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomerAdjustment) SetShippingAddress(shippingAddress *Shipping) {
	c.ShippingAddress = shippingAddress
	c.require(customerAdjustmentFieldShippingAddress)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomerAdjustment) SetContactMethods(contactMethods []*ContactMethod) {
	c.ContactMethods = contactMethods
	c.require(customerAdjustmentFieldContactMethods)
}

func (c *CustomerAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerAdjustment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerAdjustment) MarshalJSON() ([]byte, error) {
	type embed CustomerAdjustment
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CustomerAdjustment) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Language that the customer uses for notifications. This code follows the [ISO 639-1](https://www.iso.org/iso-639-language-code) alpha-2 standard.
type CustomerNotificationLanguage string

const (
	CustomerNotificationLanguageEn CustomerNotificationLanguage = "en"
	CustomerNotificationLanguageFr CustomerNotificationLanguage = "fr"
)

func NewCustomerNotificationLanguageFromString(s string) (CustomerNotificationLanguage, error) {
	switch s {
	case "en":
		return CustomerNotificationLanguageEn, nil
	case "fr":
		return CustomerNotificationLanguageFr, nil
	}
	var t CustomerNotificationLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomerNotificationLanguage) Ptr() *CustomerNotificationLanguage {
	return &c
}

// Object that contains available options to customize certain aspects of an instruction.
var (
	customizationOptionsFieldEbtDetails  = big.NewInt(1 << 0)
	customizationOptionsFieldEntryMethod = big.NewInt(1 << 1)
)

type CustomizationOptions struct {
	EbtDetails *EbtDetails `json:"ebtDetails,omitempty" url:"ebtDetails,omitempty"`
	// Indicates how you want the device to capture the card details.
	// - `deviceRead` - Device prompts the cardholder to tap, swipe, or insert their card.
	// - `manualEntry` - Device prompts the merchant or cardholder to manually enter card details.
	// - `deviceReadOrManualEntry` - Device prompts the cardholder to tap, swipe, or insert their card. The device also displays an option for the merchant or cardholder to manually enter card details.
	EntryMethod *CustomizationOptionsEntryMethod `json:"entryMethod,omitempty" url:"entryMethod,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomizationOptions) GetEbtDetails() *EbtDetails {
	if c == nil {
		return nil
	}
	return c.EbtDetails
}

func (c *CustomizationOptions) GetEntryMethod() *CustomizationOptionsEntryMethod {
	if c == nil {
		return nil
	}
	return c.EntryMethod
}

func (c *CustomizationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomizationOptions) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetEbtDetails sets the EbtDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomizationOptions) SetEbtDetails(ebtDetails *EbtDetails) {
	c.EbtDetails = ebtDetails
	c.require(customizationOptionsFieldEbtDetails)
}

// SetEntryMethod sets the EntryMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CustomizationOptions) SetEntryMethod(entryMethod *CustomizationOptionsEntryMethod) {
	c.EntryMethod = entryMethod
	c.require(customizationOptionsFieldEntryMethod)
}

func (c *CustomizationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomizationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomizationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomizationOptions) MarshalJSON() ([]byte, error) {
	type embed CustomizationOptions
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CustomizationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates how you want the device to capture the card details.
// - `deviceRead` - Device prompts the cardholder to tap, swipe, or insert their card.
// - `manualEntry` - Device prompts the merchant or cardholder to manually enter card details.
// - `deviceReadOrManualEntry` - Device prompts the cardholder to tap, swipe, or insert their card. The device also displays an option for the merchant or cardholder to manually enter card details.
type CustomizationOptionsEntryMethod string

const (
	CustomizationOptionsEntryMethodDeviceRead              CustomizationOptionsEntryMethod = "deviceRead"
	CustomizationOptionsEntryMethodManualEntry             CustomizationOptionsEntryMethod = "manualEntry"
	CustomizationOptionsEntryMethodDeviceReadOrManualEntry CustomizationOptionsEntryMethod = "deviceReadOrManualEntry"
)

func NewCustomizationOptionsEntryMethodFromString(s string) (CustomizationOptionsEntryMethod, error) {
	switch s {
	case "deviceRead":
		return CustomizationOptionsEntryMethodDeviceRead, nil
	case "manualEntry":
		return CustomizationOptionsEntryMethodManualEntry, nil
	case "deviceReadOrManualEntry":
		return CustomizationOptionsEntryMethodDeviceReadOrManualEntry, nil
	}
	var t CustomizationOptionsEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomizationOptionsEntryMethod) Ptr() *CustomizationOptionsEntryMethod {
	return &c
}

// Object that contains information about the dynamic currency conversion (DCC) offer.
//
// For more information about DCC, go to [Dynamic Currency Conversion](https://docs.payroc.com/knowledge/card-payments/dynamic-currency-conversion).
var (
	dccOfferFieldAccepted           = big.NewInt(1 << 0)
	dccOfferFieldOfferReference     = big.NewInt(1 << 1)
	dccOfferFieldFxAmount           = big.NewInt(1 << 2)
	dccOfferFieldFxCurrency         = big.NewInt(1 << 3)
	dccOfferFieldFxCurrencyCode     = big.NewInt(1 << 4)
	dccOfferFieldFxCurrencyExponent = big.NewInt(1 << 5)
	dccOfferFieldFxRate             = big.NewInt(1 << 6)
	dccOfferFieldMarkup             = big.NewInt(1 << 7)
	dccOfferFieldMarkupText         = big.NewInt(1 << 8)
	dccOfferFieldProvider           = big.NewInt(1 << 9)
	dccOfferFieldSource             = big.NewInt(1 << 10)
)

type DccOffer struct {
	// Indicates if the cardholder accepted DCC offer.
	Accepted *bool `json:"accepted,omitempty" url:"accepted,omitempty"`
	// Unique identifier of the DCC offer.
	OfferReference *string `json:"offerReference,omitempty" url:"offerReference,omitempty"`
	// Amount in the cardholder’s currency in the currency’s lowest denomination, for example, cents.
	FxAmount int64 `json:"fxAmount" url:"fxAmount"`
	// Currency of the transaction in the card’s currency. The value for the currency follows the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) standard.
	FxCurrency Currency `json:"fxCurrency" url:"fxCurrency"`
	// Three-digit currency code for the card. This code follows the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) standard.
	FxCurrencyCode *string `json:"fxCurrencyCode,omitempty" url:"fxCurrencyCode,omitempty"`
	// Number of decimal places between the smallest currency unit and a whole currency unit.
	//
	// For example, for GBP, the smallest currency unit is 1p and it is equal to £0.01.
	// If you use GBP, the value for **fxCurrencyExponent** is 2.
	FxCurrencyExponent *int `json:"fxCurrencyExponent,omitempty" url:"fxCurrencyExponent,omitempty"`
	// Foreign exchange rate for the card's currency.
	FxRate float64 `json:"fxRate" url:"fxRate"`
	// Markup percentage rate that the DCC provider applies to the foreign exchange rate.
	Markup float64 `json:"markup" url:"markup"`
	// Supporting text for the markup rate.
	MarkupText *string `json:"markupText,omitempty" url:"markupText,omitempty"`
	// Name of the DCC provider.
	Provider *string `json:"provider,omitempty" url:"provider,omitempty"`
	// Source that the DCC provider used to get the foreign exchange rates.
	Source *string `json:"source,omitempty" url:"source,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DccOffer) GetAccepted() *bool {
	if d == nil {
		return nil
	}
	return d.Accepted
}

func (d *DccOffer) GetOfferReference() *string {
	if d == nil {
		return nil
	}
	return d.OfferReference
}

func (d *DccOffer) GetFxAmount() int64 {
	if d == nil {
		return 0
	}
	return d.FxAmount
}

func (d *DccOffer) GetFxCurrency() Currency {
	if d == nil {
		return ""
	}
	return d.FxCurrency
}

func (d *DccOffer) GetFxCurrencyCode() *string {
	if d == nil {
		return nil
	}
	return d.FxCurrencyCode
}

func (d *DccOffer) GetFxCurrencyExponent() *int {
	if d == nil {
		return nil
	}
	return d.FxCurrencyExponent
}

func (d *DccOffer) GetFxRate() float64 {
	if d == nil {
		return 0
	}
	return d.FxRate
}

func (d *DccOffer) GetMarkup() float64 {
	if d == nil {
		return 0
	}
	return d.Markup
}

func (d *DccOffer) GetMarkupText() *string {
	if d == nil {
		return nil
	}
	return d.MarkupText
}

func (d *DccOffer) GetProvider() *string {
	if d == nil {
		return nil
	}
	return d.Provider
}

func (d *DccOffer) GetSource() *string {
	if d == nil {
		return nil
	}
	return d.Source
}

func (d *DccOffer) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DccOffer) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetAccepted sets the Accepted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetAccepted(accepted *bool) {
	d.Accepted = accepted
	d.require(dccOfferFieldAccepted)
}

// SetOfferReference sets the OfferReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetOfferReference(offerReference *string) {
	d.OfferReference = offerReference
	d.require(dccOfferFieldOfferReference)
}

// SetFxAmount sets the FxAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetFxAmount(fxAmount int64) {
	d.FxAmount = fxAmount
	d.require(dccOfferFieldFxAmount)
}

// SetFxCurrency sets the FxCurrency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetFxCurrency(fxCurrency Currency) {
	d.FxCurrency = fxCurrency
	d.require(dccOfferFieldFxCurrency)
}

// SetFxCurrencyCode sets the FxCurrencyCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetFxCurrencyCode(fxCurrencyCode *string) {
	d.FxCurrencyCode = fxCurrencyCode
	d.require(dccOfferFieldFxCurrencyCode)
}

// SetFxCurrencyExponent sets the FxCurrencyExponent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetFxCurrencyExponent(fxCurrencyExponent *int) {
	d.FxCurrencyExponent = fxCurrencyExponent
	d.require(dccOfferFieldFxCurrencyExponent)
}

// SetFxRate sets the FxRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetFxRate(fxRate float64) {
	d.FxRate = fxRate
	d.require(dccOfferFieldFxRate)
}

// SetMarkup sets the Markup field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetMarkup(markup float64) {
	d.Markup = markup
	d.require(dccOfferFieldMarkup)
}

// SetMarkupText sets the MarkupText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetMarkupText(markupText *string) {
	d.MarkupText = markupText
	d.require(dccOfferFieldMarkupText)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetProvider(provider *string) {
	d.Provider = provider
	d.require(dccOfferFieldProvider)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DccOffer) SetSource(source *string) {
	d.Source = source
	d.require(dccOfferFieldSource)
}

func (d *DccOffer) UnmarshalJSON(data []byte) error {
	type unmarshaler DccOffer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DccOffer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DccOffer) MarshalJSON() ([]byte, error) {
	type embed DccOffer
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DccOffer) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Object that contains information about the physical device the merchant used to capture the customer’s card details.
var (
	deviceFieldModel           = big.NewInt(1 << 0)
	deviceFieldCategory        = big.NewInt(1 << 1)
	deviceFieldSerialNumber    = big.NewInt(1 << 2)
	deviceFieldFirmwareVersion = big.NewInt(1 << 3)
	deviceFieldConfig          = big.NewInt(1 << 4)
)

type Device struct {
	// Model of the device that the merchant used to process the transaction.
	Model DeviceModel `json:"model" url:"model"`
	// Indicates if the device is attended or unattended.
	Category *DeviceCategory `json:"category,omitempty" url:"category,omitempty"`
	// Serial number of the physical device.
	SerialNumber string `json:"serialNumber" url:"serialNumber"`
	// Firmware version of the physical device.
	FirmwareVersion *string       `json:"firmwareVersion,omitempty" url:"firmwareVersion,omitempty"`
	Config          *DeviceConfig `json:"config,omitempty" url:"config,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Device) GetModel() DeviceModel {
	if d == nil {
		return ""
	}
	return d.Model
}

func (d *Device) GetCategory() *DeviceCategory {
	if d == nil {
		return nil
	}
	return d.Category
}

func (d *Device) GetSerialNumber() string {
	if d == nil {
		return ""
	}
	return d.SerialNumber
}

func (d *Device) GetFirmwareVersion() *string {
	if d == nil {
		return nil
	}
	return d.FirmwareVersion
}

func (d *Device) GetConfig() *DeviceConfig {
	if d == nil {
		return nil
	}
	return d.Config
}

func (d *Device) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Device) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetModel(model DeviceModel) {
	d.Model = model
	d.require(deviceFieldModel)
}

// SetCategory sets the Category field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetCategory(category *DeviceCategory) {
	d.Category = category
	d.require(deviceFieldCategory)
}

// SetSerialNumber sets the SerialNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetSerialNumber(serialNumber string) {
	d.SerialNumber = serialNumber
	d.require(deviceFieldSerialNumber)
}

// SetFirmwareVersion sets the FirmwareVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetFirmwareVersion(firmwareVersion *string) {
	d.FirmwareVersion = firmwareVersion
	d.require(deviceFieldFirmwareVersion)
}

// SetConfig sets the Config field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Device) SetConfig(config *DeviceConfig) {
	d.Config = config
	d.require(deviceFieldConfig)
}

func (d *Device) UnmarshalJSON(data []byte) error {
	type unmarshaler Device
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Device(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Device) MarshalJSON() ([]byte, error) {
	type embed Device
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *Device) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Indicates if the device is attended or unattended.
type DeviceCategory string

const (
	DeviceCategoryAttended   DeviceCategory = "attended"
	DeviceCategoryUnattended DeviceCategory = "unattended"
)

func NewDeviceCategoryFromString(s string) (DeviceCategory, error) {
	switch s {
	case "attended":
		return DeviceCategoryAttended, nil
	case "unattended":
		return DeviceCategoryUnattended, nil
	}
	var t DeviceCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceCategory) Ptr() *DeviceCategory {
	return &d
}

// Object that contains information about the configuration of the POS terminal.
var (
	deviceConfigFieldQuickChip = big.NewInt(1 << 0)
)

type DeviceConfig struct {
	// Indicates if Quick Chip mode is active on a merchant’s POS terminal.
	QuickChip bool `json:"quickChip" url:"quickChip"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceConfig) GetQuickChip() bool {
	if d == nil {
		return false
	}
	return d.QuickChip
}

func (d *DeviceConfig) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceConfig) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetQuickChip sets the QuickChip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceConfig) SetQuickChip(quickChip bool) {
	d.QuickChip = quickChip
	d.require(deviceConfigFieldQuickChip)
}

func (d *DeviceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceConfig) MarshalJSON() ([]byte, error) {
	type embed DeviceConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeviceConfig) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Object that contains information about the status of the instruction
var (
	deviceInstructionFieldStatus       = big.NewInt(1 << 0)
	deviceInstructionFieldErrorMessage = big.NewInt(1 << 1)
	deviceInstructionFieldLink         = big.NewInt(1 << 2)
)

type DeviceInstruction struct {
	// Indicates the current status of the instruction.
	// - `canceled` – The instruction was canceled before it was completed.
	// - `completed` – The instruction has completed. Use the link object to check the resource.
	// - `failure` – The instruction failed. Check the errorMessage field for more information.
	// - `inProgress` – The instruction is currently in progress.
	Status *DeviceInstructionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Description of the error that caused the instruction to fail.
	//
	// **Note:** We return this field only if the status is `failure`.
	ErrorMessage *string `json:"errorMessage,omitempty" url:"errorMessage,omitempty"`
	Link         *Link   `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceInstruction) GetStatus() *DeviceInstructionStatus {
	if d == nil {
		return nil
	}
	return d.Status
}

func (d *DeviceInstruction) GetErrorMessage() *string {
	if d == nil {
		return nil
	}
	return d.ErrorMessage
}

func (d *DeviceInstruction) GetLink() *Link {
	if d == nil {
		return nil
	}
	return d.Link
}

func (d *DeviceInstruction) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceInstruction) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInstruction) SetStatus(status *DeviceInstructionStatus) {
	d.Status = status
	d.require(deviceInstructionFieldStatus)
}

// SetErrorMessage sets the ErrorMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInstruction) SetErrorMessage(errorMessage *string) {
	d.ErrorMessage = errorMessage
	d.require(deviceInstructionFieldErrorMessage)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInstruction) SetLink(link *Link) {
	d.Link = link
	d.require(deviceInstructionFieldLink)
}

func (d *DeviceInstruction) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceInstruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceInstruction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceInstruction) MarshalJSON() ([]byte, error) {
	type embed DeviceInstruction
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeviceInstruction) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Indicates the current status of the instruction.
// - `canceled` – The instruction was canceled before it was completed.
// - `completed` – The instruction has completed. Use the link object to check the resource.
// - `failure` – The instruction failed. Check the errorMessage field for more information.
// - `inProgress` – The instruction is currently in progress.
type DeviceInstructionStatus string

const (
	DeviceInstructionStatusCanceled   DeviceInstructionStatus = "canceled"
	DeviceInstructionStatusCompleted  DeviceInstructionStatus = "completed"
	DeviceInstructionStatusFailure    DeviceInstructionStatus = "failure"
	DeviceInstructionStatusInProgress DeviceInstructionStatus = "inProgress"
)

func NewDeviceInstructionStatusFromString(s string) (DeviceInstructionStatus, error) {
	switch s {
	case "canceled":
		return DeviceInstructionStatusCanceled, nil
	case "completed":
		return DeviceInstructionStatusCompleted, nil
	case "failure":
		return DeviceInstructionStatusFailure, nil
	case "inProgress":
		return DeviceInstructionStatusInProgress, nil
	}
	var t DeviceInstructionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceInstructionStatus) Ptr() *DeviceInstructionStatus {
	return &d
}

// Model of the device that the merchant used to process the transaction.
type DeviceModel string

const (
	DeviceModelBbposChp            DeviceModel = "bbposChp"
	DeviceModelBbposChp2X          DeviceModel = "bbposChp2x"
	DeviceModelBbposChp3X          DeviceModel = "bbposChp3x"
	DeviceModelBbposRambler        DeviceModel = "bbposRambler"
	DeviceModelBbposWp             DeviceModel = "bbposWp"
	DeviceModelBbposWp2            DeviceModel = "bbposWp2"
	DeviceModelBbposWp3            DeviceModel = "bbposWp3"
	DeviceModelGenericCtlsMsr      DeviceModel = "genericCtlsMsr"
	DeviceModelGenericMsr          DeviceModel = "genericMsr"
	DeviceModelIdtechAugusta       DeviceModel = "idtechAugusta"
	DeviceModelIdtechMinismart     DeviceModel = "idtechMinismart"
	DeviceModelIdtechSredkey       DeviceModel = "idtechSredkey"
	DeviceModelIdtechVp3300        DeviceModel = "idtechVp3300"
	DeviceModelIdtechVp5300        DeviceModel = "idtechVp5300"
	DeviceModelIdtechVp6300        DeviceModel = "idtechVp6300"
	DeviceModelIdtechVp6800        DeviceModel = "idtechVp6800"
	DeviceModelIngenicoAxiumDx4000 DeviceModel = "ingenicoAxiumDx4000"
	DeviceModelIngenicoAxiumDx8000 DeviceModel = "ingenicoAxiumDx8000"
	DeviceModelIngenicoAxiumEx8000 DeviceModel = "ingenicoAxiumEx8000"
	DeviceModelIngenicoIct220      DeviceModel = "ingenicoIct220"
	DeviceModelIngenicoIpp320      DeviceModel = "ingenicoIpp320"
	DeviceModelIngenicoIpp350      DeviceModel = "ingenicoIpp350"
	DeviceModelIngenicoIuc285      DeviceModel = "ingenicoIuc285"
	DeviceModelIngenicoL3000       DeviceModel = "ingenicoL3000"
	DeviceModelIngenicoL7000       DeviceModel = "ingenicoL7000"
	DeviceModelIngenicoS2000       DeviceModel = "ingenicoS2000"
	DeviceModelIngenicoS3000       DeviceModel = "ingenicoS3000"
	DeviceModelIngenicoS4000       DeviceModel = "ingenicoS4000"
	DeviceModelIngenicoS5000       DeviceModel = "ingenicoS5000"
	DeviceModelIngenicoS7000       DeviceModel = "ingenicoS7000"
	DeviceModelPaxA80              DeviceModel = "paxA80"
	DeviceModelPaxA920             DeviceModel = "paxA920"
	DeviceModelPaxA920Pro          DeviceModel = "paxA920Pro"
	DeviceModelPaxE500             DeviceModel = "paxE500"
	DeviceModelPaxE700             DeviceModel = "paxE700"
	DeviceModelPaxE800             DeviceModel = "paxE800"
	DeviceModelPaxIm30             DeviceModel = "paxIm30"
	DeviceModelUic680              DeviceModel = "uic680"
	DeviceModelUicBezel8           DeviceModel = "uicBezel8"
)

func NewDeviceModelFromString(s string) (DeviceModel, error) {
	switch s {
	case "bbposChp":
		return DeviceModelBbposChp, nil
	case "bbposChp2x":
		return DeviceModelBbposChp2X, nil
	case "bbposChp3x":
		return DeviceModelBbposChp3X, nil
	case "bbposRambler":
		return DeviceModelBbposRambler, nil
	case "bbposWp":
		return DeviceModelBbposWp, nil
	case "bbposWp2":
		return DeviceModelBbposWp2, nil
	case "bbposWp3":
		return DeviceModelBbposWp3, nil
	case "genericCtlsMsr":
		return DeviceModelGenericCtlsMsr, nil
	case "genericMsr":
		return DeviceModelGenericMsr, nil
	case "idtechAugusta":
		return DeviceModelIdtechAugusta, nil
	case "idtechMinismart":
		return DeviceModelIdtechMinismart, nil
	case "idtechSredkey":
		return DeviceModelIdtechSredkey, nil
	case "idtechVp3300":
		return DeviceModelIdtechVp3300, nil
	case "idtechVp5300":
		return DeviceModelIdtechVp5300, nil
	case "idtechVp6300":
		return DeviceModelIdtechVp6300, nil
	case "idtechVp6800":
		return DeviceModelIdtechVp6800, nil
	case "ingenicoAxiumDx4000":
		return DeviceModelIngenicoAxiumDx4000, nil
	case "ingenicoAxiumDx8000":
		return DeviceModelIngenicoAxiumDx8000, nil
	case "ingenicoAxiumEx8000":
		return DeviceModelIngenicoAxiumEx8000, nil
	case "ingenicoIct220":
		return DeviceModelIngenicoIct220, nil
	case "ingenicoIpp320":
		return DeviceModelIngenicoIpp320, nil
	case "ingenicoIpp350":
		return DeviceModelIngenicoIpp350, nil
	case "ingenicoIuc285":
		return DeviceModelIngenicoIuc285, nil
	case "ingenicoL3000":
		return DeviceModelIngenicoL3000, nil
	case "ingenicoL7000":
		return DeviceModelIngenicoL7000, nil
	case "ingenicoS2000":
		return DeviceModelIngenicoS2000, nil
	case "ingenicoS3000":
		return DeviceModelIngenicoS3000, nil
	case "ingenicoS4000":
		return DeviceModelIngenicoS4000, nil
	case "ingenicoS5000":
		return DeviceModelIngenicoS5000, nil
	case "ingenicoS7000":
		return DeviceModelIngenicoS7000, nil
	case "paxA80":
		return DeviceModelPaxA80, nil
	case "paxA920":
		return DeviceModelPaxA920, nil
	case "paxA920Pro":
		return DeviceModelPaxA920Pro, nil
	case "paxE500":
		return DeviceModelPaxE500, nil
	case "paxE700":
		return DeviceModelPaxE700, nil
	case "paxE800":
		return DeviceModelPaxE800, nil
	case "paxIm30":
		return DeviceModelPaxIm30, nil
	case "uic680":
		return DeviceModelUic680, nil
	case "uicBezel8":
		return DeviceModelUicBezel8, nil
	}
	var t DeviceModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceModel) Ptr() *DeviceModel {
	return &d
}

// Object that contains information about the payment details in the customer’s digital wallet.
var (
	digitalWalletPayloadFieldAccountType     = big.NewInt(1 << 0)
	digitalWalletPayloadFieldServiceProvider = big.NewInt(1 << 1)
	digitalWalletPayloadFieldCardholderName  = big.NewInt(1 << 2)
	digitalWalletPayloadFieldEncryptedData   = big.NewInt(1 << 3)
)

type DigitalWalletPayload struct {
	// Indicates the customer’s account type.
	//
	// **Note:** Send a value for accountType only for bank account details.
	AccountType *DigitalWalletPayloadAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`
	// Provider of the digital wallet. Send one of the following values:
	// - `apple` - For more information about how to integrate with Apple Pay, go to [Apple Pay®](https://docs.payroc.com/guides/take-payments/apple-pay).
	// - `google` - For more information about how to integrate with google Pay, go to [Google Pay®](https://docs.payroc.com/guides/take-payments/google-pay).
	ServiceProvider DigitalWalletPayloadServiceProvider `json:"serviceProvider" url:"serviceProvider"`
	// Cardholder’s name.
	CardholderName *string `json:"cardholderName,omitempty" url:"cardholderName,omitempty"`
	// Encrypted data of the digital wallet.
	EncryptedData string `json:"encryptedData" url:"encryptedData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DigitalWalletPayload) GetAccountType() *DigitalWalletPayloadAccountType {
	if d == nil {
		return nil
	}
	return d.AccountType
}

func (d *DigitalWalletPayload) GetServiceProvider() DigitalWalletPayloadServiceProvider {
	if d == nil {
		return ""
	}
	return d.ServiceProvider
}

func (d *DigitalWalletPayload) GetCardholderName() *string {
	if d == nil {
		return nil
	}
	return d.CardholderName
}

func (d *DigitalWalletPayload) GetEncryptedData() string {
	if d == nil {
		return ""
	}
	return d.EncryptedData
}

func (d *DigitalWalletPayload) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DigitalWalletPayload) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DigitalWalletPayload) SetAccountType(accountType *DigitalWalletPayloadAccountType) {
	d.AccountType = accountType
	d.require(digitalWalletPayloadFieldAccountType)
}

// SetServiceProvider sets the ServiceProvider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DigitalWalletPayload) SetServiceProvider(serviceProvider DigitalWalletPayloadServiceProvider) {
	d.ServiceProvider = serviceProvider
	d.require(digitalWalletPayloadFieldServiceProvider)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DigitalWalletPayload) SetCardholderName(cardholderName *string) {
	d.CardholderName = cardholderName
	d.require(digitalWalletPayloadFieldCardholderName)
}

// SetEncryptedData sets the EncryptedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DigitalWalletPayload) SetEncryptedData(encryptedData string) {
	d.EncryptedData = encryptedData
	d.require(digitalWalletPayloadFieldEncryptedData)
}

func (d *DigitalWalletPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler DigitalWalletPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DigitalWalletPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DigitalWalletPayload) MarshalJSON() ([]byte, error) {
	type embed DigitalWalletPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DigitalWalletPayload) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Indicates the customer’s account type.
//
// **Note:** Send a value for accountType only for bank account details.
type DigitalWalletPayloadAccountType string

const (
	DigitalWalletPayloadAccountTypeChecking DigitalWalletPayloadAccountType = "checking"
	DigitalWalletPayloadAccountTypeSavings  DigitalWalletPayloadAccountType = "savings"
)

func NewDigitalWalletPayloadAccountTypeFromString(s string) (DigitalWalletPayloadAccountType, error) {
	switch s {
	case "checking":
		return DigitalWalletPayloadAccountTypeChecking, nil
	case "savings":
		return DigitalWalletPayloadAccountTypeSavings, nil
	}
	var t DigitalWalletPayloadAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DigitalWalletPayloadAccountType) Ptr() *DigitalWalletPayloadAccountType {
	return &d
}

// Provider of the digital wallet. Send one of the following values:
// - `apple` - For more information about how to integrate with Apple Pay, go to [Apple Pay®](https://docs.payroc.com/guides/take-payments/apple-pay).
// - `google` - For more information about how to integrate with google Pay, go to [Google Pay®](https://docs.payroc.com/guides/take-payments/google-pay).
type DigitalWalletPayloadServiceProvider string

const (
	DigitalWalletPayloadServiceProviderApple  DigitalWalletPayloadServiceProvider = "apple"
	DigitalWalletPayloadServiceProviderGoogle DigitalWalletPayloadServiceProvider = "google"
)

func NewDigitalWalletPayloadServiceProviderFromString(s string) (DigitalWalletPayloadServiceProvider, error) {
	switch s {
	case "apple":
		return DigitalWalletPayloadServiceProviderApple, nil
	case "google":
		return DigitalWalletPayloadServiceProviderGoogle, nil
	}
	var t DigitalWalletPayloadServiceProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DigitalWalletPayloadServiceProvider) Ptr() *DigitalWalletPayloadServiceProvider {
	return &d
}

// Object that contains information about the dispute.
var (
	disputeFieldDisputeId         = big.NewInt(1 << 0)
	disputeFieldDisputeType       = big.NewInt(1 << 1)
	disputeFieldCurrentStatus     = big.NewInt(1 << 2)
	disputeFieldCreatedDate       = big.NewInt(1 << 3)
	disputeFieldLastModifiedDate  = big.NewInt(1 << 4)
	disputeFieldReceivedDate      = big.NewInt(1 << 5)
	disputeFieldDescription       = big.NewInt(1 << 6)
	disputeFieldReferenceNumber   = big.NewInt(1 << 7)
	disputeFieldDisputeAmount     = big.NewInt(1 << 8)
	disputeFieldFeeAmount         = big.NewInt(1 << 9)
	disputeFieldFirstDispute      = big.NewInt(1 << 10)
	disputeFieldAuthorizationCode = big.NewInt(1 << 11)
	disputeFieldCurrency          = big.NewInt(1 << 12)
	disputeFieldCard              = big.NewInt(1 << 13)
	disputeFieldMerchant          = big.NewInt(1 << 14)
	disputeFieldTransaction       = big.NewInt(1 << 15)
)

type Dispute struct {
	// Unique identifier that we assigned to the dispute.
	DisputeId *int `json:"disputeId,omitempty" url:"disputeId,omitempty"`
	// Type of dispute.
	DisputeType *DisputeDisputeType `json:"disputeType,omitempty" url:"disputeType,omitempty"`
	// Object that contains information about the current status of the dispute.
	CurrentStatus *DisputeCurrentStatus `json:"currentStatus,omitempty" url:"currentStatus,omitempty"`
	// Date that we received the dispute. The format of this value is **YYYY-MM-DD**.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty" format:"date"`
	// Date that the dispute was last changed. The format of this value is **YYYY-MM-DD**.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty" format:"date"`
	// Date that the acquiring bank received the dispute. The format of this value is **YYYY-MM-DD**.
	ReceivedDate *time.Time `json:"receivedDate,omitempty" url:"receivedDate,omitempty" format:"date"`
	// Description of the dispute.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Reference number from the acquiring bank.
	ReferenceNumber *string `json:"referenceNumber,omitempty" url:"referenceNumber,omitempty"`
	// Dispute amount. We return the value in the currency's lowest denomination, for example, cents.
	DisputeAmount *int64 `json:"disputeAmount,omitempty" url:"disputeAmount,omitempty"`
	// Value of the fees for the dispute. We return the value in the currency's lowest denomination, for example, cents.
	FeeAmount *int64 `json:"feeAmount,omitempty" url:"feeAmount,omitempty"`
	// Indicates if this is the first dispute for the transaction.
	FirstDispute *bool `json:"firstDispute,omitempty" url:"firstDispute,omitempty"`
	// Authorization code of the transaction that the dispute is linked to.
	AuthorizationCode *string `json:"authorizationCode,omitempty" url:"authorizationCode,omitempty"`
	// Currency of the transaction that the dispute is linked to. The value for the currency follows the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) standard.
	Currency    *string             `json:"currency,omitempty" url:"currency,omitempty"`
	Card        *CardSummary        `json:"card,omitempty" url:"card,omitempty"`
	Merchant    *MerchantSummary    `json:"merchant,omitempty" url:"merchant,omitempty"`
	Transaction *TransactionSummary `json:"transaction,omitempty" url:"transaction,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *Dispute) GetDisputeId() *int {
	if d == nil {
		return nil
	}
	return d.DisputeId
}

func (d *Dispute) GetDisputeType() *DisputeDisputeType {
	if d == nil {
		return nil
	}
	return d.DisputeType
}

func (d *Dispute) GetCurrentStatus() *DisputeCurrentStatus {
	if d == nil {
		return nil
	}
	return d.CurrentStatus
}

func (d *Dispute) GetCreatedDate() *time.Time {
	if d == nil {
		return nil
	}
	return d.CreatedDate
}

func (d *Dispute) GetLastModifiedDate() *time.Time {
	if d == nil {
		return nil
	}
	return d.LastModifiedDate
}

func (d *Dispute) GetReceivedDate() *time.Time {
	if d == nil {
		return nil
	}
	return d.ReceivedDate
}

func (d *Dispute) GetDescription() *string {
	if d == nil {
		return nil
	}
	return d.Description
}

func (d *Dispute) GetReferenceNumber() *string {
	if d == nil {
		return nil
	}
	return d.ReferenceNumber
}

func (d *Dispute) GetDisputeAmount() *int64 {
	if d == nil {
		return nil
	}
	return d.DisputeAmount
}

func (d *Dispute) GetFeeAmount() *int64 {
	if d == nil {
		return nil
	}
	return d.FeeAmount
}

func (d *Dispute) GetFirstDispute() *bool {
	if d == nil {
		return nil
	}
	return d.FirstDispute
}

func (d *Dispute) GetAuthorizationCode() *string {
	if d == nil {
		return nil
	}
	return d.AuthorizationCode
}

func (d *Dispute) GetCurrency() *string {
	if d == nil {
		return nil
	}
	return d.Currency
}

func (d *Dispute) GetCard() *CardSummary {
	if d == nil {
		return nil
	}
	return d.Card
}

func (d *Dispute) GetMerchant() *MerchantSummary {
	if d == nil {
		return nil
	}
	return d.Merchant
}

func (d *Dispute) GetTransaction() *TransactionSummary {
	if d == nil {
		return nil
	}
	return d.Transaction
}

func (d *Dispute) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Dispute) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDisputeId sets the DisputeId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetDisputeId(disputeId *int) {
	d.DisputeId = disputeId
	d.require(disputeFieldDisputeId)
}

// SetDisputeType sets the DisputeType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetDisputeType(disputeType *DisputeDisputeType) {
	d.DisputeType = disputeType
	d.require(disputeFieldDisputeType)
}

// SetCurrentStatus sets the CurrentStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetCurrentStatus(currentStatus *DisputeCurrentStatus) {
	d.CurrentStatus = currentStatus
	d.require(disputeFieldCurrentStatus)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetCreatedDate(createdDate *time.Time) {
	d.CreatedDate = createdDate
	d.require(disputeFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetLastModifiedDate(lastModifiedDate *time.Time) {
	d.LastModifiedDate = lastModifiedDate
	d.require(disputeFieldLastModifiedDate)
}

// SetReceivedDate sets the ReceivedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetReceivedDate(receivedDate *time.Time) {
	d.ReceivedDate = receivedDate
	d.require(disputeFieldReceivedDate)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetDescription(description *string) {
	d.Description = description
	d.require(disputeFieldDescription)
}

// SetReferenceNumber sets the ReferenceNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetReferenceNumber(referenceNumber *string) {
	d.ReferenceNumber = referenceNumber
	d.require(disputeFieldReferenceNumber)
}

// SetDisputeAmount sets the DisputeAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetDisputeAmount(disputeAmount *int64) {
	d.DisputeAmount = disputeAmount
	d.require(disputeFieldDisputeAmount)
}

// SetFeeAmount sets the FeeAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetFeeAmount(feeAmount *int64) {
	d.FeeAmount = feeAmount
	d.require(disputeFieldFeeAmount)
}

// SetFirstDispute sets the FirstDispute field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetFirstDispute(firstDispute *bool) {
	d.FirstDispute = firstDispute
	d.require(disputeFieldFirstDispute)
}

// SetAuthorizationCode sets the AuthorizationCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetAuthorizationCode(authorizationCode *string) {
	d.AuthorizationCode = authorizationCode
	d.require(disputeFieldAuthorizationCode)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetCurrency(currency *string) {
	d.Currency = currency
	d.require(disputeFieldCurrency)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetCard(card *CardSummary) {
	d.Card = card
	d.require(disputeFieldCard)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetMerchant(merchant *MerchantSummary) {
	d.Merchant = merchant
	d.require(disputeFieldMerchant)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *Dispute) SetTransaction(transaction *TransactionSummary) {
	d.Transaction = transaction
	d.require(disputeFieldTransaction)
}

func (d *Dispute) UnmarshalJSON(data []byte) error {
	type embed Dispute
	var unmarshaler = struct {
		embed
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
		ReceivedDate     *internal.Date `json:"receivedDate,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Dispute(unmarshaler.embed)
	d.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	d.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	d.ReceivedDate = unmarshaler.ReceivedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dispute) MarshalJSON() ([]byte, error) {
	type embed Dispute
	var marshaler = struct {
		embed
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
		ReceivedDate     *internal.Date `json:"receivedDate,omitempty"`
	}{
		embed:            embed(*d),
		CreatedDate:      internal.NewOptionalDate(d.CreatedDate),
		LastModifiedDate: internal.NewOptionalDate(d.LastModifiedDate),
		ReceivedDate:     internal.NewOptionalDate(d.ReceivedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *Dispute) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Object that contains information about the current status of the dispute.
var (
	disputeCurrentStatusFieldDisputeStatusId = big.NewInt(1 << 0)
	disputeCurrentStatusFieldStatus          = big.NewInt(1 << 1)
	disputeCurrentStatusFieldStatusDate      = big.NewInt(1 << 2)
	disputeCurrentStatusFieldLink            = big.NewInt(1 << 3)
)

type DisputeCurrentStatus struct {
	// Unique identifier that we assigned to the status of the dispute.
	DisputeStatusId *int `json:"disputeStatusId,omitempty" url:"disputeStatusId,omitempty"`
	// Status of the dispute.
	//
	// **Note:** If you want to view the status history of the dispute, use our [List Dispute Statuses](https://docs.payroc.com/api/schema/reporting/settlement/list-disputes-statuses) method.
	Status *DisputeStatusStatus `json:"status,omitempty" url:"status,omitempty"`
	// Date that the status of the dispute was last changed. The format of this value is **YYYY-MM-DD**.
	StatusDate *time.Time `json:"statusDate,omitempty" url:"statusDate,omitempty" format:"date"`
	Link       *Link      `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeCurrentStatus) GetDisputeStatusId() *int {
	if d == nil {
		return nil
	}
	return d.DisputeStatusId
}

func (d *DisputeCurrentStatus) GetStatus() *DisputeStatusStatus {
	if d == nil {
		return nil
	}
	return d.Status
}

func (d *DisputeCurrentStatus) GetStatusDate() *time.Time {
	if d == nil {
		return nil
	}
	return d.StatusDate
}

func (d *DisputeCurrentStatus) GetLink() *Link {
	if d == nil {
		return nil
	}
	return d.Link
}

func (d *DisputeCurrentStatus) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeCurrentStatus) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDisputeStatusId sets the DisputeStatusId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DisputeCurrentStatus) SetDisputeStatusId(disputeStatusId *int) {
	d.DisputeStatusId = disputeStatusId
	d.require(disputeCurrentStatusFieldDisputeStatusId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DisputeCurrentStatus) SetStatus(status *DisputeStatusStatus) {
	d.Status = status
	d.require(disputeCurrentStatusFieldStatus)
}

// SetStatusDate sets the StatusDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DisputeCurrentStatus) SetStatusDate(statusDate *time.Time) {
	d.StatusDate = statusDate
	d.require(disputeCurrentStatusFieldStatusDate)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DisputeCurrentStatus) SetLink(link *Link) {
	d.Link = link
	d.require(disputeCurrentStatusFieldLink)
}

func (d *DisputeCurrentStatus) UnmarshalJSON(data []byte) error {
	type embed DisputeCurrentStatus
	var unmarshaler = struct {
		embed
		StatusDate *internal.Date `json:"statusDate,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DisputeCurrentStatus(unmarshaler.embed)
	d.StatusDate = unmarshaler.StatusDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeCurrentStatus) MarshalJSON() ([]byte, error) {
	type embed DisputeCurrentStatus
	var marshaler = struct {
		embed
		StatusDate *internal.Date `json:"statusDate,omitempty"`
	}{
		embed:      embed(*d),
		StatusDate: internal.NewOptionalDate(d.StatusDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DisputeCurrentStatus) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Type of dispute.
type DisputeDisputeType string

const (
	DisputeDisputeTypePrearbitration           DisputeDisputeType = "prearbitration"
	DisputeDisputeTypeIssuerReversal           DisputeDisputeType = "issuerReversal"
	DisputeDisputeTypeFirstDisputeWithReversal DisputeDisputeType = "firstDisputeWithReversal"
	DisputeDisputeTypeFirstDispute             DisputeDisputeType = "firstDispute"
)

func NewDisputeDisputeTypeFromString(s string) (DisputeDisputeType, error) {
	switch s {
	case "prearbitration":
		return DisputeDisputeTypePrearbitration, nil
	case "issuerReversal":
		return DisputeDisputeTypeIssuerReversal, nil
	case "firstDisputeWithReversal":
		return DisputeDisputeTypeFirstDisputeWithReversal, nil
	case "firstDispute":
		return DisputeDisputeTypeFirstDispute, nil
	}
	var t DisputeDisputeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DisputeDisputeType) Ptr() *DisputeDisputeType {
	return &d
}

// Object that contains information about the current status of the dispute.
var (
	disputeStatusFieldDisputeStatusId = big.NewInt(1 << 0)
	disputeStatusFieldStatus          = big.NewInt(1 << 1)
	disputeStatusFieldStatusDate      = big.NewInt(1 << 2)
)

type DisputeStatus struct {
	// Unique identifier that we assigned to the status of the dispute.
	DisputeStatusId *int `json:"disputeStatusId,omitempty" url:"disputeStatusId,omitempty"`
	// Status of the dispute.
	//
	// **Note:** If you want to view the status history of the dispute, use our [List Dispute Statuses](https://docs.payroc.com/api/schema/reporting/settlement/list-disputes-statuses) method.
	Status *DisputeStatusStatus `json:"status,omitempty" url:"status,omitempty"`
	// Date that the status of the dispute was last changed. The format of this value is **YYYY-MM-DD**.
	StatusDate *time.Time `json:"statusDate,omitempty" url:"statusDate,omitempty" format:"date"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeStatus) GetDisputeStatusId() *int {
	if d == nil {
		return nil
	}
	return d.DisputeStatusId
}

func (d *DisputeStatus) GetStatus() *DisputeStatusStatus {
	if d == nil {
		return nil
	}
	return d.Status
}

func (d *DisputeStatus) GetStatusDate() *time.Time {
	if d == nil {
		return nil
	}
	return d.StatusDate
}

func (d *DisputeStatus) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStatus) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetDisputeStatusId sets the DisputeStatusId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DisputeStatus) SetDisputeStatusId(disputeStatusId *int) {
	d.DisputeStatusId = disputeStatusId
	d.require(disputeStatusFieldDisputeStatusId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DisputeStatus) SetStatus(status *DisputeStatusStatus) {
	d.Status = status
	d.require(disputeStatusFieldStatus)
}

// SetStatusDate sets the StatusDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DisputeStatus) SetStatusDate(statusDate *time.Time) {
	d.StatusDate = statusDate
	d.require(disputeStatusFieldStatusDate)
}

func (d *DisputeStatus) UnmarshalJSON(data []byte) error {
	type embed DisputeStatus
	var unmarshaler = struct {
		embed
		StatusDate *internal.Date `json:"statusDate,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DisputeStatus(unmarshaler.embed)
	d.StatusDate = unmarshaler.StatusDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStatus) MarshalJSON() ([]byte, error) {
	type embed DisputeStatus
	var marshaler = struct {
		embed
		StatusDate *internal.Date `json:"statusDate,omitempty"`
	}{
		embed:      embed(*d),
		StatusDate: internal.NewOptionalDate(d.StatusDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DisputeStatus) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Status of the dispute.
//
// **Note:** If you want to view the status history of the dispute, use our [List Dispute Statuses](https://docs.payroc.com/api/schema/reporting/settlement/list-disputes-statuses) method.
type DisputeStatusStatus string

const (
	DisputeStatusStatusPrearbitrationInProcess         DisputeStatusStatus = "prearbitrationInProcess"
	DisputeStatusStatusPrearbitrationAccepted          DisputeStatusStatus = "prearbitrationAccepted"
	DisputeStatusStatusPrearbitrationDeclined          DisputeStatusStatus = "prearbitrationDeclined"
	DisputeStatusStatusArbitrationFiledWithCardBand    DisputeStatusStatus = "arbitrationFiledWithCardBand"
	DisputeStatusStatusArbitrationFundsToBeReturned    DisputeStatusStatus = "arbitrationFundsToBeReturned"
	DisputeStatusStatusArbitrationLost                 DisputeStatusStatus = "arbitrationLost"
	DisputeStatusStatusArbitrationSettledPartialAmount DisputeStatusStatus = "arbitrationSettledPartialAmount"
	DisputeStatusStatusPrecomplianceInProcess          DisputeStatusStatus = "precomplianceInProcess"
	DisputeStatusStatusPrecomplianceAccepted           DisputeStatusStatus = "precomplianceAccepted"
	DisputeStatusStatusPrecomplianceDeclined           DisputeStatusStatus = "precomplianceDeclined"
	DisputeStatusStatusComplianceFiledWithCardBand     DisputeStatusStatus = "complianceFiledWithCardBand"
	DisputeStatusStatusComplianceLost                  DisputeStatusStatus = "complianceLost"
	DisputeStatusStatusComplianceSettledPartialAmount  DisputeStatusStatus = "complianceSettledPartialAmount"
	DisputeStatusStatusInvalid                         DisputeStatusStatus = "invalid"
	DisputeStatusStatusIssuerReversal                  DisputeStatusStatus = "issuerReversal"
	DisputeStatusStatusNew                             DisputeStatusStatus = "new"
	DisputeStatusStatusRejected                        DisputeStatusStatus = "rejected"
	DisputeStatusStatusRepresentmentInProgress         DisputeStatusStatus = "representmentInProgress"
	DisputeStatusStatusRepresentmentFailed             DisputeStatusStatus = "representmentFailed"
	DisputeStatusStatusRepresentmentPaid               DisputeStatusStatus = "representmentPaid"
	DisputeStatusStatusRepresentmentReceived           DisputeStatusStatus = "representmentReceived"
	DisputeStatusStatusStand                           DisputeStatusStatus = "stand"
)

func NewDisputeStatusStatusFromString(s string) (DisputeStatusStatus, error) {
	switch s {
	case "prearbitrationInProcess":
		return DisputeStatusStatusPrearbitrationInProcess, nil
	case "prearbitrationAccepted":
		return DisputeStatusStatusPrearbitrationAccepted, nil
	case "prearbitrationDeclined":
		return DisputeStatusStatusPrearbitrationDeclined, nil
	case "arbitrationFiledWithCardBand":
		return DisputeStatusStatusArbitrationFiledWithCardBand, nil
	case "arbitrationFundsToBeReturned":
		return DisputeStatusStatusArbitrationFundsToBeReturned, nil
	case "arbitrationLost":
		return DisputeStatusStatusArbitrationLost, nil
	case "arbitrationSettledPartialAmount":
		return DisputeStatusStatusArbitrationSettledPartialAmount, nil
	case "precomplianceInProcess":
		return DisputeStatusStatusPrecomplianceInProcess, nil
	case "precomplianceAccepted":
		return DisputeStatusStatusPrecomplianceAccepted, nil
	case "precomplianceDeclined":
		return DisputeStatusStatusPrecomplianceDeclined, nil
	case "complianceFiledWithCardBand":
		return DisputeStatusStatusComplianceFiledWithCardBand, nil
	case "complianceLost":
		return DisputeStatusStatusComplianceLost, nil
	case "complianceSettledPartialAmount":
		return DisputeStatusStatusComplianceSettledPartialAmount, nil
	case "invalid":
		return DisputeStatusStatusInvalid, nil
	case "issuerReversal":
		return DisputeStatusStatusIssuerReversal, nil
	case "new":
		return DisputeStatusStatusNew, nil
	case "rejected":
		return DisputeStatusStatusRejected, nil
	case "representmentInProgress":
		return DisputeStatusStatusRepresentmentInProgress, nil
	case "representmentFailed":
		return DisputeStatusStatusRepresentmentFailed, nil
	case "representmentPaid":
		return DisputeStatusStatusRepresentmentPaid, nil
	case "representmentReceived":
		return DisputeStatusStatusRepresentmentReceived, nil
	case "stand":
		return DisputeStatusStatusStand, nil
	}
	var t DisputeStatusStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DisputeStatusStatus) Ptr() *DisputeStatusStatus {
	return &d
}

// Object that contains information about dual pricing.
var (
	dualPricingFieldOffered           = big.NewInt(1 << 0)
	dualPricingFieldChoiceRate        = big.NewInt(1 << 1)
	dualPricingFieldAlternativeTender = big.NewInt(1 << 2)
)

type DualPricing struct {
	// Indicates if the merchant offered dual pricing to the customer.
	Offered bool `json:"offered" url:"offered"`
	// Object that contains information about the choice rate.
	// **Note:** For requests, if the value for **offered** is `true`, you must send this object in the request.
	ChoiceRate *ChoiceRate `json:"choiceRate,omitempty" url:"choiceRate,omitempty"`
	// Payment method that the merchant presented to the customer as an alternative to their chosen method.
	// **Note:** For requests, if the value for **offered** is `true`, you must send a value for **alternativeTender** in the request.
	AlternativeTender *DualPricingAlternativeTender `json:"alternativeTender,omitempty" url:"alternativeTender,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DualPricing) GetOffered() bool {
	if d == nil {
		return false
	}
	return d.Offered
}

func (d *DualPricing) GetChoiceRate() *ChoiceRate {
	if d == nil {
		return nil
	}
	return d.ChoiceRate
}

func (d *DualPricing) GetAlternativeTender() *DualPricingAlternativeTender {
	if d == nil {
		return nil
	}
	return d.AlternativeTender
}

func (d *DualPricing) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DualPricing) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetOffered sets the Offered field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DualPricing) SetOffered(offered bool) {
	d.Offered = offered
	d.require(dualPricingFieldOffered)
}

// SetChoiceRate sets the ChoiceRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DualPricing) SetChoiceRate(choiceRate *ChoiceRate) {
	d.ChoiceRate = choiceRate
	d.require(dualPricingFieldChoiceRate)
}

// SetAlternativeTender sets the AlternativeTender field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DualPricing) SetAlternativeTender(alternativeTender *DualPricingAlternativeTender) {
	d.AlternativeTender = alternativeTender
	d.require(dualPricingFieldAlternativeTender)
}

func (d *DualPricing) UnmarshalJSON(data []byte) error {
	type unmarshaler DualPricing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DualPricing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DualPricing) MarshalJSON() ([]byte, error) {
	type embed DualPricing
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DualPricing) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Payment method that the merchant presented to the customer as an alternative to their chosen method.
// **Note:** For requests, if the value for **offered** is `true`, you must send a value for **alternativeTender** in the request.
type DualPricingAlternativeTender string

const (
	DualPricingAlternativeTenderCard         DualPricingAlternativeTender = "card"
	DualPricingAlternativeTenderCash         DualPricingAlternativeTender = "cash"
	DualPricingAlternativeTenderBankTransfer DualPricingAlternativeTender = "bankTransfer"
)

func NewDualPricingAlternativeTenderFromString(s string) (DualPricingAlternativeTender, error) {
	switch s {
	case "card":
		return DualPricingAlternativeTenderCard, nil
	case "cash":
		return DualPricingAlternativeTenderCash, nil
	case "bankTransfer":
		return DualPricingAlternativeTenderBankTransfer, nil
	}
	var t DualPricingAlternativeTender
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DualPricingAlternativeTender) Ptr() *DualPricingAlternativeTender {
	return &d
}

// Object that contains information about encrypted PIN details.
var (
	dukptPinDetailsFieldPin    = big.NewInt(1 << 0)
	dukptPinDetailsFieldPinKsn = big.NewInt(1 << 1)
)

type DukptPinDetails struct {
	// Encrypted PIN.
	// **Note:** PIN is encrypted using the DUKPT scheme.
	Pin string `json:"pin" url:"pin"`
	// Key serial number.
	PinKsn string `json:"pinKsn" url:"pinKsn"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DukptPinDetails) GetPin() string {
	if d == nil {
		return ""
	}
	return d.Pin
}

func (d *DukptPinDetails) GetPinKsn() string {
	if d == nil {
		return ""
	}
	return d.PinKsn
}

func (d *DukptPinDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DukptPinDetails) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetPin sets the Pin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DukptPinDetails) SetPin(pin string) {
	d.Pin = pin
	d.require(dukptPinDetailsFieldPin)
}

// SetPinKsn sets the PinKsn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DukptPinDetails) SetPinKsn(pinKsn string) {
	d.PinKsn = pinKsn
	d.require(dukptPinDetailsFieldPinKsn)
}

func (d *DukptPinDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DukptPinDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DukptPinDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DukptPinDetails) MarshalJSON() ([]byte, error) {
	type embed DukptPinDetails
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DukptPinDetails) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Object that contains information about the Electronic Benefit Transfer (EBT) transaction.
var (
	ebtDetailsFieldBenefitCategory = big.NewInt(1 << 0)
	ebtDetailsFieldWithdrawal      = big.NewInt(1 << 1)
)

type EbtDetails struct {
	// Indicates if the balance relates to an EBT Cash account or an EBT SNAP account.
	//   - `cash` – EBT Cash
	//   - `foodStamp` – EBT SNAP
	BenefitCategory EbtDetailsBenefitCategory `json:"benefitCategory" url:"benefitCategory"`
	// Indicates whether the customer wants to withdraw cash.
	//
	// **Note:** Cash withdrawals are available only from EBT Cash accounts.
	Withdrawal *bool `json:"withdrawal,omitempty" url:"withdrawal,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EbtDetails) GetBenefitCategory() EbtDetailsBenefitCategory {
	if e == nil {
		return ""
	}
	return e.BenefitCategory
}

func (e *EbtDetails) GetWithdrawal() *bool {
	if e == nil {
		return nil
	}
	return e.Withdrawal
}

func (e *EbtDetails) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EbtDetails) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetBenefitCategory sets the BenefitCategory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtDetails) SetBenefitCategory(benefitCategory EbtDetailsBenefitCategory) {
	e.BenefitCategory = benefitCategory
	e.require(ebtDetailsFieldBenefitCategory)
}

// SetWithdrawal sets the Withdrawal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtDetails) SetWithdrawal(withdrawal *bool) {
	e.Withdrawal = withdrawal
	e.require(ebtDetailsFieldWithdrawal)
}

func (e *EbtDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler EbtDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EbtDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EbtDetails) MarshalJSON() ([]byte, error) {
	type embed EbtDetails
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EbtDetails) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates if the balance relates to an EBT Cash account or an EBT SNAP account.
//   - `cash` – EBT Cash
//   - `foodStamp` – EBT SNAP
type EbtDetailsBenefitCategory string

const (
	EbtDetailsBenefitCategoryCash      EbtDetailsBenefitCategory = "cash"
	EbtDetailsBenefitCategoryFoodStamp EbtDetailsBenefitCategory = "foodStamp"
)

func NewEbtDetailsBenefitCategoryFromString(s string) (EbtDetailsBenefitCategory, error) {
	switch s {
	case "cash":
		return EbtDetailsBenefitCategoryCash, nil
	case "foodStamp":
		return EbtDetailsBenefitCategoryFoodStamp, nil
	}
	var t EbtDetailsBenefitCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EbtDetailsBenefitCategory) Ptr() *EbtDetailsBenefitCategory {
	return &e
}

// Object that contains information about the Electronic Benefit Transfer (EBT) transaction.
var (
	ebtDetailsWithVoucherFieldBenefitCategory = big.NewInt(1 << 0)
	ebtDetailsWithVoucherFieldWithdrawal      = big.NewInt(1 << 1)
	ebtDetailsWithVoucherFieldVoucher         = big.NewInt(1 << 2)
)

type EbtDetailsWithVoucher struct {
	// Indicates if the balance relates to an EBT Cash account or an EBT SNAP account.
	//   - `cash` – EBT Cash
	//   - `foodStamp` – EBT SNAP
	BenefitCategory EbtDetailsBenefitCategory `json:"benefitCategory" url:"benefitCategory"`
	// Indicates whether the customer wants to withdraw cash.
	//
	// **Note:** Cash withdrawals are available only from EBT Cash accounts.
	Withdrawal *bool    `json:"withdrawal,omitempty" url:"withdrawal,omitempty"`
	Voucher    *Voucher `json:"voucher,omitempty" url:"voucher,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EbtDetailsWithVoucher) GetBenefitCategory() EbtDetailsBenefitCategory {
	if e == nil {
		return ""
	}
	return e.BenefitCategory
}

func (e *EbtDetailsWithVoucher) GetWithdrawal() *bool {
	if e == nil {
		return nil
	}
	return e.Withdrawal
}

func (e *EbtDetailsWithVoucher) GetVoucher() *Voucher {
	if e == nil {
		return nil
	}
	return e.Voucher
}

func (e *EbtDetailsWithVoucher) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EbtDetailsWithVoucher) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetBenefitCategory sets the BenefitCategory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtDetailsWithVoucher) SetBenefitCategory(benefitCategory EbtDetailsBenefitCategory) {
	e.BenefitCategory = benefitCategory
	e.require(ebtDetailsWithVoucherFieldBenefitCategory)
}

// SetWithdrawal sets the Withdrawal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtDetailsWithVoucher) SetWithdrawal(withdrawal *bool) {
	e.Withdrawal = withdrawal
	e.require(ebtDetailsWithVoucherFieldWithdrawal)
}

// SetVoucher sets the Voucher field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtDetailsWithVoucher) SetVoucher(voucher *Voucher) {
	e.Voucher = voucher
	e.require(ebtDetailsWithVoucherFieldVoucher)
}

func (e *EbtDetailsWithVoucher) UnmarshalJSON(data []byte) error {
	type unmarshaler EbtDetailsWithVoucher
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EbtDetailsWithVoucher(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EbtDetailsWithVoucher) MarshalJSON() ([]byte, error) {
	type embed EbtDetailsWithVoucher
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EbtDetailsWithVoucher) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Object that contains details about EBT transactions.
var (
	ebtDisabledFieldEnabled = big.NewInt(1 << 0)
)

type EbtDisabled struct {
	// Indicates if the terminal accepts Electronic Benefit Transfer (EBT) transactions.
	Enabled bool `json:"enabled" url:"enabled"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EbtDisabled) GetEnabled() bool {
	if e == nil {
		return false
	}
	return e.Enabled
}

func (e *EbtDisabled) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EbtDisabled) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtDisabled) SetEnabled(enabled bool) {
	e.Enabled = enabled
	e.require(ebtDisabledFieldEnabled)
}

func (e *EbtDisabled) UnmarshalJSON(data []byte) error {
	type unmarshaler EbtDisabled
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EbtDisabled(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EbtDisabled) MarshalJSON() ([]byte, error) {
	type embed EbtDisabled
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EbtDisabled) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Object that contains details about EBT transactions.
var (
	ebtEnabledFieldEnabled   = big.NewInt(1 << 0)
	ebtEnabledFieldEbtType   = big.NewInt(1 << 1)
	ebtEnabledFieldFnsNumber = big.NewInt(1 << 2)
)

type EbtEnabled struct {
	// Indicates if the terminal accepts Electronic Benefit Transfer (EBT) transactions.
	Enabled bool `json:"enabled" url:"enabled"`
	// Indicates the type of EBT that the terminal supports.
	EbtType EbtEnabledEbtType `json:"ebtType" url:"ebtType"`
	// Food and Nutritional Service (FNS) number that the government assigns to the merchant to allow them to accept Supplemental Nutrition Assistance Program (SNAP) transactions.
	FnsNumber *string `json:"fnsNumber,omitempty" url:"fnsNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EbtEnabled) GetEnabled() bool {
	if e == nil {
		return false
	}
	return e.Enabled
}

func (e *EbtEnabled) GetEbtType() EbtEnabledEbtType {
	if e == nil {
		return ""
	}
	return e.EbtType
}

func (e *EbtEnabled) GetFnsNumber() *string {
	if e == nil {
		return nil
	}
	return e.FnsNumber
}

func (e *EbtEnabled) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EbtEnabled) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtEnabled) SetEnabled(enabled bool) {
	e.Enabled = enabled
	e.require(ebtEnabledFieldEnabled)
}

// SetEbtType sets the EbtType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtEnabled) SetEbtType(ebtType EbtEnabledEbtType) {
	e.EbtType = ebtType
	e.require(ebtEnabledFieldEbtType)
}

// SetFnsNumber sets the FnsNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EbtEnabled) SetFnsNumber(fnsNumber *string) {
	e.FnsNumber = fnsNumber
	e.require(ebtEnabledFieldFnsNumber)
}

func (e *EbtEnabled) UnmarshalJSON(data []byte) error {
	type unmarshaler EbtEnabled
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EbtEnabled(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EbtEnabled) MarshalJSON() ([]byte, error) {
	type embed EbtEnabled
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EbtEnabled) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates the type of EBT that the terminal supports.
type EbtEnabledEbtType string

const (
	EbtEnabledEbtTypeFoodStamp EbtEnabledEbtType = "foodStamp"
	EbtEnabledEbtTypeCash      EbtEnabledEbtType = "cash"
	EbtEnabledEbtTypeBoth      EbtEnabledEbtType = "both"
)

func NewEbtEnabledEbtTypeFromString(s string) (EbtEnabledEbtType, error) {
	switch s {
	case "foodStamp":
		return EbtEnabledEbtTypeFoodStamp, nil
	case "cash":
		return EbtEnabledEbtTypeCash, nil
	case "both":
		return EbtEnabledEbtTypeBoth, nil
	}
	var t EbtEnabledEbtType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EbtEnabledEbtType) Ptr() *EbtEnabledEbtType {
	return &e
}

// Object that contains the fees for EBT transactions.
var (
	electronicBenefitsTransferFieldTransaction = big.NewInt(1 << 0)
)

type ElectronicBenefitsTransfer struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ElectronicBenefitsTransfer) GetTransaction() Amount {
	if e == nil {
		return 0
	}
	return e.Transaction
}

func (e *ElectronicBenefitsTransfer) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ElectronicBenefitsTransfer) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ElectronicBenefitsTransfer) SetTransaction(transaction Amount) {
	e.Transaction = transaction
	e.require(electronicBenefitsTransferFieldTransaction)
}

func (e *ElectronicBenefitsTransfer) UnmarshalJSON(data []byte) error {
	type unmarshaler ElectronicBenefitsTransfer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ElectronicBenefitsTransfer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ElectronicBenefitsTransfer) MarshalJSON() ([]byte, error) {
	type embed ElectronicBenefitsTransfer
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ElectronicBenefitsTransfer) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Object that contains information about the EMV tag.
var (
	emvTagFieldHex   = big.NewInt(1 << 0)
	emvTagFieldValue = big.NewInt(1 << 1)
)

type EmvTag struct {
	// Hex code of the EMV tag.
	Hex string `json:"hex" url:"hex"`
	// Value of the EMV tag.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmvTag) GetHex() string {
	if e == nil {
		return ""
	}
	return e.Hex
}

func (e *EmvTag) GetValue() string {
	if e == nil {
		return ""
	}
	return e.Value
}

func (e *EmvTag) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmvTag) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetHex sets the Hex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EmvTag) SetHex(hex string) {
	e.Hex = hex
	e.require(emvTagFieldHex)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EmvTag) SetValue(value string) {
	e.Value = value
	e.require(emvTagFieldValue)
}

func (e *EmvTag) UnmarshalJSON(data []byte) error {
	type unmarshaler EmvTag
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmvTag(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmvTag) MarshalJSON() ([]byte, error) {
	type embed EmvTag
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EmvTag) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Object that contains information about the encrypted swiped card data.
var (
	encryptedSwipedDataFormatFieldDevice          = big.NewInt(1 << 0)
	encryptedSwipedDataFormatFieldEncryptedData   = big.NewInt(1 << 1)
	encryptedSwipedDataFormatFieldFirstDigitOfPan = big.NewInt(1 << 2)
	encryptedSwipedDataFormatFieldFallback        = big.NewInt(1 << 3)
	encryptedSwipedDataFormatFieldFallbackReason  = big.NewInt(1 << 4)
)

type EncryptedSwipedDataFormat struct {
	Device *EncryptionCapableDevice `json:"device" url:"device"`
	// Encrypted data received from the magnetic stripe reader.
	EncryptedData string `json:"encryptedData" url:"encryptedData"`
	// First digit of the of the card number.
	FirstDigitOfPan *string `json:"firstDigitOfPan,omitempty" url:"firstDigitOfPan,omitempty"`
	// Indicates that this is a fallback transaction. For example, if there was a technical issue with the chip on the customer's card and the merchant then swiped the card.
	Fallback *bool `json:"fallback,omitempty" url:"fallback,omitempty"`
	// Reason for the fallback.
	FallbackReason *EncryptedSwipedDataFormatFallbackReason `json:"fallbackReason,omitempty" url:"fallbackReason,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EncryptedSwipedDataFormat) GetDevice() *EncryptionCapableDevice {
	if e == nil {
		return nil
	}
	return e.Device
}

func (e *EncryptedSwipedDataFormat) GetEncryptedData() string {
	if e == nil {
		return ""
	}
	return e.EncryptedData
}

func (e *EncryptedSwipedDataFormat) GetFirstDigitOfPan() *string {
	if e == nil {
		return nil
	}
	return e.FirstDigitOfPan
}

func (e *EncryptedSwipedDataFormat) GetFallback() *bool {
	if e == nil {
		return nil
	}
	return e.Fallback
}

func (e *EncryptedSwipedDataFormat) GetFallbackReason() *EncryptedSwipedDataFormatFallbackReason {
	if e == nil {
		return nil
	}
	return e.FallbackReason
}

func (e *EncryptedSwipedDataFormat) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EncryptedSwipedDataFormat) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptedSwipedDataFormat) SetDevice(device *EncryptionCapableDevice) {
	e.Device = device
	e.require(encryptedSwipedDataFormatFieldDevice)
}

// SetEncryptedData sets the EncryptedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptedSwipedDataFormat) SetEncryptedData(encryptedData string) {
	e.EncryptedData = encryptedData
	e.require(encryptedSwipedDataFormatFieldEncryptedData)
}

// SetFirstDigitOfPan sets the FirstDigitOfPan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptedSwipedDataFormat) SetFirstDigitOfPan(firstDigitOfPan *string) {
	e.FirstDigitOfPan = firstDigitOfPan
	e.require(encryptedSwipedDataFormatFieldFirstDigitOfPan)
}

// SetFallback sets the Fallback field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptedSwipedDataFormat) SetFallback(fallback *bool) {
	e.Fallback = fallback
	e.require(encryptedSwipedDataFormatFieldFallback)
}

// SetFallbackReason sets the FallbackReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptedSwipedDataFormat) SetFallbackReason(fallbackReason *EncryptedSwipedDataFormatFallbackReason) {
	e.FallbackReason = fallbackReason
	e.require(encryptedSwipedDataFormatFieldFallbackReason)
}

func (e *EncryptedSwipedDataFormat) UnmarshalJSON(data []byte) error {
	type unmarshaler EncryptedSwipedDataFormat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EncryptedSwipedDataFormat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EncryptedSwipedDataFormat) MarshalJSON() ([]byte, error) {
	type embed EncryptedSwipedDataFormat
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EncryptedSwipedDataFormat) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Reason for the fallback.
type EncryptedSwipedDataFormatFallbackReason string

const (
	EncryptedSwipedDataFormatFallbackReasonTechnical          EncryptedSwipedDataFormatFallbackReason = "technical"
	EncryptedSwipedDataFormatFallbackReasonRepeatFallback     EncryptedSwipedDataFormatFallbackReason = "repeatFallback"
	EncryptedSwipedDataFormatFallbackReasonEmptyCandidateList EncryptedSwipedDataFormatFallbackReason = "emptyCandidateList"
)

func NewEncryptedSwipedDataFormatFallbackReasonFromString(s string) (EncryptedSwipedDataFormatFallbackReason, error) {
	switch s {
	case "technical":
		return EncryptedSwipedDataFormatFallbackReasonTechnical, nil
	case "repeatFallback":
		return EncryptedSwipedDataFormatFallbackReasonRepeatFallback, nil
	case "emptyCandidateList":
		return EncryptedSwipedDataFormatFallbackReasonEmptyCandidateList, nil
	}
	var t EncryptedSwipedDataFormatFallbackReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EncryptedSwipedDataFormatFallbackReason) Ptr() *EncryptedSwipedDataFormatFallbackReason {
	return &e
}

// Object that contains information about the encryption details of the POS terminal.
var (
	encryptionCapableDeviceFieldModel           = big.NewInt(1 << 0)
	encryptionCapableDeviceFieldCategory        = big.NewInt(1 << 1)
	encryptionCapableDeviceFieldSerialNumber    = big.NewInt(1 << 2)
	encryptionCapableDeviceFieldFirmwareVersion = big.NewInt(1 << 3)
	encryptionCapableDeviceFieldConfig          = big.NewInt(1 << 4)
	encryptionCapableDeviceFieldDataKsn         = big.NewInt(1 << 5)
)

type EncryptionCapableDevice struct {
	// Model of the device that the merchant used to process the transaction.
	Model DeviceModel `json:"model" url:"model"`
	// Indicates if the device is attended or unattended.
	Category *DeviceCategory `json:"category,omitempty" url:"category,omitempty"`
	// Serial number of the physical device.
	SerialNumber string `json:"serialNumber" url:"serialNumber"`
	// Firmware version of the physical device.
	FirmwareVersion *string       `json:"firmwareVersion,omitempty" url:"firmwareVersion,omitempty"`
	Config          *DeviceConfig `json:"config,omitempty" url:"config,omitempty"`
	// Key serial number.
	DataKsn *string `json:"dataKsn,omitempty" url:"dataKsn,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EncryptionCapableDevice) GetModel() DeviceModel {
	if e == nil {
		return ""
	}
	return e.Model
}

func (e *EncryptionCapableDevice) GetCategory() *DeviceCategory {
	if e == nil {
		return nil
	}
	return e.Category
}

func (e *EncryptionCapableDevice) GetSerialNumber() string {
	if e == nil {
		return ""
	}
	return e.SerialNumber
}

func (e *EncryptionCapableDevice) GetFirmwareVersion() *string {
	if e == nil {
		return nil
	}
	return e.FirmwareVersion
}

func (e *EncryptionCapableDevice) GetConfig() *DeviceConfig {
	if e == nil {
		return nil
	}
	return e.Config
}

func (e *EncryptionCapableDevice) GetDataKsn() *string {
	if e == nil {
		return nil
	}
	return e.DataKsn
}

func (e *EncryptionCapableDevice) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EncryptionCapableDevice) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptionCapableDevice) SetModel(model DeviceModel) {
	e.Model = model
	e.require(encryptionCapableDeviceFieldModel)
}

// SetCategory sets the Category field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptionCapableDevice) SetCategory(category *DeviceCategory) {
	e.Category = category
	e.require(encryptionCapableDeviceFieldCategory)
}

// SetSerialNumber sets the SerialNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptionCapableDevice) SetSerialNumber(serialNumber string) {
	e.SerialNumber = serialNumber
	e.require(encryptionCapableDeviceFieldSerialNumber)
}

// SetFirmwareVersion sets the FirmwareVersion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptionCapableDevice) SetFirmwareVersion(firmwareVersion *string) {
	e.FirmwareVersion = firmwareVersion
	e.require(encryptionCapableDeviceFieldFirmwareVersion)
}

// SetConfig sets the Config field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptionCapableDevice) SetConfig(config *DeviceConfig) {
	e.Config = config
	e.require(encryptionCapableDeviceFieldConfig)
}

// SetDataKsn sets the DataKsn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EncryptionCapableDevice) SetDataKsn(dataKsn *string) {
	e.DataKsn = dataKsn
	e.require(encryptionCapableDeviceFieldDataKsn)
}

func (e *EncryptionCapableDevice) UnmarshalJSON(data []byte) error {
	type unmarshaler EncryptionCapableDevice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EncryptionCapableDevice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EncryptionCapableDevice) MarshalJSON() ([]byte, error) {
	type embed EncryptionCapableDevice
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EncryptionCapableDevice) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Object that contains the fees for enhanced interchange services.
var (
	enhancedInterchangeFieldEnrollment       = big.NewInt(1 << 0)
	enhancedInterchangeFieldCreditToMerchant = big.NewInt(1 << 1)
)

type EnhancedInterchange struct {
	// Enrollment fee for the enhanced interchange services. The value is in the currency's lowest denomination, for example, cents.
	Enrollment Amount `json:"enrollment" url:"enrollment"`
	// Percentage of additional discount.
	CreditToMerchant Percentage `json:"creditToMerchant" url:"creditToMerchant"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EnhancedInterchange) GetEnrollment() Amount {
	if e == nil {
		return 0
	}
	return e.Enrollment
}

func (e *EnhancedInterchange) GetCreditToMerchant() Percentage {
	if e == nil {
		return 0
	}
	return e.CreditToMerchant
}

func (e *EnhancedInterchange) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnhancedInterchange) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEnrollment sets the Enrollment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnhancedInterchange) SetEnrollment(enrollment Amount) {
	e.Enrollment = enrollment
	e.require(enhancedInterchangeFieldEnrollment)
}

// SetCreditToMerchant sets the CreditToMerchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EnhancedInterchange) SetCreditToMerchant(creditToMerchant Percentage) {
	e.CreditToMerchant = creditToMerchant
	e.require(enhancedInterchangeFieldCreditToMerchant)
}

func (e *EnhancedInterchange) UnmarshalJSON(data []byte) error {
	type unmarshaler EnhancedInterchange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnhancedInterchange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnhancedInterchange) MarshalJSON() ([]byte, error) {
	type embed EnhancedInterchange
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EnhancedInterchange) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventSubscriptionFieldId            = big.NewInt(1 << 0)
	eventSubscriptionFieldEnabled       = big.NewInt(1 << 1)
	eventSubscriptionFieldStatus        = big.NewInt(1 << 2)
	eventSubscriptionFieldEventTypes    = big.NewInt(1 << 3)
	eventSubscriptionFieldNotifications = big.NewInt(1 << 4)
	eventSubscriptionFieldMetadata      = big.NewInt(1 << 5)
)

type EventSubscription struct {
	// Unique identifier that we assigned to the event subscription.
	Id *int64 `json:"id,omitempty" url:"id,omitempty"`
	// Indicates if we should notify you when the event occurs. The value is one of the following:
	// - `true` - We notify you when the event occurs.
	// - `false` - We don't notify you when the event occurs.
	Enabled bool `json:"enabled" url:"enabled"`
	// Status of the subscription. We return one of the following values:
	// - `registered` - You have set up the subscription, and we will notify you when an event occurs.
	// - `suspended` - We have deactivated the event subscription, and we won't notify you when an event occurs.
	// - `failed` - We couldn't contact your URI endpoint. We email the supportEmailAddress.
	Status *EventSubscriptionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Array of events that you want to subscribe to. For a list of events, go to [Events List](https://docs.payroc.com/knowledge/events/events-list).
	EventTypes []string `json:"eventTypes" url:"eventTypes"`
	// Array of polymorphic notification objects that contain information about how we contact you when an event occurs.
	Notifications []*Notification `json:"notifications" url:"notifications"`
	// Object that you can send to include custom data in the request. For more information about how to use metadata, go to [Metadata](https://docs.payroc.com/api/metadata).
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventSubscription) GetId() *int64 {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *EventSubscription) GetEnabled() bool {
	if e == nil {
		return false
	}
	return e.Enabled
}

func (e *EventSubscription) GetStatus() *EventSubscriptionStatus {
	if e == nil {
		return nil
	}
	return e.Status
}

func (e *EventSubscription) GetEventTypes() []string {
	if e == nil {
		return nil
	}
	return e.EventTypes
}

func (e *EventSubscription) GetNotifications() []*Notification {
	if e == nil {
		return nil
	}
	return e.Notifications
}

func (e *EventSubscription) GetMetadata() map[string]interface{} {
	if e == nil {
		return nil
	}
	return e.Metadata
}

func (e *EventSubscription) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventSubscription) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventSubscription) SetId(id *int64) {
	e.Id = id
	e.require(eventSubscriptionFieldId)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventSubscription) SetEnabled(enabled bool) {
	e.Enabled = enabled
	e.require(eventSubscriptionFieldEnabled)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventSubscription) SetStatus(status *EventSubscriptionStatus) {
	e.Status = status
	e.require(eventSubscriptionFieldStatus)
}

// SetEventTypes sets the EventTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventSubscription) SetEventTypes(eventTypes []string) {
	e.EventTypes = eventTypes
	e.require(eventSubscriptionFieldEventTypes)
}

// SetNotifications sets the Notifications field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventSubscription) SetNotifications(notifications []*Notification) {
	e.Notifications = notifications
	e.require(eventSubscriptionFieldNotifications)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventSubscription) SetMetadata(metadata map[string]interface{}) {
	e.Metadata = metadata
	e.require(eventSubscriptionFieldMetadata)
}

func (e *EventSubscription) UnmarshalJSON(data []byte) error {
	type unmarshaler EventSubscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventSubscription(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventSubscription) MarshalJSON() ([]byte, error) {
	type embed EventSubscription
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventSubscription) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Status of the subscription. We return one of the following values:
// - `registered` - You have set up the subscription, and we will notify you when an event occurs.
// - `suspended` - We have deactivated the event subscription, and we won't notify you when an event occurs.
// - `failed` - We couldn't contact your URI endpoint. We email the supportEmailAddress.
type EventSubscriptionStatus string

const (
	EventSubscriptionStatusRegistered EventSubscriptionStatus = "registered"
	EventSubscriptionStatusSuspended  EventSubscriptionStatus = "suspended"
	EventSubscriptionStatusFailed     EventSubscriptionStatus = "failed"
)

func NewEventSubscriptionStatusFromString(s string) (EventSubscriptionStatus, error) {
	switch s {
	case "registered":
		return EventSubscriptionStatusRegistered, nil
	case "suspended":
		return EventSubscriptionStatusSuspended, nil
	case "failed":
		return EventSubscriptionStatusFailed, nil
	}
	var t EventSubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventSubscriptionStatus) Ptr() *EventSubscriptionStatus {
	return &e
}

// Object that contains information about the initial payment for the payment instruction.
var (
	firstTxnReferenceDataFieldPaymentId             = big.NewInt(1 << 0)
	firstTxnReferenceDataFieldCardSchemeReferenceId = big.NewInt(1 << 1)
)

type FirstTxnReferenceData struct {
	// Unique identifier of the first payment.
	// **Note:** We recommend that you always send a value for **paymentId**.
	PaymentId *string `json:"paymentId,omitempty" url:"paymentId,omitempty"`
	// Identifier that the card brand assigns to the payment instruction.
	CardSchemeReferenceId *string `json:"cardSchemeReferenceId,omitempty" url:"cardSchemeReferenceId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FirstTxnReferenceData) GetPaymentId() *string {
	if f == nil {
		return nil
	}
	return f.PaymentId
}

func (f *FirstTxnReferenceData) GetCardSchemeReferenceId() *string {
	if f == nil {
		return nil
	}
	return f.CardSchemeReferenceId
}

func (f *FirstTxnReferenceData) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FirstTxnReferenceData) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FirstTxnReferenceData) SetPaymentId(paymentId *string) {
	f.PaymentId = paymentId
	f.require(firstTxnReferenceDataFieldPaymentId)
}

// SetCardSchemeReferenceId sets the CardSchemeReferenceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FirstTxnReferenceData) SetCardSchemeReferenceId(cardSchemeReferenceId *string) {
	f.CardSchemeReferenceId = cardSchemeReferenceId
	f.require(firstTxnReferenceDataFieldCardSchemeReferenceId)
}

func (f *FirstTxnReferenceData) UnmarshalJSON(data []byte) error {
	type unmarshaler FirstTxnReferenceData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FirstTxnReferenceData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FirstTxnReferenceData) MarshalJSON() ([]byte, error) {
	type embed FirstTxnReferenceData
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FirstTxnReferenceData) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Object that contains information about Flat Rate.
var (
	flatRateFieldFees = big.NewInt(1 << 0)
)

type FlatRate struct {
	// Object that contains information about the Flat Rate fees.
	Fees *FlatRateFees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlatRate) GetFees() *FlatRateFees {
	if f == nil {
		return nil
	}
	return f.Fees
}

func (f *FlatRate) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlatRate) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlatRate) SetFees(fees *FlatRateFees) {
	f.Fees = fees
	f.require(flatRateFieldFees)
}

func (f *FlatRate) UnmarshalJSON(data []byte) error {
	type unmarshaler FlatRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlatRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlatRate) MarshalJSON() ([]byte, error) {
	type embed FlatRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlatRate) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	flatRateAmexDirectFieldTransaction = big.NewInt(1 << 0)
)

type FlatRateAmexDirect struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlatRateAmexDirect) GetTransaction() Amount {
	if f == nil {
		return 0
	}
	return f.Transaction
}

func (f *FlatRateAmexDirect) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlatRateAmexDirect) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlatRateAmexDirect) SetTransaction(transaction Amount) {
	f.Transaction = transaction
	f.require(flatRateAmexDirectFieldTransaction)
}

func (f *FlatRateAmexDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler FlatRateAmexDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlatRateAmexDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlatRateAmexDirect) MarshalJSON() ([]byte, error) {
	type embed FlatRateAmexDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlatRateAmexDirect) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Object that contains information about the Flat Rate fees.
var (
	flatRateFeesFieldStandardCards              = big.NewInt(1 << 0)
	flatRateFeesFieldAmex                       = big.NewInt(1 << 1)
	flatRateFeesFieldPinDebit                   = big.NewInt(1 << 2)
	flatRateFeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	flatRateFeesFieldSpecialityCards            = big.NewInt(1 << 4)
)

type FlatRateFees struct {
	// Object that contains the fees for standard card transactions.
	StandardCards *ProcessorFee `json:"standardCards" url:"standardCards"`
	// Polymorphic object that contains fees for American Express transactions.
	Amex                       *FlatRateFeesAmex           `json:"amex,omitempty" url:"amex,omitempty"`
	PinDebit                   *PinDebit                   `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	SpecialityCards            *SpecialityCards            `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlatRateFees) GetStandardCards() *ProcessorFee {
	if f == nil {
		return nil
	}
	return f.StandardCards
}

func (f *FlatRateFees) GetAmex() *FlatRateFeesAmex {
	if f == nil {
		return nil
	}
	return f.Amex
}

func (f *FlatRateFees) GetPinDebit() *PinDebit {
	if f == nil {
		return nil
	}
	return f.PinDebit
}

func (f *FlatRateFees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if f == nil {
		return nil
	}
	return f.ElectronicBenefitsTransfer
}

func (f *FlatRateFees) GetSpecialityCards() *SpecialityCards {
	if f == nil {
		return nil
	}
	return f.SpecialityCards
}

func (f *FlatRateFees) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlatRateFees) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetStandardCards sets the StandardCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlatRateFees) SetStandardCards(standardCards *ProcessorFee) {
	f.StandardCards = standardCards
	f.require(flatRateFeesFieldStandardCards)
}

// SetAmex sets the Amex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlatRateFees) SetAmex(amex *FlatRateFeesAmex) {
	f.Amex = amex
	f.require(flatRateFeesFieldAmex)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlatRateFees) SetPinDebit(pinDebit *PinDebit) {
	f.PinDebit = pinDebit
	f.require(flatRateFeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlatRateFees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	f.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	f.require(flatRateFeesFieldElectronicBenefitsTransfer)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlatRateFees) SetSpecialityCards(specialityCards *SpecialityCards) {
	f.SpecialityCards = specialityCards
	f.require(flatRateFeesFieldSpecialityCards)
}

func (f *FlatRateFees) UnmarshalJSON(data []byte) error {
	type unmarshaler FlatRateFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlatRateFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlatRateFees) MarshalJSON() ([]byte, error) {
	type embed FlatRateFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlatRateFees) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Polymorphic object that contains fees for American Express transactions.
type FlatRateFeesAmex struct {
	Type   string
	Direct *FlatRateAmexDirect
}

func (f *FlatRateFeesAmex) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FlatRateFeesAmex) GetDirect() *FlatRateAmexDirect {
	if f == nil {
		return nil
	}
	return f.Direct
}

func (f *FlatRateFeesAmex) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "direct":
		value := new(FlatRateAmexDirect)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.Direct = value
	}
	return nil
}

func (f FlatRateFeesAmex) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	if f.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(f.Direct, "type", "direct")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", f)
}

type FlatRateFeesAmexVisitor interface {
	VisitDirect(*FlatRateAmexDirect) error
}

func (f *FlatRateFeesAmex) Accept(visitor FlatRateFeesAmexVisitor) error {
	if f.Direct != nil {
		return visitor.VisitDirect(f.Direct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", f)
}

func (f *FlatRateFeesAmex) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.Direct != nil {
		fields = append(fields, "direct")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

// Object that contains information about the encrypted card data for keyed transactions.
var (
	fullyEncryptedKeyedDataFormatFieldDevice          = big.NewInt(1 << 0)
	fullyEncryptedKeyedDataFormatFieldEncryptedData   = big.NewInt(1 << 1)
	fullyEncryptedKeyedDataFormatFieldFirstDigitOfPan = big.NewInt(1 << 2)
)

type FullyEncryptedKeyedDataFormat struct {
	Device *EncryptionCapableDevice `json:"device" url:"device"`
	// Encrypted card data.
	EncryptedData string `json:"encryptedData" url:"encryptedData"`
	// First digit of the customer’s card number.
	FirstDigitOfPan *string `json:"firstDigitOfPan,omitempty" url:"firstDigitOfPan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FullyEncryptedKeyedDataFormat) GetDevice() *EncryptionCapableDevice {
	if f == nil {
		return nil
	}
	return f.Device
}

func (f *FullyEncryptedKeyedDataFormat) GetEncryptedData() string {
	if f == nil {
		return ""
	}
	return f.EncryptedData
}

func (f *FullyEncryptedKeyedDataFormat) GetFirstDigitOfPan() *string {
	if f == nil {
		return nil
	}
	return f.FirstDigitOfPan
}

func (f *FullyEncryptedKeyedDataFormat) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FullyEncryptedKeyedDataFormat) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FullyEncryptedKeyedDataFormat) SetDevice(device *EncryptionCapableDevice) {
	f.Device = device
	f.require(fullyEncryptedKeyedDataFormatFieldDevice)
}

// SetEncryptedData sets the EncryptedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FullyEncryptedKeyedDataFormat) SetEncryptedData(encryptedData string) {
	f.EncryptedData = encryptedData
	f.require(fullyEncryptedKeyedDataFormatFieldEncryptedData)
}

// SetFirstDigitOfPan sets the FirstDigitOfPan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FullyEncryptedKeyedDataFormat) SetFirstDigitOfPan(firstDigitOfPan *string) {
	f.FirstDigitOfPan = firstDigitOfPan
	f.require(fullyEncryptedKeyedDataFormatFieldFirstDigitOfPan)
}

func (f *FullyEncryptedKeyedDataFormat) UnmarshalJSON(data []byte) error {
	type unmarshaler FullyEncryptedKeyedDataFormat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FullyEncryptedKeyedDataFormat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FullyEncryptedKeyedDataFormat) MarshalJSON() ([]byte, error) {
	type embed FullyEncryptedKeyedDataFormat
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FullyEncryptedKeyedDataFormat) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fundingAccountFieldFundingAccountId = big.NewInt(1 << 0)
	fundingAccountFieldCreatedDate      = big.NewInt(1 << 1)
	fundingAccountFieldLastModifiedDate = big.NewInt(1 << 2)
	fundingAccountFieldStatus           = big.NewInt(1 << 3)
	fundingAccountFieldType             = big.NewInt(1 << 4)
	fundingAccountFieldUse              = big.NewInt(1 << 5)
	fundingAccountFieldNameOnAccount    = big.NewInt(1 << 6)
	fundingAccountFieldPaymentMethods   = big.NewInt(1 << 7)
	fundingAccountFieldMetadata         = big.NewInt(1 << 8)
	fundingAccountFieldLinks            = big.NewInt(1 << 9)
)

type FundingAccount struct {
	// Unique identifier that we assigned to the funding account.
	FundingAccountId *int `json:"fundingAccountId,omitempty" url:"fundingAccountId,omitempty"`
	// Date and time that we received your request to create the funding account in our system.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date and time that the funding account was last modified.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	// Status of the funding account. The value is one of the following:
	// - `approved` - We approved the funding account.
	// - `rejected` - We rejected the funding account.
	// - `pending` - We have not yet approved the funding account.
	// - `hold` - Our Risk team have temporarily placed a hold on the funding account.
	Status *FundingAccountStatus `json:"status,omitempty" url:"status,omitempty"`
	// Type of funding account.
	Type FundingAccountType `json:"type" url:"type"`
	// Indicates if we send funds or withdraw funds from the account.
	// - `credit` - Send funds to the account.
	// - `debit` - Withdraw funds from the account.
	// - `creditAndDebit` - Send funds and withdraw funds from the account.
	//
	// **Note:** If the funding account is associated with a funding recipient, we accept only a value of `credit`.
	Use FundingAccountUse `json:"use" url:"use"`
	// Name of the account holder.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Array of paymentMethod objects.
	PaymentMethods PaymentMethods `json:"paymentMethods" url:"paymentMethods"`
	// [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Array of HATEOAS links.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FundingAccount) GetFundingAccountId() *int {
	if f == nil {
		return nil
	}
	return f.FundingAccountId
}

func (f *FundingAccount) GetCreatedDate() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedDate
}

func (f *FundingAccount) GetLastModifiedDate() *time.Time {
	if f == nil {
		return nil
	}
	return f.LastModifiedDate
}

func (f *FundingAccount) GetStatus() *FundingAccountStatus {
	if f == nil {
		return nil
	}
	return f.Status
}

func (f *FundingAccount) GetType() FundingAccountType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FundingAccount) GetUse() FundingAccountUse {
	if f == nil {
		return ""
	}
	return f.Use
}

func (f *FundingAccount) GetNameOnAccount() string {
	if f == nil {
		return ""
	}
	return f.NameOnAccount
}

func (f *FundingAccount) GetPaymentMethods() PaymentMethods {
	if f == nil {
		return nil
	}
	return f.PaymentMethods
}

func (f *FundingAccount) GetMetadata() map[string]string {
	if f == nil {
		return nil
	}
	return f.Metadata
}

func (f *FundingAccount) GetLinks() []*Link {
	if f == nil {
		return nil
	}
	return f.Links
}

func (f *FundingAccount) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FundingAccount) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFundingAccountId sets the FundingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetFundingAccountId(fundingAccountId *int) {
	f.FundingAccountId = fundingAccountId
	f.require(fundingAccountFieldFundingAccountId)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetCreatedDate(createdDate *time.Time) {
	f.CreatedDate = createdDate
	f.require(fundingAccountFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetLastModifiedDate(lastModifiedDate *time.Time) {
	f.LastModifiedDate = lastModifiedDate
	f.require(fundingAccountFieldLastModifiedDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetStatus(status *FundingAccountStatus) {
	f.Status = status
	f.require(fundingAccountFieldStatus)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetType(type_ FundingAccountType) {
	f.Type = type_
	f.require(fundingAccountFieldType)
}

// SetUse sets the Use field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetUse(use FundingAccountUse) {
	f.Use = use
	f.require(fundingAccountFieldUse)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetNameOnAccount(nameOnAccount string) {
	f.NameOnAccount = nameOnAccount
	f.require(fundingAccountFieldNameOnAccount)
}

// SetPaymentMethods sets the PaymentMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetPaymentMethods(paymentMethods PaymentMethods) {
	f.PaymentMethods = paymentMethods
	f.require(fundingAccountFieldPaymentMethods)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetMetadata(metadata map[string]string) {
	f.Metadata = metadata
	f.require(fundingAccountFieldMetadata)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccount) SetLinks(links []*Link) {
	f.Links = links
	f.require(fundingAccountFieldLinks)
}

func (f *FundingAccount) UnmarshalJSON(data []byte) error {
	type embed FundingAccount
	var unmarshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FundingAccount(unmarshaler.embed)
	f.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	f.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FundingAccount) MarshalJSON() ([]byte, error) {
	type embed FundingAccount
	var marshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*f),
		CreatedDate:      internal.NewOptionalDateTime(f.CreatedDate),
		LastModifiedDate: internal.NewOptionalDateTime(f.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FundingAccount) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Status of the funding account. The value is one of the following:
// - `approved` - We approved the funding account.
// - `rejected` - We rejected the funding account.
// - `pending` - We have not yet approved the funding account.
// - `hold` - Our Risk team have temporarily placed a hold on the funding account.
type FundingAccountStatus string

const (
	FundingAccountStatusApproved FundingAccountStatus = "approved"
	FundingAccountStatusRejected FundingAccountStatus = "rejected"
	FundingAccountStatusPending  FundingAccountStatus = "pending"
	FundingAccountStatusHold     FundingAccountStatus = "hold"
)

func NewFundingAccountStatusFromString(s string) (FundingAccountStatus, error) {
	switch s {
	case "approved":
		return FundingAccountStatusApproved, nil
	case "rejected":
		return FundingAccountStatusRejected, nil
	case "pending":
		return FundingAccountStatusPending, nil
	case "hold":
		return FundingAccountStatusHold, nil
	}
	var t FundingAccountStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FundingAccountStatus) Ptr() *FundingAccountStatus {
	return &f
}

var (
	fundingAccountSummaryFieldFundingAccountId = big.NewInt(1 << 0)
	fundingAccountSummaryFieldStatus           = big.NewInt(1 << 1)
	fundingAccountSummaryFieldLink             = big.NewInt(1 << 2)
)

type FundingAccountSummary struct {
	// Unique identifier that we assigned to the funding account.
	FundingAccountId *int `json:"fundingAccountId,omitempty" url:"fundingAccountId,omitempty"`
	// Status of the funding account.
	Status *FundingAccountSummaryStatus `json:"status,omitempty" url:"status,omitempty"`
	// Object that contains HATEOAS links for the funding accounts that are linked to the processing account.
	Link *Link `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FundingAccountSummary) GetFundingAccountId() *int {
	if f == nil {
		return nil
	}
	return f.FundingAccountId
}

func (f *FundingAccountSummary) GetStatus() *FundingAccountSummaryStatus {
	if f == nil {
		return nil
	}
	return f.Status
}

func (f *FundingAccountSummary) GetLink() *Link {
	if f == nil {
		return nil
	}
	return f.Link
}

func (f *FundingAccountSummary) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FundingAccountSummary) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFundingAccountId sets the FundingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccountSummary) SetFundingAccountId(fundingAccountId *int) {
	f.FundingAccountId = fundingAccountId
	f.require(fundingAccountSummaryFieldFundingAccountId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccountSummary) SetStatus(status *FundingAccountSummaryStatus) {
	f.Status = status
	f.require(fundingAccountSummaryFieldStatus)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingAccountSummary) SetLink(link *Link) {
	f.Link = link
	f.require(fundingAccountSummaryFieldLink)
}

func (f *FundingAccountSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler FundingAccountSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FundingAccountSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FundingAccountSummary) MarshalJSON() ([]byte, error) {
	type embed FundingAccountSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FundingAccountSummary) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Status of the funding account.
type FundingAccountSummaryStatus string

const (
	FundingAccountSummaryStatusApproved FundingAccountSummaryStatus = "approved"
	FundingAccountSummaryStatusRejected FundingAccountSummaryStatus = "rejected"
	FundingAccountSummaryStatusPending  FundingAccountSummaryStatus = "pending"
)

func NewFundingAccountSummaryStatusFromString(s string) (FundingAccountSummaryStatus, error) {
	switch s {
	case "approved":
		return FundingAccountSummaryStatusApproved, nil
	case "rejected":
		return FundingAccountSummaryStatusRejected, nil
	case "pending":
		return FundingAccountSummaryStatusPending, nil
	}
	var t FundingAccountSummaryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FundingAccountSummaryStatus) Ptr() *FundingAccountSummaryStatus {
	return &f
}

// Type of funding account.
type FundingAccountType string

const (
	FundingAccountTypeChecking      FundingAccountType = "checking"
	FundingAccountTypeSavings       FundingAccountType = "savings"
	FundingAccountTypeGeneralLedger FundingAccountType = "generalLedger"
)

func NewFundingAccountTypeFromString(s string) (FundingAccountType, error) {
	switch s {
	case "checking":
		return FundingAccountTypeChecking, nil
	case "savings":
		return FundingAccountTypeSavings, nil
	case "generalLedger":
		return FundingAccountTypeGeneralLedger, nil
	}
	var t FundingAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FundingAccountType) Ptr() *FundingAccountType {
	return &f
}

// Indicates if we send funds or withdraw funds from the account.
// - `credit` - Send funds to the account.
// - `debit` - Withdraw funds from the account.
// - `creditAndDebit` - Send funds and withdraw funds from the account.
//
// **Note:** If the funding account is associated with a funding recipient, we accept only a value of `credit`.
type FundingAccountUse string

const (
	FundingAccountUseCredit         FundingAccountUse = "credit"
	FundingAccountUseDebit          FundingAccountUse = "debit"
	FundingAccountUseCreditAndDebit FundingAccountUse = "creditAndDebit"
)

func NewFundingAccountUseFromString(s string) (FundingAccountUse, error) {
	switch s {
	case "credit":
		return FundingAccountUseCredit, nil
	case "debit":
		return FundingAccountUseDebit, nil
	case "creditAndDebit":
		return FundingAccountUseCreditAndDebit, nil
	}
	var t FundingAccountUse
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FundingAccountUse) Ptr() *FundingAccountUse {
	return &f
}

var (
	fundingRecipientFieldRecipientId      = big.NewInt(1 << 0)
	fundingRecipientFieldStatus           = big.NewInt(1 << 1)
	fundingRecipientFieldCreatedDate      = big.NewInt(1 << 2)
	fundingRecipientFieldLastModifiedDate = big.NewInt(1 << 3)
	fundingRecipientFieldRecipientType    = big.NewInt(1 << 4)
	fundingRecipientFieldTaxId            = big.NewInt(1 << 5)
	fundingRecipientFieldCharityId        = big.NewInt(1 << 6)
	fundingRecipientFieldDoingBusinessAs  = big.NewInt(1 << 7)
	fundingRecipientFieldAddress          = big.NewInt(1 << 8)
	fundingRecipientFieldContactMethods   = big.NewInt(1 << 9)
	fundingRecipientFieldMetadata         = big.NewInt(1 << 10)
	fundingRecipientFieldOwners           = big.NewInt(1 << 11)
	fundingRecipientFieldFundingAccounts  = big.NewInt(1 << 12)
)

type FundingRecipient struct {
	// Unique identifier that we assigned to the funding recipient.
	RecipientId *int `json:"recipientId,omitempty" url:"recipientId,omitempty"`
	// Indicates if we have approved the funding recipient.
	Status *FundingRecipientStatus `json:"status,omitempty" url:"status,omitempty"`
	// Date the funding recipient was created.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date the funding recipient was last modified.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	// Type or legal structure of the funding recipient.
	RecipientType FundingRecipientRecipientType `json:"recipientType" url:"recipientType"`
	// Employer identification number (EIN) or Social Security number (SSN).
	TaxId string `json:"taxId" url:"taxId"`
	// Government identifier of the charity.
	CharityId *string `json:"charityId,omitempty" url:"charityId,omitempty"`
	// Legal name of the business or organization.
	DoingBusinessAs string `json:"doingBusinessAs" url:"doingBusinessAs"`
	// Polymorphic object that contains address information for a funding recipient.
	Address *Address `json:"address" url:"address"`
	// Array of polymorphic objects, which contain contact information.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods" url:"contactMethods"`
	// [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Array of owner objects associated with the funding recipient.
	Owners []*FundingRecipientOwnersItem `json:"owners,omitempty" url:"owners,omitempty"`
	// Array of fundingAccount objects associated with the funding recipient.
	FundingAccounts []*FundingRecipientFundingAccountsItem `json:"fundingAccounts,omitempty" url:"fundingAccounts,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FundingRecipient) GetRecipientId() *int {
	if f == nil {
		return nil
	}
	return f.RecipientId
}

func (f *FundingRecipient) GetStatus() *FundingRecipientStatus {
	if f == nil {
		return nil
	}
	return f.Status
}

func (f *FundingRecipient) GetCreatedDate() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedDate
}

func (f *FundingRecipient) GetLastModifiedDate() *time.Time {
	if f == nil {
		return nil
	}
	return f.LastModifiedDate
}

func (f *FundingRecipient) GetRecipientType() FundingRecipientRecipientType {
	if f == nil {
		return ""
	}
	return f.RecipientType
}

func (f *FundingRecipient) GetTaxId() string {
	if f == nil {
		return ""
	}
	return f.TaxId
}

func (f *FundingRecipient) GetCharityId() *string {
	if f == nil {
		return nil
	}
	return f.CharityId
}

func (f *FundingRecipient) GetDoingBusinessAs() string {
	if f == nil {
		return ""
	}
	return f.DoingBusinessAs
}

func (f *FundingRecipient) GetAddress() *Address {
	if f == nil {
		return nil
	}
	return f.Address
}

func (f *FundingRecipient) GetContactMethods() []*ContactMethod {
	if f == nil {
		return nil
	}
	return f.ContactMethods
}

func (f *FundingRecipient) GetMetadata() map[string]string {
	if f == nil {
		return nil
	}
	return f.Metadata
}

func (f *FundingRecipient) GetOwners() []*FundingRecipientOwnersItem {
	if f == nil {
		return nil
	}
	return f.Owners
}

func (f *FundingRecipient) GetFundingAccounts() []*FundingRecipientFundingAccountsItem {
	if f == nil {
		return nil
	}
	return f.FundingAccounts
}

func (f *FundingRecipient) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FundingRecipient) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetRecipientId sets the RecipientId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetRecipientId(recipientId *int) {
	f.RecipientId = recipientId
	f.require(fundingRecipientFieldRecipientId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetStatus(status *FundingRecipientStatus) {
	f.Status = status
	f.require(fundingRecipientFieldStatus)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetCreatedDate(createdDate *time.Time) {
	f.CreatedDate = createdDate
	f.require(fundingRecipientFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetLastModifiedDate(lastModifiedDate *time.Time) {
	f.LastModifiedDate = lastModifiedDate
	f.require(fundingRecipientFieldLastModifiedDate)
}

// SetRecipientType sets the RecipientType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetRecipientType(recipientType FundingRecipientRecipientType) {
	f.RecipientType = recipientType
	f.require(fundingRecipientFieldRecipientType)
}

// SetTaxId sets the TaxId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetTaxId(taxId string) {
	f.TaxId = taxId
	f.require(fundingRecipientFieldTaxId)
}

// SetCharityId sets the CharityId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetCharityId(charityId *string) {
	f.CharityId = charityId
	f.require(fundingRecipientFieldCharityId)
}

// SetDoingBusinessAs sets the DoingBusinessAs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetDoingBusinessAs(doingBusinessAs string) {
	f.DoingBusinessAs = doingBusinessAs
	f.require(fundingRecipientFieldDoingBusinessAs)
}

// SetAddress sets the Address field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetAddress(address *Address) {
	f.Address = address
	f.require(fundingRecipientFieldAddress)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetContactMethods(contactMethods []*ContactMethod) {
	f.ContactMethods = contactMethods
	f.require(fundingRecipientFieldContactMethods)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetMetadata(metadata map[string]string) {
	f.Metadata = metadata
	f.require(fundingRecipientFieldMetadata)
}

// SetOwners sets the Owners field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetOwners(owners []*FundingRecipientOwnersItem) {
	f.Owners = owners
	f.require(fundingRecipientFieldOwners)
}

// SetFundingAccounts sets the FundingAccounts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipient) SetFundingAccounts(fundingAccounts []*FundingRecipientFundingAccountsItem) {
	f.FundingAccounts = fundingAccounts
	f.require(fundingRecipientFieldFundingAccounts)
}

func (f *FundingRecipient) UnmarshalJSON(data []byte) error {
	type embed FundingRecipient
	var unmarshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FundingRecipient(unmarshaler.embed)
	f.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	f.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FundingRecipient) MarshalJSON() ([]byte, error) {
	type embed FundingRecipient
	var marshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*f),
		CreatedDate:      internal.NewOptionalDateTime(f.CreatedDate),
		LastModifiedDate: internal.NewOptionalDateTime(f.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FundingRecipient) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fundingRecipientFundingAccountsItemFieldFundingAccountId = big.NewInt(1 << 0)
	fundingRecipientFundingAccountsItemFieldStatus           = big.NewInt(1 << 1)
	fundingRecipientFundingAccountsItemFieldLink             = big.NewInt(1 << 2)
)

type FundingRecipientFundingAccountsItem struct {
	// Unique identifier of the funding account.
	FundingAccountId *int `json:"fundingAccountId,omitempty" url:"fundingAccountId,omitempty"`
	// Status of the funding account.
	Status *FundingRecipientFundingAccountsItemStatus `json:"status,omitempty" url:"status,omitempty"`
	// Object that contains HATEOAS links for the resource.
	Link *FundingRecipientFundingAccountsItemLink `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FundingRecipientFundingAccountsItem) GetFundingAccountId() *int {
	if f == nil {
		return nil
	}
	return f.FundingAccountId
}

func (f *FundingRecipientFundingAccountsItem) GetStatus() *FundingRecipientFundingAccountsItemStatus {
	if f == nil {
		return nil
	}
	return f.Status
}

func (f *FundingRecipientFundingAccountsItem) GetLink() *FundingRecipientFundingAccountsItemLink {
	if f == nil {
		return nil
	}
	return f.Link
}

func (f *FundingRecipientFundingAccountsItem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FundingRecipientFundingAccountsItem) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFundingAccountId sets the FundingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientFundingAccountsItem) SetFundingAccountId(fundingAccountId *int) {
	f.FundingAccountId = fundingAccountId
	f.require(fundingRecipientFundingAccountsItemFieldFundingAccountId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientFundingAccountsItem) SetStatus(status *FundingRecipientFundingAccountsItemStatus) {
	f.Status = status
	f.require(fundingRecipientFundingAccountsItemFieldStatus)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientFundingAccountsItem) SetLink(link *FundingRecipientFundingAccountsItemLink) {
	f.Link = link
	f.require(fundingRecipientFundingAccountsItemFieldLink)
}

func (f *FundingRecipientFundingAccountsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler FundingRecipientFundingAccountsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FundingRecipientFundingAccountsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FundingRecipientFundingAccountsItem) MarshalJSON() ([]byte, error) {
	type embed FundingRecipientFundingAccountsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FundingRecipientFundingAccountsItem) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Object that contains HATEOAS links for the resource.
var (
	fundingRecipientFundingAccountsItemLinkFieldRel    = big.NewInt(1 << 0)
	fundingRecipientFundingAccountsItemLinkFieldHref   = big.NewInt(1 << 1)
	fundingRecipientFundingAccountsItemLinkFieldMethod = big.NewInt(1 << 2)
)

type FundingRecipientFundingAccountsItemLink struct {
	// Indicates the relationship between the current resource and the target resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// URL of the target resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`
	// HTTP method that you need to use with the target resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FundingRecipientFundingAccountsItemLink) GetRel() *string {
	if f == nil {
		return nil
	}
	return f.Rel
}

func (f *FundingRecipientFundingAccountsItemLink) GetHref() *string {
	if f == nil {
		return nil
	}
	return f.Href
}

func (f *FundingRecipientFundingAccountsItemLink) GetMethod() *string {
	if f == nil {
		return nil
	}
	return f.Method
}

func (f *FundingRecipientFundingAccountsItemLink) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FundingRecipientFundingAccountsItemLink) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientFundingAccountsItemLink) SetRel(rel *string) {
	f.Rel = rel
	f.require(fundingRecipientFundingAccountsItemLinkFieldRel)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientFundingAccountsItemLink) SetHref(href *string) {
	f.Href = href
	f.require(fundingRecipientFundingAccountsItemLinkFieldHref)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientFundingAccountsItemLink) SetMethod(method *string) {
	f.Method = method
	f.require(fundingRecipientFundingAccountsItemLinkFieldMethod)
}

func (f *FundingRecipientFundingAccountsItemLink) UnmarshalJSON(data []byte) error {
	type unmarshaler FundingRecipientFundingAccountsItemLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FundingRecipientFundingAccountsItemLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FundingRecipientFundingAccountsItemLink) MarshalJSON() ([]byte, error) {
	type embed FundingRecipientFundingAccountsItemLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FundingRecipientFundingAccountsItemLink) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Status of the funding account.
type FundingRecipientFundingAccountsItemStatus string

const (
	FundingRecipientFundingAccountsItemStatusApproved FundingRecipientFundingAccountsItemStatus = "approved"
	FundingRecipientFundingAccountsItemStatusRejected FundingRecipientFundingAccountsItemStatus = "rejected"
	FundingRecipientFundingAccountsItemStatusPending  FundingRecipientFundingAccountsItemStatus = "pending"
	FundingRecipientFundingAccountsItemStatusHold     FundingRecipientFundingAccountsItemStatus = "hold"
)

func NewFundingRecipientFundingAccountsItemStatusFromString(s string) (FundingRecipientFundingAccountsItemStatus, error) {
	switch s {
	case "approved":
		return FundingRecipientFundingAccountsItemStatusApproved, nil
	case "rejected":
		return FundingRecipientFundingAccountsItemStatusRejected, nil
	case "pending":
		return FundingRecipientFundingAccountsItemStatusPending, nil
	case "hold":
		return FundingRecipientFundingAccountsItemStatusHold, nil
	}
	var t FundingRecipientFundingAccountsItemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FundingRecipientFundingAccountsItemStatus) Ptr() *FundingRecipientFundingAccountsItemStatus {
	return &f
}

var (
	fundingRecipientOwnersItemFieldOwnerId = big.NewInt(1 << 0)
	fundingRecipientOwnersItemFieldLink    = big.NewInt(1 << 1)
)

type FundingRecipientOwnersItem struct {
	// Unique identifier of the owner.
	OwnerId *int `json:"ownerId,omitempty" url:"ownerId,omitempty"`
	// Object that contains HATEOAS links for the resource.
	Link *FundingRecipientOwnersItemLink `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FundingRecipientOwnersItem) GetOwnerId() *int {
	if f == nil {
		return nil
	}
	return f.OwnerId
}

func (f *FundingRecipientOwnersItem) GetLink() *FundingRecipientOwnersItemLink {
	if f == nil {
		return nil
	}
	return f.Link
}

func (f *FundingRecipientOwnersItem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FundingRecipientOwnersItem) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetOwnerId sets the OwnerId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientOwnersItem) SetOwnerId(ownerId *int) {
	f.OwnerId = ownerId
	f.require(fundingRecipientOwnersItemFieldOwnerId)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientOwnersItem) SetLink(link *FundingRecipientOwnersItemLink) {
	f.Link = link
	f.require(fundingRecipientOwnersItemFieldLink)
}

func (f *FundingRecipientOwnersItem) UnmarshalJSON(data []byte) error {
	type unmarshaler FundingRecipientOwnersItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FundingRecipientOwnersItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FundingRecipientOwnersItem) MarshalJSON() ([]byte, error) {
	type embed FundingRecipientOwnersItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FundingRecipientOwnersItem) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Object that contains HATEOAS links for the resource.
var (
	fundingRecipientOwnersItemLinkFieldRel    = big.NewInt(1 << 0)
	fundingRecipientOwnersItemLinkFieldHref   = big.NewInt(1 << 1)
	fundingRecipientOwnersItemLinkFieldMethod = big.NewInt(1 << 2)
)

type FundingRecipientOwnersItemLink struct {
	// Indicates the relationship between the current resource and the target resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// URL of the target resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`
	// HTTP method that you need to use with the target resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FundingRecipientOwnersItemLink) GetRel() *string {
	if f == nil {
		return nil
	}
	return f.Rel
}

func (f *FundingRecipientOwnersItemLink) GetHref() *string {
	if f == nil {
		return nil
	}
	return f.Href
}

func (f *FundingRecipientOwnersItemLink) GetMethod() *string {
	if f == nil {
		return nil
	}
	return f.Method
}

func (f *FundingRecipientOwnersItemLink) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FundingRecipientOwnersItemLink) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientOwnersItemLink) SetRel(rel *string) {
	f.Rel = rel
	f.require(fundingRecipientOwnersItemLinkFieldRel)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientOwnersItemLink) SetHref(href *string) {
	f.Href = href
	f.require(fundingRecipientOwnersItemLinkFieldHref)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FundingRecipientOwnersItemLink) SetMethod(method *string) {
	f.Method = method
	f.require(fundingRecipientOwnersItemLinkFieldMethod)
}

func (f *FundingRecipientOwnersItemLink) UnmarshalJSON(data []byte) error {
	type unmarshaler FundingRecipientOwnersItemLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FundingRecipientOwnersItemLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FundingRecipientOwnersItemLink) MarshalJSON() ([]byte, error) {
	type embed FundingRecipientOwnersItemLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FundingRecipientOwnersItemLink) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Type or legal structure of the funding recipient.
type FundingRecipientRecipientType string

const (
	FundingRecipientRecipientTypePrivateCorporation FundingRecipientRecipientType = "privateCorporation"
	FundingRecipientRecipientTypePublicCorporation  FundingRecipientRecipientType = "publicCorporation"
	FundingRecipientRecipientTypeNonProfit          FundingRecipientRecipientType = "nonProfit"
	FundingRecipientRecipientTypeGovernment         FundingRecipientRecipientType = "government"
	FundingRecipientRecipientTypePrivateLlc         FundingRecipientRecipientType = "privateLlc"
	FundingRecipientRecipientTypePublicLlc          FundingRecipientRecipientType = "publicLlc"
	FundingRecipientRecipientTypePrivatePartnership FundingRecipientRecipientType = "privatePartnership"
	FundingRecipientRecipientTypePublicPartnership  FundingRecipientRecipientType = "publicPartnership"
	FundingRecipientRecipientTypeSoleProprietor     FundingRecipientRecipientType = "soleProprietor"
)

func NewFundingRecipientRecipientTypeFromString(s string) (FundingRecipientRecipientType, error) {
	switch s {
	case "privateCorporation":
		return FundingRecipientRecipientTypePrivateCorporation, nil
	case "publicCorporation":
		return FundingRecipientRecipientTypePublicCorporation, nil
	case "nonProfit":
		return FundingRecipientRecipientTypeNonProfit, nil
	case "government":
		return FundingRecipientRecipientTypeGovernment, nil
	case "privateLlc":
		return FundingRecipientRecipientTypePrivateLlc, nil
	case "publicLlc":
		return FundingRecipientRecipientTypePublicLlc, nil
	case "privatePartnership":
		return FundingRecipientRecipientTypePrivatePartnership, nil
	case "publicPartnership":
		return FundingRecipientRecipientTypePublicPartnership, nil
	case "soleProprietor":
		return FundingRecipientRecipientTypeSoleProprietor, nil
	}
	var t FundingRecipientRecipientType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FundingRecipientRecipientType) Ptr() *FundingRecipientRecipientType {
	return &f
}

// Indicates if we have approved the funding recipient.
type FundingRecipientStatus string

const (
	FundingRecipientStatusApproved FundingRecipientStatus = "approved"
	FundingRecipientStatusRejected FundingRecipientStatus = "rejected"
	FundingRecipientStatusPending  FundingRecipientStatus = "pending"
)

func NewFundingRecipientStatusFromString(s string) (FundingRecipientStatus, error) {
	switch s {
	case "approved":
		return FundingRecipientStatusApproved, nil
	case "rejected":
		return FundingRecipientStatusRejected, nil
	case "pending":
		return FundingRecipientStatusPending, nil
	}
	var t FundingRecipientStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FundingRecipientStatus) Ptr() *FundingRecipientStatus {
	return &f
}

// Foreign exchange rate for the transaction.
var (
	fxRateFieldProcessingTerminalId = big.NewInt(1 << 0)
	fxRateFieldOperator             = big.NewInt(1 << 1)
	fxRateFieldBaseAmount           = big.NewInt(1 << 2)
	fxRateFieldBaseCurrency         = big.NewInt(1 << 3)
	fxRateFieldInquiryResult        = big.NewInt(1 << 4)
	fxRateFieldDccOffer             = big.NewInt(1 << 5)
	fxRateFieldCardInfo             = big.NewInt(1 << 6)
)

type FxRate struct {
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Operator who ran the transaction.
	Operator *string `json:"operator,omitempty" url:"operator,omitempty"`
	// Total amount of the transaction in the local currency. The value is in the currency’s lowest denomination, for example, cents.
	BaseAmount    int64                `json:"baseAmount" url:"baseAmount"`
	BaseCurrency  Currency             `json:"baseCurrency" url:"baseCurrency"`
	InquiryResult *FxRateInquiryResult `json:"inquiryResult" url:"inquiryResult"`
	DccOffer      *DccOffer            `json:"dccOffer,omitempty" url:"dccOffer,omitempty"`
	CardInfo      *CardInfo            `json:"cardInfo" url:"cardInfo"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FxRate) GetProcessingTerminalId() string {
	if f == nil {
		return ""
	}
	return f.ProcessingTerminalId
}

func (f *FxRate) GetOperator() *string {
	if f == nil {
		return nil
	}
	return f.Operator
}

func (f *FxRate) GetBaseAmount() int64 {
	if f == nil {
		return 0
	}
	return f.BaseAmount
}

func (f *FxRate) GetBaseCurrency() Currency {
	if f == nil {
		return ""
	}
	return f.BaseCurrency
}

func (f *FxRate) GetInquiryResult() *FxRateInquiryResult {
	if f == nil {
		return nil
	}
	return f.InquiryResult
}

func (f *FxRate) GetDccOffer() *DccOffer {
	if f == nil {
		return nil
	}
	return f.DccOffer
}

func (f *FxRate) GetCardInfo() *CardInfo {
	if f == nil {
		return nil
	}
	return f.CardInfo
}

func (f *FxRate) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FxRate) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRate) SetProcessingTerminalId(processingTerminalId string) {
	f.ProcessingTerminalId = processingTerminalId
	f.require(fxRateFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRate) SetOperator(operator *string) {
	f.Operator = operator
	f.require(fxRateFieldOperator)
}

// SetBaseAmount sets the BaseAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRate) SetBaseAmount(baseAmount int64) {
	f.BaseAmount = baseAmount
	f.require(fxRateFieldBaseAmount)
}

// SetBaseCurrency sets the BaseCurrency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRate) SetBaseCurrency(baseCurrency Currency) {
	f.BaseCurrency = baseCurrency
	f.require(fxRateFieldBaseCurrency)
}

// SetInquiryResult sets the InquiryResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRate) SetInquiryResult(inquiryResult *FxRateInquiryResult) {
	f.InquiryResult = inquiryResult
	f.require(fxRateFieldInquiryResult)
}

// SetDccOffer sets the DccOffer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRate) SetDccOffer(dccOffer *DccOffer) {
	f.DccOffer = dccOffer
	f.require(fxRateFieldDccOffer)
}

// SetCardInfo sets the CardInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRate) SetCardInfo(cardInfo *CardInfo) {
	f.CardInfo = cardInfo
	f.require(fxRateFieldCardInfo)
}

func (f *FxRate) UnmarshalJSON(data []byte) error {
	type unmarshaler FxRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FxRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FxRate) MarshalJSON() ([]byte, error) {
	type embed FxRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FxRate) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Object that indicates if the customer's card is eligible for Dynamic Currency Conversion (DCC).
var (
	fxRateInquiryResultFieldDccOffered       = big.NewInt(1 << 0)
	fxRateInquiryResultFieldCauseOfRejection = big.NewInt(1 << 1)
)

type FxRateInquiryResult struct {
	// Indicates if the card is eligible for Dynamic Currency Conversion (DCC).
	DccOffered bool `json:"dccOffered" url:"dccOffered"`
	// Explains why the DCC service did not offer a currency conversion rate to the customer.
	CauseOfRejection *string `json:"causeOfRejection,omitempty" url:"causeOfRejection,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FxRateInquiryResult) GetDccOffered() bool {
	if f == nil {
		return false
	}
	return f.DccOffered
}

func (f *FxRateInquiryResult) GetCauseOfRejection() *string {
	if f == nil {
		return nil
	}
	return f.CauseOfRejection
}

func (f *FxRateInquiryResult) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FxRateInquiryResult) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetDccOffered sets the DccOffered field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRateInquiryResult) SetDccOffered(dccOffered bool) {
	f.DccOffered = dccOffered
	f.require(fxRateInquiryResultFieldDccOffered)
}

// SetCauseOfRejection sets the CauseOfRejection field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FxRateInquiryResult) SetCauseOfRejection(causeOfRejection *string) {
	f.CauseOfRejection = causeOfRejection
	f.require(fxRateInquiryResultFieldCauseOfRejection)
}

func (f *FxRateInquiryResult) UnmarshalJSON(data []byte) error {
	type unmarshaler FxRateInquiryResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FxRateInquiryResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FxRateInquiryResult) MarshalJSON() ([]byte, error) {
	type embed FxRateInquiryResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FxRateInquiryResult) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Object that contains the 3-D Secure information from our gateway.
var (
	gatewayThreeDSecureFieldMpiReference = big.NewInt(1 << 0)
)

type GatewayThreeDSecure struct {
	// Reference that our gateway assigned to the 3-D Secure authentication response.
	MpiReference string `json:"mpiReference" url:"mpiReference"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GatewayThreeDSecure) GetMpiReference() string {
	if g == nil {
		return ""
	}
	return g.MpiReference
}

func (g *GatewayThreeDSecure) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayThreeDSecure) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMpiReference sets the MpiReference field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayThreeDSecure) SetMpiReference(mpiReference string) {
	g.MpiReference = mpiReference
	g.require(gatewayThreeDSecureFieldMpiReference)
}

func (g *GatewayThreeDSecure) UnmarshalJSON(data []byte) error {
	type unmarshaler GatewayThreeDSecure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GatewayThreeDSecure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayThreeDSecure) MarshalJSON() ([]byte, error) {
	type embed GatewayThreeDSecure
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GatewayThreeDSecure) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Object that contains information about the gateway fees.
var (
	gatewayUsFieldFees = big.NewInt(1 << 0)
)

type GatewayUs struct {
	// Object that contains information about the gateway fees.
	Fees *GatewayUsFees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GatewayUs) GetFees() *GatewayUsFees {
	if g == nil {
		return nil
	}
	return g.Fees
}

func (g *GatewayUs) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayUs) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUs) SetFees(fees *GatewayUsFees) {
	g.Fees = fees
	g.require(gatewayUsFieldFees)
}

func (g *GatewayUs) UnmarshalJSON(data []byte) error {
	type unmarshaler GatewayUs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GatewayUs(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayUs) MarshalJSON() ([]byte, error) {
	type embed GatewayUs
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GatewayUs) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Object that contains information about the gateway fees for MPA 5.0.
var (
	gatewayUs50FieldFees = big.NewInt(1 << 0)
)

type GatewayUs50 struct {
	// Object that contains information about the gateway fees.
	Fees *GatewayUs50Fees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GatewayUs50) GetFees() *GatewayUs50Fees {
	if g == nil {
		return nil
	}
	return g.Fees
}

func (g *GatewayUs50) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayUs50) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUs50) SetFees(fees *GatewayUs50Fees) {
	g.Fees = fees
	g.require(gatewayUs50FieldFees)
}

func (g *GatewayUs50) UnmarshalJSON(data []byte) error {
	type unmarshaler GatewayUs50
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GatewayUs50(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayUs50) MarshalJSON() ([]byte, error) {
	type embed GatewayUs50
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GatewayUs50) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Object that contains information about the gateway fees.
var (
	gatewayUs50FeesFieldMonthly          = big.NewInt(1 << 0)
	gatewayUs50FeesFieldSetup            = big.NewInt(1 << 1)
	gatewayUs50FeesFieldPerTransaction   = big.NewInt(1 << 2)
	gatewayUs50FeesFieldPerDeviceMonthly = big.NewInt(1 << 3)
)

type GatewayUs50Fees struct {
	// Monthly fee for the gateway. The value is in the currency's lowest denomination, for example, cents.
	Monthly Amount `json:"monthly" url:"monthly"`
	// Fee for setting up your account with the gateway. The value is in the currency's lowest denomination, for example, cents.
	Setup Amount `json:"setup" url:"setup"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	PerTransaction Amount `json:"perTransaction" url:"perTransaction"`
	// Monthly fee for each device. The value is in the currency's lowest denomination, for example, cents.
	PerDeviceMonthly Amount `json:"perDeviceMonthly" url:"perDeviceMonthly"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GatewayUs50Fees) GetMonthly() Amount {
	if g == nil {
		return 0
	}
	return g.Monthly
}

func (g *GatewayUs50Fees) GetSetup() Amount {
	if g == nil {
		return 0
	}
	return g.Setup
}

func (g *GatewayUs50Fees) GetPerTransaction() Amount {
	if g == nil {
		return 0
	}
	return g.PerTransaction
}

func (g *GatewayUs50Fees) GetPerDeviceMonthly() Amount {
	if g == nil {
		return 0
	}
	return g.PerDeviceMonthly
}

func (g *GatewayUs50Fees) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayUs50Fees) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMonthly sets the Monthly field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUs50Fees) SetMonthly(monthly Amount) {
	g.Monthly = monthly
	g.require(gatewayUs50FeesFieldMonthly)
}

// SetSetup sets the Setup field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUs50Fees) SetSetup(setup Amount) {
	g.Setup = setup
	g.require(gatewayUs50FeesFieldSetup)
}

// SetPerTransaction sets the PerTransaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUs50Fees) SetPerTransaction(perTransaction Amount) {
	g.PerTransaction = perTransaction
	g.require(gatewayUs50FeesFieldPerTransaction)
}

// SetPerDeviceMonthly sets the PerDeviceMonthly field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUs50Fees) SetPerDeviceMonthly(perDeviceMonthly Amount) {
	g.PerDeviceMonthly = perDeviceMonthly
	g.require(gatewayUs50FeesFieldPerDeviceMonthly)
}

func (g *GatewayUs50Fees) UnmarshalJSON(data []byte) error {
	type unmarshaler GatewayUs50Fees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GatewayUs50Fees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayUs50Fees) MarshalJSON() ([]byte, error) {
	type embed GatewayUs50Fees
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GatewayUs50Fees) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Object that contains information about the gateway fees.
var (
	gatewayUsFeesFieldMonthly                  = big.NewInt(1 << 0)
	gatewayUsFeesFieldSetup                    = big.NewInt(1 << 1)
	gatewayUsFeesFieldPerTransaction           = big.NewInt(1 << 2)
	gatewayUsFeesFieldPerDeviceMonthly         = big.NewInt(1 << 3)
	gatewayUsFeesFieldAdditionalServiceMonthly = big.NewInt(1 << 4)
)

type GatewayUsFees struct {
	// Monthly fee for the gateway. The value is in the currency's lowest denomination, for example, cents.
	Monthly Amount `json:"monthly" url:"monthly"`
	// Fee for setting up your account with the gateway. The value is in the currency's lowest denomination, for example, cents.
	Setup Amount `json:"setup" url:"setup"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	PerTransaction Amount `json:"perTransaction" url:"perTransaction"`
	// Monthly fee for each device. The value is in the currency's lowest denomination, for example, cents.
	PerDeviceMonthly Amount `json:"perDeviceMonthly" url:"perDeviceMonthly"`
	// Monthly fee for additional service. The value is in the currency's lowest denomination, for example, cents.
	AdditionalServiceMonthly Amount `json:"additionalServiceMonthly" url:"additionalServiceMonthly"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GatewayUsFees) GetMonthly() Amount {
	if g == nil {
		return 0
	}
	return g.Monthly
}

func (g *GatewayUsFees) GetSetup() Amount {
	if g == nil {
		return 0
	}
	return g.Setup
}

func (g *GatewayUsFees) GetPerTransaction() Amount {
	if g == nil {
		return 0
	}
	return g.PerTransaction
}

func (g *GatewayUsFees) GetPerDeviceMonthly() Amount {
	if g == nil {
		return 0
	}
	return g.PerDeviceMonthly
}

func (g *GatewayUsFees) GetAdditionalServiceMonthly() Amount {
	if g == nil {
		return 0
	}
	return g.AdditionalServiceMonthly
}

func (g *GatewayUsFees) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayUsFees) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetMonthly sets the Monthly field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUsFees) SetMonthly(monthly Amount) {
	g.Monthly = monthly
	g.require(gatewayUsFeesFieldMonthly)
}

// SetSetup sets the Setup field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUsFees) SetSetup(setup Amount) {
	g.Setup = setup
	g.require(gatewayUsFeesFieldSetup)
}

// SetPerTransaction sets the PerTransaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUsFees) SetPerTransaction(perTransaction Amount) {
	g.PerTransaction = perTransaction
	g.require(gatewayUsFeesFieldPerTransaction)
}

// SetPerDeviceMonthly sets the PerDeviceMonthly field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUsFees) SetPerDeviceMonthly(perDeviceMonthly Amount) {
	g.PerDeviceMonthly = perDeviceMonthly
	g.require(gatewayUsFeesFieldPerDeviceMonthly)
}

// SetAdditionalServiceMonthly sets the AdditionalServiceMonthly field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GatewayUsFees) SetAdditionalServiceMonthly(additionalServiceMonthly Amount) {
	g.AdditionalServiceMonthly = additionalServiceMonthly
	g.require(gatewayUsFeesFieldAdditionalServiceMonthly)
}

func (g *GatewayUsFees) UnmarshalJSON(data []byte) error {
	type unmarshaler GatewayUsFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GatewayUsFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayUsFees) MarshalJSON() ([]byte, error) {
	type embed GatewayUsFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GatewayUsFees) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Object that contains information about the Hardware Advantage Plan.
var (
	hardwareAdvantagePlanFieldEnabled = big.NewInt(1 << 0)
)

type HardwareAdvantagePlan struct {
	// Indicates if the merchant has signed up for the Hardware Advantage Plan.
	Enabled bool `json:"enabled" url:"enabled"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HardwareAdvantagePlan) GetEnabled() bool {
	if h == nil {
		return false
	}
	return h.Enabled
}

func (h *HardwareAdvantagePlan) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HardwareAdvantagePlan) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HardwareAdvantagePlan) SetEnabled(enabled bool) {
	h.Enabled = enabled
	h.require(hardwareAdvantagePlanFieldEnabled)
}

func (h *HardwareAdvantagePlan) UnmarshalJSON(data []byte) error {
	type unmarshaler HardwareAdvantagePlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HardwareAdvantagePlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HardwareAdvantagePlan) MarshalJSON() ([]byte, error) {
	type embed HardwareAdvantagePlan
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HardwareAdvantagePlan) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Object that contains the terminal's host configuration.
var (
	hostConfigurationFieldProcessingTerminalId = big.NewInt(1 << 0)
	hostConfigurationFieldProcessingAccountId  = big.NewInt(1 << 1)
	hostConfigurationFieldConfiguration        = big.NewInt(1 << 2)
)

type HostConfiguration struct {
	// Unique identifier that our gateway assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Unique identifier that we assigned to the processing account.
	ProcessingAccountId *string `json:"processingAccountId,omitempty" url:"processingAccountId,omitempty"`
	// Polymorphic object that contains the host processor configuration.
	Configuration *HostConfigurationConfiguration `json:"configuration" url:"configuration"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HostConfiguration) GetProcessingTerminalId() string {
	if h == nil {
		return ""
	}
	return h.ProcessingTerminalId
}

func (h *HostConfiguration) GetProcessingAccountId() *string {
	if h == nil {
		return nil
	}
	return h.ProcessingAccountId
}

func (h *HostConfiguration) GetConfiguration() *HostConfigurationConfiguration {
	if h == nil {
		return nil
	}
	return h.Configuration
}

func (h *HostConfiguration) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HostConfiguration) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostConfiguration) SetProcessingTerminalId(processingTerminalId string) {
	h.ProcessingTerminalId = processingTerminalId
	h.require(hostConfigurationFieldProcessingTerminalId)
}

// SetProcessingAccountId sets the ProcessingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostConfiguration) SetProcessingAccountId(processingAccountId *string) {
	h.ProcessingAccountId = processingAccountId
	h.require(hostConfigurationFieldProcessingAccountId)
}

// SetConfiguration sets the Configuration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HostConfiguration) SetConfiguration(configuration *HostConfigurationConfiguration) {
	h.Configuration = configuration
	h.require(hostConfigurationFieldConfiguration)
}

func (h *HostConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler HostConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HostConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HostConfiguration) MarshalJSON() ([]byte, error) {
	type embed HostConfiguration
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HostConfiguration) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

// Polymorphic object that contains the host processor configuration.
type HostConfigurationConfiguration struct {
	Processor string
	Tsys      *Tsys
}

func (h *HostConfigurationConfiguration) GetProcessor() string {
	if h == nil {
		return ""
	}
	return h.Processor
}

func (h *HostConfigurationConfiguration) GetTsys() *Tsys {
	if h == nil {
		return nil
	}
	return h.Tsys
}

func (h *HostConfigurationConfiguration) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Processor string `json:"processor"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	h.Processor = unmarshaler.Processor
	if unmarshaler.Processor == "" {
		return fmt.Errorf("%T did not include discriminant processor", h)
	}
	switch unmarshaler.Processor {
	case "tsys":
		value := new(Tsys)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		h.Tsys = value
	}
	return nil
}

func (h HostConfigurationConfiguration) MarshalJSON() ([]byte, error) {
	if err := h.validate(); err != nil {
		return nil, err
	}
	if h.Tsys != nil {
		return internal.MarshalJSONWithExtraProperty(h.Tsys, "processor", "tsys")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", h)
}

type HostConfigurationConfigurationVisitor interface {
	VisitTsys(*Tsys) error
}

func (h *HostConfigurationConfiguration) Accept(visitor HostConfigurationConfigurationVisitor) error {
	if h.Tsys != nil {
		return visitor.VisitTsys(h.Tsys)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", h)
}

func (h *HostConfigurationConfiguration) validate() error {
	if h == nil {
		return fmt.Errorf("type %T is nil", h)
	}
	var fields []string
	if h.Tsys != nil {
		fields = append(fields, "tsys")
	}
	if len(fields) == 0 {
		if h.Processor != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", h, h.Processor)
		}
		return fmt.Errorf("type %T is empty", h)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", h, fields)
	}
	if h.Processor != "" {
		field := fields[0]
		if h.Processor != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				h,
				h.Processor,
				h,
			)
		}
	}
	return nil
}

// Object that contains information about the Integrated Circuit Card (ICC).
var (
	iccCardDetailsFieldDowngradeTo         = big.NewInt(1 << 0)
	iccCardDetailsFieldDevice              = big.NewInt(1 << 1)
	iccCardDetailsFieldIccData             = big.NewInt(1 << 2)
	iccCardDetailsFieldFirstDigitOfPan     = big.NewInt(1 << 3)
	iccCardDetailsFieldCardholderSignature = big.NewInt(1 << 4)
	iccCardDetailsFieldEbtDetails          = big.NewInt(1 << 5)
)

type IccCardDetails struct {
	// If an offline transaction is not approved using the initial entry method, reprocess the transaction using a downgraded entry method.
	// For example, an Integrated Circuit Card (ICC) transaction can be downgraded to a swiped transaction or a keyed transaction.
	DowngradeTo *IccCardDetailsDowngradeTo `json:"downgradeTo,omitempty" url:"downgradeTo,omitempty"`
	Device      *EncryptionCapableDevice   `json:"device" url:"device"`
	// Cardholder data from the ICC. The data consists of EMV tags in Tag-Length-Value (TLV) format.
	IccData string `json:"iccData" url:"iccData"`
	// First digit of the card number.
	FirstDigitOfPan *string `json:"firstDigitOfPan,omitempty" url:"firstDigitOfPan,omitempty"`
	// Cardholder's signature. For more information about how to format the signature, go to [How to send a signature to our gateway](https://docs.payroc.com/knowledge/basic-concepts/signature-capture).
	CardholderSignature *string                `json:"cardholderSignature,omitempty" url:"cardholderSignature,omitempty"`
	EbtDetails          *EbtDetailsWithVoucher `json:"ebtDetails,omitempty" url:"ebtDetails,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IccCardDetails) GetDowngradeTo() *IccCardDetailsDowngradeTo {
	if i == nil {
		return nil
	}
	return i.DowngradeTo
}

func (i *IccCardDetails) GetDevice() *EncryptionCapableDevice {
	if i == nil {
		return nil
	}
	return i.Device
}

func (i *IccCardDetails) GetIccData() string {
	if i == nil {
		return ""
	}
	return i.IccData
}

func (i *IccCardDetails) GetFirstDigitOfPan() *string {
	if i == nil {
		return nil
	}
	return i.FirstDigitOfPan
}

func (i *IccCardDetails) GetCardholderSignature() *string {
	if i == nil {
		return nil
	}
	return i.CardholderSignature
}

func (i *IccCardDetails) GetEbtDetails() *EbtDetailsWithVoucher {
	if i == nil {
		return nil
	}
	return i.EbtDetails
}

func (i *IccCardDetails) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IccCardDetails) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetDowngradeTo sets the DowngradeTo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IccCardDetails) SetDowngradeTo(downgradeTo *IccCardDetailsDowngradeTo) {
	i.DowngradeTo = downgradeTo
	i.require(iccCardDetailsFieldDowngradeTo)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IccCardDetails) SetDevice(device *EncryptionCapableDevice) {
	i.Device = device
	i.require(iccCardDetailsFieldDevice)
}

// SetIccData sets the IccData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IccCardDetails) SetIccData(iccData string) {
	i.IccData = iccData
	i.require(iccCardDetailsFieldIccData)
}

// SetFirstDigitOfPan sets the FirstDigitOfPan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IccCardDetails) SetFirstDigitOfPan(firstDigitOfPan *string) {
	i.FirstDigitOfPan = firstDigitOfPan
	i.require(iccCardDetailsFieldFirstDigitOfPan)
}

// SetCardholderSignature sets the CardholderSignature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IccCardDetails) SetCardholderSignature(cardholderSignature *string) {
	i.CardholderSignature = cardholderSignature
	i.require(iccCardDetailsFieldCardholderSignature)
}

// SetEbtDetails sets the EbtDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IccCardDetails) SetEbtDetails(ebtDetails *EbtDetailsWithVoucher) {
	i.EbtDetails = ebtDetails
	i.require(iccCardDetailsFieldEbtDetails)
}

func (i *IccCardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler IccCardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IccCardDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IccCardDetails) MarshalJSON() ([]byte, error) {
	type embed IccCardDetails
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IccCardDetails) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// If an offline transaction is not approved using the initial entry method, reprocess the transaction using a downgraded entry method.
// For example, an Integrated Circuit Card (ICC) transaction can be downgraded to a swiped transaction or a keyed transaction.
type IccCardDetailsDowngradeTo string

const (
	IccCardDetailsDowngradeToKeyed  IccCardDetailsDowngradeTo = "keyed"
	IccCardDetailsDowngradeToSwiped IccCardDetailsDowngradeTo = "swiped"
)

func NewIccCardDetailsDowngradeToFromString(s string) (IccCardDetailsDowngradeTo, error) {
	switch s {
	case "keyed":
		return IccCardDetailsDowngradeToKeyed, nil
	case "swiped":
		return IccCardDetailsDowngradeToSwiped, nil
	}
	var t IccCardDetailsDowngradeTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IccCardDetailsDowngradeTo) Ptr() *IccCardDetailsDowngradeTo {
	return &i
}

var (
	identifierFieldType  = big.NewInt(1 << 0)
	identifierFieldValue = big.NewInt(1 << 1)
)

type Identifier struct {
	// Type of ID provided to verify identity.
	Type IdentifierType `json:"type" url:"type"`
	// Social Security Number (SSN) or Social Insurance Number (SIN).
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Identifier) GetType() IdentifierType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *Identifier) GetValue() string {
	if i == nil {
		return ""
	}
	return i.Value
}

func (i *Identifier) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Identifier) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Identifier) SetType(type_ IdentifierType) {
	i.Type = type_
	i.require(identifierFieldType)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Identifier) SetValue(value string) {
	i.Value = value
	i.require(identifierFieldValue)
}

func (i *Identifier) UnmarshalJSON(data []byte) error {
	type unmarshaler Identifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Identifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Identifier) MarshalJSON() ([]byte, error) {
	type embed Identifier
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *Identifier) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Type of ID provided to verify identity.
type IdentifierType string

const (
	IdentifierTypeNationalId IdentifierType = "nationalId"
)

func NewIdentifierTypeFromString(s string) (IdentifierType, error) {
	switch s {
	case "nationalId":
		return IdentifierTypeNationalId, nil
	}
	var t IdentifierType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IdentifierType) Ptr() *IdentifierType {
	return &i
}

// Inform the payfac what to do with the specified funds. **
var (
	instructionFieldInstructionId    = big.NewInt(1 << 0)
	instructionFieldCreatedDate      = big.NewInt(1 << 1)
	instructionFieldLastModifiedDate = big.NewInt(1 << 2)
	instructionFieldStatus           = big.NewInt(1 << 3)
	instructionFieldMerchants        = big.NewInt(1 << 4)
	instructionFieldMetadata         = big.NewInt(1 << 5)
)

type Instruction struct {
	// Unique identifier that we assigned to the funding instruction.
	InstructionId *int `json:"instructionId,omitempty" url:"instructionId,omitempty"`
	// Date that we created the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.
	CreatedDate *string `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date of the most recent change to the funding instruction. The date format follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.
	LastModifiedDate *string `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	// Status of the funding instruction. Our gateway returns one of the following values:
	// - `accepted` - We have received the funding instruction but have not yet reviewed it.
	// - `pending` - We have received the funding instruction and we are reviewing it.
	// - `completed` - We have reviewed and processed the funding instruction.
	Status *InstructionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Array of merchants objects. Each object specifies the merchant whose funding balance we distribute and who you want to send the funds to.
	Merchants []*InstructionMerchantsItem `json:"merchants,omitempty" url:"merchants,omitempty"`
	// [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Instruction) GetInstructionId() *int {
	if i == nil {
		return nil
	}
	return i.InstructionId
}

func (i *Instruction) GetCreatedDate() *string {
	if i == nil {
		return nil
	}
	return i.CreatedDate
}

func (i *Instruction) GetLastModifiedDate() *string {
	if i == nil {
		return nil
	}
	return i.LastModifiedDate
}

func (i *Instruction) GetStatus() *InstructionStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *Instruction) GetMerchants() []*InstructionMerchantsItem {
	if i == nil {
		return nil
	}
	return i.Merchants
}

func (i *Instruction) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *Instruction) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Instruction) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetInstructionId sets the InstructionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Instruction) SetInstructionId(instructionId *int) {
	i.InstructionId = instructionId
	i.require(instructionFieldInstructionId)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Instruction) SetCreatedDate(createdDate *string) {
	i.CreatedDate = createdDate
	i.require(instructionFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Instruction) SetLastModifiedDate(lastModifiedDate *string) {
	i.LastModifiedDate = lastModifiedDate
	i.require(instructionFieldLastModifiedDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Instruction) SetStatus(status *InstructionStatus) {
	i.Status = status
	i.require(instructionFieldStatus)
}

// SetMerchants sets the Merchants field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Instruction) SetMerchants(merchants []*InstructionMerchantsItem) {
	i.Merchants = merchants
	i.require(instructionFieldMerchants)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *Instruction) SetMetadata(metadata map[string]string) {
	i.Metadata = metadata
	i.require(instructionFieldMetadata)
}

func (i *Instruction) UnmarshalJSON(data []byte) error {
	type unmarshaler Instruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Instruction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Instruction) MarshalJSON() ([]byte, error) {
	type embed Instruction
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *Instruction) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Instruction indicating which recipients should receive funding from the specific merchant balance.
var (
	instructionMerchantsItemFieldMerchantId = big.NewInt(1 << 0)
	instructionMerchantsItemFieldRecipients = big.NewInt(1 << 1)
	instructionMerchantsItemFieldLink       = big.NewInt(1 << 2)
)

type InstructionMerchantsItem struct {
	// Unique identifier that the processor assigned to the merchant.
	MerchantId string `json:"merchantId" url:"merchantId"`
	// Array of recipients objects. Each object contains information about the funding account and the amount of funds we send to the funding account.
	Recipients []*InstructionMerchantsItemRecipientsItem `json:"recipients" url:"recipients"`
	// Object that contains HATEOAS links for the resource.
	Link *InstructionMerchantsItemLink `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InstructionMerchantsItem) GetMerchantId() string {
	if i == nil {
		return ""
	}
	return i.MerchantId
}

func (i *InstructionMerchantsItem) GetRecipients() []*InstructionMerchantsItemRecipientsItem {
	if i == nil {
		return nil
	}
	return i.Recipients
}

func (i *InstructionMerchantsItem) GetLink() *InstructionMerchantsItemLink {
	if i == nil {
		return nil
	}
	return i.Link
}

func (i *InstructionMerchantsItem) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InstructionMerchantsItem) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetMerchantId sets the MerchantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItem) SetMerchantId(merchantId string) {
	i.MerchantId = merchantId
	i.require(instructionMerchantsItemFieldMerchantId)
}

// SetRecipients sets the Recipients field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItem) SetRecipients(recipients []*InstructionMerchantsItemRecipientsItem) {
	i.Recipients = recipients
	i.require(instructionMerchantsItemFieldRecipients)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItem) SetLink(link *InstructionMerchantsItemLink) {
	i.Link = link
	i.require(instructionMerchantsItemFieldLink)
}

func (i *InstructionMerchantsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler InstructionMerchantsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InstructionMerchantsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InstructionMerchantsItem) MarshalJSON() ([]byte, error) {
	type embed InstructionMerchantsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InstructionMerchantsItem) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains HATEOAS links for the resource.
var (
	instructionMerchantsItemLinkFieldRel    = big.NewInt(1 << 0)
	instructionMerchantsItemLinkFieldMethod = big.NewInt(1 << 1)
	instructionMerchantsItemLinkFieldHref   = big.NewInt(1 << 2)
)

type InstructionMerchantsItemLink struct {
	// Indicates the relationship between the current resource and the target resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// HTTP method that you need to use with the target resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`
	// URL of the target resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InstructionMerchantsItemLink) GetRel() *string {
	if i == nil {
		return nil
	}
	return i.Rel
}

func (i *InstructionMerchantsItemLink) GetMethod() *string {
	if i == nil {
		return nil
	}
	return i.Method
}

func (i *InstructionMerchantsItemLink) GetHref() *string {
	if i == nil {
		return nil
	}
	return i.Href
}

func (i *InstructionMerchantsItemLink) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InstructionMerchantsItemLink) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemLink) SetRel(rel *string) {
	i.Rel = rel
	i.require(instructionMerchantsItemLinkFieldRel)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemLink) SetMethod(method *string) {
	i.Method = method
	i.require(instructionMerchantsItemLinkFieldMethod)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemLink) SetHref(href *string) {
	i.Href = href
	i.require(instructionMerchantsItemLinkFieldHref)
}

func (i *InstructionMerchantsItemLink) UnmarshalJSON(data []byte) error {
	type unmarshaler InstructionMerchantsItemLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InstructionMerchantsItemLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InstructionMerchantsItemLink) MarshalJSON() ([]byte, error) {
	type embed InstructionMerchantsItemLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InstructionMerchantsItemLink) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains information about the target funding account.
var (
	instructionMerchantsItemRecipientsItemFieldFundingAccountId = big.NewInt(1 << 0)
	instructionMerchantsItemRecipientsItemFieldPaymentMethod    = big.NewInt(1 << 1)
	instructionMerchantsItemRecipientsItemFieldAmount           = big.NewInt(1 << 2)
	instructionMerchantsItemRecipientsItemFieldStatus           = big.NewInt(1 << 3)
	instructionMerchantsItemRecipientsItemFieldMetadata         = big.NewInt(1 << 4)
	instructionMerchantsItemRecipientsItemFieldLink             = big.NewInt(1 << 5)
)

type InstructionMerchantsItemRecipientsItem struct {
	// Unique identifier that we assigned to the funding account.
	FundingAccountId int `json:"fundingAccountId" url:"fundingAccountId"`
	// Payment method that we use to send funds to the funding account.
	PaymentMethod InstructionMerchantsItemRecipientsItemPaymentMethod `json:"paymentMethod" url:"paymentMethod"`
	// Object that contains information about the funds that we send to the funding account.
	Amount *InstructionMerchantsItemRecipientsItemAmount `json:"amount" url:"amount"`
	// Status of the individual payment instruction. Our gateway returns one of the following values:
	// -	`accepted` - We received the payment instruction, but we haven't reviewed it.
	// -	`pending` - We are reviewing the payment instruction.
	// -	`released` - We approved the payment instruction.
	// -	`funded` - We sent the funds to the funding account by ACH.
	// -	`failed` - The ACH payment to the funding account failed.
	// -	`rejected` - We reviewed the payment instruction and rejected it.
	// - `onHold` - We have placed the payment instruction on hold.
	Status *InstructionMerchantsItemRecipientsItemStatus `json:"status,omitempty" url:"status,omitempty"`
	// [Metadata](https://docs.payroc.com/api/metadata) object you can use to include custom data with your request.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Object that contains HATEOAS links for the resource.
	Link *InstructionMerchantsItemRecipientsItemLink `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InstructionMerchantsItemRecipientsItem) GetFundingAccountId() int {
	if i == nil {
		return 0
	}
	return i.FundingAccountId
}

func (i *InstructionMerchantsItemRecipientsItem) GetPaymentMethod() InstructionMerchantsItemRecipientsItemPaymentMethod {
	if i == nil {
		return ""
	}
	return i.PaymentMethod
}

func (i *InstructionMerchantsItemRecipientsItem) GetAmount() *InstructionMerchantsItemRecipientsItemAmount {
	if i == nil {
		return nil
	}
	return i.Amount
}

func (i *InstructionMerchantsItemRecipientsItem) GetStatus() *InstructionMerchantsItemRecipientsItemStatus {
	if i == nil {
		return nil
	}
	return i.Status
}

func (i *InstructionMerchantsItemRecipientsItem) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InstructionMerchantsItemRecipientsItem) GetLink() *InstructionMerchantsItemRecipientsItemLink {
	if i == nil {
		return nil
	}
	return i.Link
}

func (i *InstructionMerchantsItemRecipientsItem) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InstructionMerchantsItemRecipientsItem) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetFundingAccountId sets the FundingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItem) SetFundingAccountId(fundingAccountId int) {
	i.FundingAccountId = fundingAccountId
	i.require(instructionMerchantsItemRecipientsItemFieldFundingAccountId)
}

// SetPaymentMethod sets the PaymentMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItem) SetPaymentMethod(paymentMethod InstructionMerchantsItemRecipientsItemPaymentMethod) {
	i.PaymentMethod = paymentMethod
	i.require(instructionMerchantsItemRecipientsItemFieldPaymentMethod)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItem) SetAmount(amount *InstructionMerchantsItemRecipientsItemAmount) {
	i.Amount = amount
	i.require(instructionMerchantsItemRecipientsItemFieldAmount)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItem) SetStatus(status *InstructionMerchantsItemRecipientsItemStatus) {
	i.Status = status
	i.require(instructionMerchantsItemRecipientsItemFieldStatus)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItem) SetMetadata(metadata map[string]string) {
	i.Metadata = metadata
	i.require(instructionMerchantsItemRecipientsItemFieldMetadata)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItem) SetLink(link *InstructionMerchantsItemRecipientsItemLink) {
	i.Link = link
	i.require(instructionMerchantsItemRecipientsItemFieldLink)
}

func (i *InstructionMerchantsItemRecipientsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler InstructionMerchantsItemRecipientsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InstructionMerchantsItemRecipientsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InstructionMerchantsItemRecipientsItem) MarshalJSON() ([]byte, error) {
	type embed InstructionMerchantsItemRecipientsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InstructionMerchantsItemRecipientsItem) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains information about the funds that we send to the funding account.
var (
	instructionMerchantsItemRecipientsItemAmountFieldValue    = big.NewInt(1 << 0)
	instructionMerchantsItemRecipientsItemAmountFieldCurrency = big.NewInt(1 << 1)
)

type InstructionMerchantsItemRecipientsItemAmount struct {
	// Amount of funds in the currency's lowest denomination, for example, cents.
	Value int `json:"value" url:"value"`
	// Currency of the value parameter.
	Currency *InstructionMerchantsItemRecipientsItemAmountCurrency `json:"currency,omitempty" url:"currency,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InstructionMerchantsItemRecipientsItemAmount) GetValue() int {
	if i == nil {
		return 0
	}
	return i.Value
}

func (i *InstructionMerchantsItemRecipientsItemAmount) GetCurrency() *InstructionMerchantsItemRecipientsItemAmountCurrency {
	if i == nil {
		return nil
	}
	return i.Currency
}

func (i *InstructionMerchantsItemRecipientsItemAmount) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InstructionMerchantsItemRecipientsItemAmount) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItemAmount) SetValue(value int) {
	i.Value = value
	i.require(instructionMerchantsItemRecipientsItemAmountFieldValue)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItemAmount) SetCurrency(currency *InstructionMerchantsItemRecipientsItemAmountCurrency) {
	i.Currency = currency
	i.require(instructionMerchantsItemRecipientsItemAmountFieldCurrency)
}

func (i *InstructionMerchantsItemRecipientsItemAmount) UnmarshalJSON(data []byte) error {
	type unmarshaler InstructionMerchantsItemRecipientsItemAmount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InstructionMerchantsItemRecipientsItemAmount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InstructionMerchantsItemRecipientsItemAmount) MarshalJSON() ([]byte, error) {
	type embed InstructionMerchantsItemRecipientsItemAmount
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InstructionMerchantsItemRecipientsItemAmount) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Currency of the value parameter.
type InstructionMerchantsItemRecipientsItemAmountCurrency string

const (
	InstructionMerchantsItemRecipientsItemAmountCurrencyUsd InstructionMerchantsItemRecipientsItemAmountCurrency = "USD"
)

func NewInstructionMerchantsItemRecipientsItemAmountCurrencyFromString(s string) (InstructionMerchantsItemRecipientsItemAmountCurrency, error) {
	switch s {
	case "USD":
		return InstructionMerchantsItemRecipientsItemAmountCurrencyUsd, nil
	}
	var t InstructionMerchantsItemRecipientsItemAmountCurrency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InstructionMerchantsItemRecipientsItemAmountCurrency) Ptr() *InstructionMerchantsItemRecipientsItemAmountCurrency {
	return &i
}

// Object that contains HATEOAS links for the resource.
var (
	instructionMerchantsItemRecipientsItemLinkFieldRel    = big.NewInt(1 << 0)
	instructionMerchantsItemRecipientsItemLinkFieldMethod = big.NewInt(1 << 1)
	instructionMerchantsItemRecipientsItemLinkFieldHref   = big.NewInt(1 << 2)
)

type InstructionMerchantsItemRecipientsItemLink struct {
	// Indicates the relationship between the current resource and the target resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// HTTP method that you need to use with the target resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`
	// URL of the target resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InstructionMerchantsItemRecipientsItemLink) GetRel() *string {
	if i == nil {
		return nil
	}
	return i.Rel
}

func (i *InstructionMerchantsItemRecipientsItemLink) GetMethod() *string {
	if i == nil {
		return nil
	}
	return i.Method
}

func (i *InstructionMerchantsItemRecipientsItemLink) GetHref() *string {
	if i == nil {
		return nil
	}
	return i.Href
}

func (i *InstructionMerchantsItemRecipientsItemLink) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InstructionMerchantsItemRecipientsItemLink) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItemLink) SetRel(rel *string) {
	i.Rel = rel
	i.require(instructionMerchantsItemRecipientsItemLinkFieldRel)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItemLink) SetMethod(method *string) {
	i.Method = method
	i.require(instructionMerchantsItemRecipientsItemLinkFieldMethod)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InstructionMerchantsItemRecipientsItemLink) SetHref(href *string) {
	i.Href = href
	i.require(instructionMerchantsItemRecipientsItemLinkFieldHref)
}

func (i *InstructionMerchantsItemRecipientsItemLink) UnmarshalJSON(data []byte) error {
	type unmarshaler InstructionMerchantsItemRecipientsItemLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InstructionMerchantsItemRecipientsItemLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InstructionMerchantsItemRecipientsItemLink) MarshalJSON() ([]byte, error) {
	type embed InstructionMerchantsItemRecipientsItemLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InstructionMerchantsItemRecipientsItemLink) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Payment method that we use to send funds to the funding account.
type InstructionMerchantsItemRecipientsItemPaymentMethod string

const (
	InstructionMerchantsItemRecipientsItemPaymentMethodAch InstructionMerchantsItemRecipientsItemPaymentMethod = "ACH"
)

func NewInstructionMerchantsItemRecipientsItemPaymentMethodFromString(s string) (InstructionMerchantsItemRecipientsItemPaymentMethod, error) {
	switch s {
	case "ACH":
		return InstructionMerchantsItemRecipientsItemPaymentMethodAch, nil
	}
	var t InstructionMerchantsItemRecipientsItemPaymentMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InstructionMerchantsItemRecipientsItemPaymentMethod) Ptr() *InstructionMerchantsItemRecipientsItemPaymentMethod {
	return &i
}

// Status of the individual payment instruction. Our gateway returns one of the following values:
// -	`accepted` - We received the payment instruction, but we haven't reviewed it.
// -	`pending` - We are reviewing the payment instruction.
// -	`released` - We approved the payment instruction.
// -	`funded` - We sent the funds to the funding account by ACH.
// -	`failed` - The ACH payment to the funding account failed.
// -	`rejected` - We reviewed the payment instruction and rejected it.
// - `onHold` - We have placed the payment instruction on hold.
type InstructionMerchantsItemRecipientsItemStatus string

const (
	InstructionMerchantsItemRecipientsItemStatusAccepted InstructionMerchantsItemRecipientsItemStatus = "accepted"
	InstructionMerchantsItemRecipientsItemStatusPending  InstructionMerchantsItemRecipientsItemStatus = "pending"
	InstructionMerchantsItemRecipientsItemStatusReleased InstructionMerchantsItemRecipientsItemStatus = "released"
	InstructionMerchantsItemRecipientsItemStatusFunded   InstructionMerchantsItemRecipientsItemStatus = "funded"
	InstructionMerchantsItemRecipientsItemStatusFailed   InstructionMerchantsItemRecipientsItemStatus = "failed"
	InstructionMerchantsItemRecipientsItemStatusRejected InstructionMerchantsItemRecipientsItemStatus = "rejected"
	InstructionMerchantsItemRecipientsItemStatusOnHold   InstructionMerchantsItemRecipientsItemStatus = "onHold"
)

func NewInstructionMerchantsItemRecipientsItemStatusFromString(s string) (InstructionMerchantsItemRecipientsItemStatus, error) {
	switch s {
	case "accepted":
		return InstructionMerchantsItemRecipientsItemStatusAccepted, nil
	case "pending":
		return InstructionMerchantsItemRecipientsItemStatusPending, nil
	case "released":
		return InstructionMerchantsItemRecipientsItemStatusReleased, nil
	case "funded":
		return InstructionMerchantsItemRecipientsItemStatusFunded, nil
	case "failed":
		return InstructionMerchantsItemRecipientsItemStatusFailed, nil
	case "rejected":
		return InstructionMerchantsItemRecipientsItemStatusRejected, nil
	case "onHold":
		return InstructionMerchantsItemRecipientsItemStatusOnHold, nil
	}
	var t InstructionMerchantsItemRecipientsItemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InstructionMerchantsItemRecipientsItemStatus) Ptr() *InstructionMerchantsItemRecipientsItemStatus {
	return &i
}

// Status of the funding instruction. Our gateway returns one of the following values:
// - `accepted` - We have received the funding instruction but have not yet reviewed it.
// - `pending` - We have received the funding instruction and we are reviewing it.
// - `completed` - We have reviewed and processed the funding instruction.
type InstructionStatus string

const (
	InstructionStatusAccepted  InstructionStatus = "accepted"
	InstructionStatusPending   InstructionStatus = "pending"
	InstructionStatusCompleted InstructionStatus = "completed"
)

func NewInstructionStatusFromString(s string) (InstructionStatus, error) {
	switch s {
	case "accepted":
		return InstructionStatusAccepted, nil
	case "pending":
		return InstructionStatusPending, nil
	case "completed":
		return InstructionStatusCompleted, nil
	}
	var t InstructionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InstructionStatus) Ptr() *InstructionStatus {
	return &i
}

// Object that contains information about Interchange Plus.
var (
	interchangePlusFieldFees = big.NewInt(1 << 0)
)

type InterchangePlus struct {
	// Object that contains information about the fees.
	Fees *InterchangePlusFees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlus) GetFees() *InterchangePlusFees {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InterchangePlus) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlus) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlus) SetFees(fees *InterchangePlusFees) {
	i.Fees = fees
	i.require(interchangePlusFieldFees)
}

func (i *InterchangePlus) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlus) MarshalJSON() ([]byte, error) {
	type embed InterchangePlus
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlus) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	interchangePlusAmexDirectFieldTransaction = big.NewInt(1 << 0)
)

type InterchangePlusAmexDirect struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusAmexDirect) GetTransaction() Amount {
	if i == nil {
		return 0
	}
	return i.Transaction
}

func (i *InterchangePlusAmexDirect) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusAmexDirect) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusAmexDirect) SetTransaction(transaction Amount) {
	i.Transaction = transaction
	i.require(interchangePlusAmexDirectFieldTransaction)
}

func (i *InterchangePlusAmexDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusAmexDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusAmexDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusAmexDirect) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusAmexDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusAmexDirect) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	interchangePlusAmexOptBlueFieldVolume      = big.NewInt(1 << 0)
	interchangePlusAmexOptBlueFieldTransaction = big.NewInt(1 << 1)
)

type InterchangePlusAmexOptBlue struct {
	// Percentage of the total transaction amount that the processor charges the merchant.
	Volume Percentage `json:"volume" url:"volume"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusAmexOptBlue) GetVolume() Percentage {
	if i == nil {
		return 0
	}
	return i.Volume
}

func (i *InterchangePlusAmexOptBlue) GetTransaction() Amount {
	if i == nil {
		return 0
	}
	return i.Transaction
}

func (i *InterchangePlusAmexOptBlue) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusAmexOptBlue) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetVolume sets the Volume field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusAmexOptBlue) SetVolume(volume Percentage) {
	i.Volume = volume
	i.require(interchangePlusAmexOptBlueFieldVolume)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusAmexOptBlue) SetTransaction(transaction Amount) {
	i.Transaction = transaction
	i.require(interchangePlusAmexOptBlueFieldTransaction)
}

func (i *InterchangePlusAmexOptBlue) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusAmexOptBlue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusAmexOptBlue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusAmexOptBlue) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusAmexOptBlue
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusAmexOptBlue) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains information about the fees.
var (
	interchangePlusFeesFieldMastercardVisaDiscover     = big.NewInt(1 << 0)
	interchangePlusFeesFieldAmex                       = big.NewInt(1 << 1)
	interchangePlusFeesFieldPinDebit                   = big.NewInt(1 << 2)
	interchangePlusFeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	interchangePlusFeesFieldEnhancedInterchange        = big.NewInt(1 << 4)
	interchangePlusFeesFieldSpecialityCards            = big.NewInt(1 << 5)
)

type InterchangePlusFees struct {
	// Object that contains the fees for Mastercard, Visa, and Discover transactions.
	MastercardVisaDiscover *ProcessorFee `json:"mastercardVisaDiscover" url:"mastercardVisaDiscover"`
	// Polymorphic object that contains fees for American Express transactions.
	//
	// The value of the type field determines which variant you should use:
	// -	`optBlue` - Amex OptBlue pricing program.
	// -	`direct` - Amex Direct pricing program.
	Amex                       *InterchangePlusFeesAmex    `json:"amex,omitempty" url:"amex,omitempty"`
	PinDebit                   *PinDebit                   `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	EnhancedInterchange        *EnhancedInterchange        `json:"enhancedInterchange,omitempty" url:"enhancedInterchange,omitempty"`
	SpecialityCards            *SpecialityCards            `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusFees) GetMastercardVisaDiscover() *ProcessorFee {
	if i == nil {
		return nil
	}
	return i.MastercardVisaDiscover
}

func (i *InterchangePlusFees) GetAmex() *InterchangePlusFeesAmex {
	if i == nil {
		return nil
	}
	return i.Amex
}

func (i *InterchangePlusFees) GetPinDebit() *PinDebit {
	if i == nil {
		return nil
	}
	return i.PinDebit
}

func (i *InterchangePlusFees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if i == nil {
		return nil
	}
	return i.ElectronicBenefitsTransfer
}

func (i *InterchangePlusFees) GetEnhancedInterchange() *EnhancedInterchange {
	if i == nil {
		return nil
	}
	return i.EnhancedInterchange
}

func (i *InterchangePlusFees) GetSpecialityCards() *SpecialityCards {
	if i == nil {
		return nil
	}
	return i.SpecialityCards
}

func (i *InterchangePlusFees) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusFees) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetMastercardVisaDiscover sets the MastercardVisaDiscover field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusFees) SetMastercardVisaDiscover(mastercardVisaDiscover *ProcessorFee) {
	i.MastercardVisaDiscover = mastercardVisaDiscover
	i.require(interchangePlusFeesFieldMastercardVisaDiscover)
}

// SetAmex sets the Amex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusFees) SetAmex(amex *InterchangePlusFeesAmex) {
	i.Amex = amex
	i.require(interchangePlusFeesFieldAmex)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusFees) SetPinDebit(pinDebit *PinDebit) {
	i.PinDebit = pinDebit
	i.require(interchangePlusFeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusFees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	i.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	i.require(interchangePlusFeesFieldElectronicBenefitsTransfer)
}

// SetEnhancedInterchange sets the EnhancedInterchange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusFees) SetEnhancedInterchange(enhancedInterchange *EnhancedInterchange) {
	i.EnhancedInterchange = enhancedInterchange
	i.require(interchangePlusFeesFieldEnhancedInterchange)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusFees) SetSpecialityCards(specialityCards *SpecialityCards) {
	i.SpecialityCards = specialityCards
	i.require(interchangePlusFeesFieldSpecialityCards)
}

func (i *InterchangePlusFees) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusFees) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusFees) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Polymorphic object that contains fees for American Express transactions.
//
// The value of the type field determines which variant you should use:
// -	`optBlue` - Amex OptBlue pricing program.
// -	`direct` - Amex Direct pricing program.
type InterchangePlusFeesAmex struct {
	Type    string
	OptBlue *InterchangePlusAmexOptBlue
	Direct  *InterchangePlusAmexDirect
}

func (i *InterchangePlusFeesAmex) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InterchangePlusFeesAmex) GetOptBlue() *InterchangePlusAmexOptBlue {
	if i == nil {
		return nil
	}
	return i.OptBlue
}

func (i *InterchangePlusFeesAmex) GetDirect() *InterchangePlusAmexDirect {
	if i == nil {
		return nil
	}
	return i.Direct
}

func (i *InterchangePlusFeesAmex) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "optBlue":
		value := new(InterchangePlusAmexOptBlue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.OptBlue = value
	case "direct":
		value := new(InterchangePlusAmexDirect)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Direct = value
	}
	return nil
}

func (i InterchangePlusFeesAmex) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.OptBlue != nil {
		return internal.MarshalJSONWithExtraProperty(i.OptBlue, "type", "optBlue")
	}
	if i.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(i.Direct, "type", "direct")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InterchangePlusFeesAmexVisitor interface {
	VisitOptBlue(*InterchangePlusAmexOptBlue) error
	VisitDirect(*InterchangePlusAmexDirect) error
}

func (i *InterchangePlusFeesAmex) Accept(visitor InterchangePlusFeesAmexVisitor) error {
	if i.OptBlue != nil {
		return visitor.VisitOptBlue(i.OptBlue)
	}
	if i.Direct != nil {
		return visitor.VisitDirect(i.Direct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InterchangePlusFeesAmex) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.OptBlue != nil {
		fields = append(fields, "optBlue")
	}
	if i.Direct != nil {
		fields = append(fields, "direct")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

// Object that contains information about Interchange Plus Plus.
var (
	interchangePlusPlusFieldFees = big.NewInt(1 << 0)
)

type InterchangePlusPlus struct {
	// Object that contains information about the fees.
	Fees *InterchangePlusPlusFees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusPlus) GetFees() *InterchangePlusPlusFees {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InterchangePlusPlus) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusPlus) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlus) SetFees(fees *InterchangePlusPlusFees) {
	i.Fees = fees
	i.require(interchangePlusPlusFieldFees)
}

func (i *InterchangePlusPlus) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusPlus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusPlus(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusPlus) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusPlus
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusPlus) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	interchangePlusPlusAmexDirectFieldTransaction = big.NewInt(1 << 0)
)

type InterchangePlusPlusAmexDirect struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusPlusAmexDirect) GetTransaction() Amount {
	if i == nil {
		return 0
	}
	return i.Transaction
}

func (i *InterchangePlusPlusAmexDirect) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusPlusAmexDirect) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusAmexDirect) SetTransaction(transaction Amount) {
	i.Transaction = transaction
	i.require(interchangePlusPlusAmexDirectFieldTransaction)
}

func (i *InterchangePlusPlusAmexDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusPlusAmexDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusPlusAmexDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusPlusAmexDirect) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusPlusAmexDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusPlusAmexDirect) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	interchangePlusPlusAmexOptBlueFieldQualifiedRate = big.NewInt(1 << 0)
	interchangePlusPlusAmexOptBlueFieldMidQualRate   = big.NewInt(1 << 1)
	interchangePlusPlusAmexOptBlueFieldNonQualRate   = big.NewInt(1 << 2)
)

type InterchangePlusPlusAmexOptBlue struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusPlusAmexOptBlue) GetQualifiedRate() *ProcessorFee {
	if i == nil {
		return nil
	}
	return i.QualifiedRate
}

func (i *InterchangePlusPlusAmexOptBlue) GetMidQualRate() *ProcessorFee {
	if i == nil {
		return nil
	}
	return i.MidQualRate
}

func (i *InterchangePlusPlusAmexOptBlue) GetNonQualRate() *ProcessorFee {
	if i == nil {
		return nil
	}
	return i.NonQualRate
}

func (i *InterchangePlusPlusAmexOptBlue) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusPlusAmexOptBlue) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusAmexOptBlue) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	i.QualifiedRate = qualifiedRate
	i.require(interchangePlusPlusAmexOptBlueFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusAmexOptBlue) SetMidQualRate(midQualRate *ProcessorFee) {
	i.MidQualRate = midQualRate
	i.require(interchangePlusPlusAmexOptBlueFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusAmexOptBlue) SetNonQualRate(nonQualRate *ProcessorFee) {
	i.NonQualRate = nonQualRate
	i.require(interchangePlusPlusAmexOptBlueFieldNonQualRate)
}

func (i *InterchangePlusPlusAmexOptBlue) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusPlusAmexOptBlue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusPlusAmexOptBlue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusPlusAmexOptBlue) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusPlusAmexOptBlue
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusPlusAmexOptBlue) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains information about the fees.
var (
	interchangePlusPlusFeesFieldMastercardVisaDiscover     = big.NewInt(1 << 0)
	interchangePlusPlusFeesFieldAmex                       = big.NewInt(1 << 1)
	interchangePlusPlusFeesFieldPinDebit                   = big.NewInt(1 << 2)
	interchangePlusPlusFeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	interchangePlusPlusFeesFieldEnhancedInterchange        = big.NewInt(1 << 4)
	interchangePlusPlusFeesFieldSpecialityCards            = big.NewInt(1 << 5)
)

type InterchangePlusPlusFees struct {
	// Object that contains the fees for Mastercard, Visa, and Discover transactions.
	MastercardVisaDiscover *QualRates `json:"mastercardVisaDiscover" url:"mastercardVisaDiscover"`
	// Polymorphic object that contains fees for American Express transactions.
	//
	// The value of the type field determines which variant you should use:
	// -	`optBlue` - Amex OptBlue pricing program.
	// -	`direct` - Amex Direct pricing program.
	Amex                       *InterchangePlusPlusFeesAmex `json:"amex,omitempty" url:"amex,omitempty"`
	PinDebit                   *PinDebit                    `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer  `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	EnhancedInterchange        *EnhancedInterchange         `json:"enhancedInterchange,omitempty" url:"enhancedInterchange,omitempty"`
	SpecialityCards            *SpecialityCards             `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusPlusFees) GetMastercardVisaDiscover() *QualRates {
	if i == nil {
		return nil
	}
	return i.MastercardVisaDiscover
}

func (i *InterchangePlusPlusFees) GetAmex() *InterchangePlusPlusFeesAmex {
	if i == nil {
		return nil
	}
	return i.Amex
}

func (i *InterchangePlusPlusFees) GetPinDebit() *PinDebit {
	if i == nil {
		return nil
	}
	return i.PinDebit
}

func (i *InterchangePlusPlusFees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if i == nil {
		return nil
	}
	return i.ElectronicBenefitsTransfer
}

func (i *InterchangePlusPlusFees) GetEnhancedInterchange() *EnhancedInterchange {
	if i == nil {
		return nil
	}
	return i.EnhancedInterchange
}

func (i *InterchangePlusPlusFees) GetSpecialityCards() *SpecialityCards {
	if i == nil {
		return nil
	}
	return i.SpecialityCards
}

func (i *InterchangePlusPlusFees) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusPlusFees) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetMastercardVisaDiscover sets the MastercardVisaDiscover field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusFees) SetMastercardVisaDiscover(mastercardVisaDiscover *QualRates) {
	i.MastercardVisaDiscover = mastercardVisaDiscover
	i.require(interchangePlusPlusFeesFieldMastercardVisaDiscover)
}

// SetAmex sets the Amex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusFees) SetAmex(amex *InterchangePlusPlusFeesAmex) {
	i.Amex = amex
	i.require(interchangePlusPlusFeesFieldAmex)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusFees) SetPinDebit(pinDebit *PinDebit) {
	i.PinDebit = pinDebit
	i.require(interchangePlusPlusFeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusFees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	i.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	i.require(interchangePlusPlusFeesFieldElectronicBenefitsTransfer)
}

// SetEnhancedInterchange sets the EnhancedInterchange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusFees) SetEnhancedInterchange(enhancedInterchange *EnhancedInterchange) {
	i.EnhancedInterchange = enhancedInterchange
	i.require(interchangePlusPlusFeesFieldEnhancedInterchange)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusPlusFees) SetSpecialityCards(specialityCards *SpecialityCards) {
	i.SpecialityCards = specialityCards
	i.require(interchangePlusPlusFeesFieldSpecialityCards)
}

func (i *InterchangePlusPlusFees) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusPlusFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusPlusFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusPlusFees) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusPlusFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusPlusFees) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Polymorphic object that contains fees for American Express transactions.
//
// The value of the type field determines which variant you should use:
// -	`optBlue` - Amex OptBlue pricing program.
// -	`direct` - Amex Direct pricing program.
type InterchangePlusPlusFeesAmex struct {
	Type    string
	OptBlue *InterchangePlusPlusAmexOptBlue
	Direct  *InterchangePlusPlusAmexDirect
}

func (i *InterchangePlusPlusFeesAmex) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InterchangePlusPlusFeesAmex) GetOptBlue() *InterchangePlusPlusAmexOptBlue {
	if i == nil {
		return nil
	}
	return i.OptBlue
}

func (i *InterchangePlusPlusFeesAmex) GetDirect() *InterchangePlusPlusAmexDirect {
	if i == nil {
		return nil
	}
	return i.Direct
}

func (i *InterchangePlusPlusFeesAmex) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "optBlue":
		value := new(InterchangePlusPlusAmexOptBlue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.OptBlue = value
	case "direct":
		value := new(InterchangePlusPlusAmexDirect)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Direct = value
	}
	return nil
}

func (i InterchangePlusPlusFeesAmex) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.OptBlue != nil {
		return internal.MarshalJSONWithExtraProperty(i.OptBlue, "type", "optBlue")
	}
	if i.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(i.Direct, "type", "direct")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InterchangePlusPlusFeesAmexVisitor interface {
	VisitOptBlue(*InterchangePlusPlusAmexOptBlue) error
	VisitDirect(*InterchangePlusPlusAmexDirect) error
}

func (i *InterchangePlusPlusFeesAmex) Accept(visitor InterchangePlusPlusFeesAmexVisitor) error {
	if i.OptBlue != nil {
		return visitor.VisitOptBlue(i.OptBlue)
	}
	if i.Direct != nil {
		return visitor.VisitDirect(i.Direct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InterchangePlusPlusFeesAmex) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.OptBlue != nil {
		fields = append(fields, "optBlue")
	}
	if i.Direct != nil {
		fields = append(fields, "direct")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

// Object that contains information about Interchange Plus with three tiers.
var (
	interchangePlusTiered3FieldFees = big.NewInt(1 << 0)
)

type InterchangePlusTiered3 struct {
	// Object that contains information about the fees.
	Fees *InterchangePlusTiered3Fees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusTiered3) GetFees() *InterchangePlusTiered3Fees {
	if i == nil {
		return nil
	}
	return i.Fees
}

func (i *InterchangePlusTiered3) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusTiered3) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3) SetFees(fees *InterchangePlusTiered3Fees) {
	i.Fees = fees
	i.require(interchangePlusTiered3FieldFees)
}

func (i *InterchangePlusTiered3) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusTiered3
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusTiered3(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusTiered3) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusTiered3
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusTiered3) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	interchangePlusTiered3AmexDirectFieldTransaction = big.NewInt(1 << 0)
)

type InterchangePlusTiered3AmexDirect struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusTiered3AmexDirect) GetTransaction() Amount {
	if i == nil {
		return 0
	}
	return i.Transaction
}

func (i *InterchangePlusTiered3AmexDirect) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusTiered3AmexDirect) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3AmexDirect) SetTransaction(transaction Amount) {
	i.Transaction = transaction
	i.require(interchangePlusTiered3AmexDirectFieldTransaction)
}

func (i *InterchangePlusTiered3AmexDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusTiered3AmexDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusTiered3AmexDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusTiered3AmexDirect) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusTiered3AmexDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusTiered3AmexDirect) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	interchangePlusTiered3AmexOptBlueFieldQualifiedRate = big.NewInt(1 << 0)
	interchangePlusTiered3AmexOptBlueFieldMidQualRate   = big.NewInt(1 << 1)
	interchangePlusTiered3AmexOptBlueFieldNonQualRate   = big.NewInt(1 << 2)
)

type InterchangePlusTiered3AmexOptBlue struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusTiered3AmexOptBlue) GetQualifiedRate() *ProcessorFee {
	if i == nil {
		return nil
	}
	return i.QualifiedRate
}

func (i *InterchangePlusTiered3AmexOptBlue) GetMidQualRate() *ProcessorFee {
	if i == nil {
		return nil
	}
	return i.MidQualRate
}

func (i *InterchangePlusTiered3AmexOptBlue) GetNonQualRate() *ProcessorFee {
	if i == nil {
		return nil
	}
	return i.NonQualRate
}

func (i *InterchangePlusTiered3AmexOptBlue) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusTiered3AmexOptBlue) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3AmexOptBlue) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	i.QualifiedRate = qualifiedRate
	i.require(interchangePlusTiered3AmexOptBlueFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3AmexOptBlue) SetMidQualRate(midQualRate *ProcessorFee) {
	i.MidQualRate = midQualRate
	i.require(interchangePlusTiered3AmexOptBlueFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3AmexOptBlue) SetNonQualRate(nonQualRate *ProcessorFee) {
	i.NonQualRate = nonQualRate
	i.require(interchangePlusTiered3AmexOptBlueFieldNonQualRate)
}

func (i *InterchangePlusTiered3AmexOptBlue) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusTiered3AmexOptBlue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusTiered3AmexOptBlue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusTiered3AmexOptBlue) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusTiered3AmexOptBlue
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusTiered3AmexOptBlue) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains information about the fees.
var (
	interchangePlusTiered3FeesFieldMastercardVisaDiscover     = big.NewInt(1 << 0)
	interchangePlusTiered3FeesFieldAmex                       = big.NewInt(1 << 1)
	interchangePlusTiered3FeesFieldPinDebit                   = big.NewInt(1 << 2)
	interchangePlusTiered3FeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	interchangePlusTiered3FeesFieldEnhancedInterchange        = big.NewInt(1 << 4)
	interchangePlusTiered3FeesFieldSpecialityCards            = big.NewInt(1 << 5)
)

type InterchangePlusTiered3Fees struct {
	// Object that contains the fees for Mastercard, Visa, and Discover transactions.
	MastercardVisaDiscover *QualRates `json:"mastercardVisaDiscover" url:"mastercardVisaDiscover"`
	// Polymorphic object that contains fees for American Express transactions.
	//
	// The value of the type field determines which variant you should use:
	// -	`optBlue` - Amex OptBlue pricing program.
	// -	`direct` - Amex Direct pricing program.
	Amex                       *InterchangePlusTiered3FeesAmex `json:"amex,omitempty" url:"amex,omitempty"`
	PinDebit                   *PinDebit                       `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer     `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	EnhancedInterchange        *EnhancedInterchange            `json:"enhancedInterchange,omitempty" url:"enhancedInterchange,omitempty"`
	SpecialityCards            *SpecialityCards                `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InterchangePlusTiered3Fees) GetMastercardVisaDiscover() *QualRates {
	if i == nil {
		return nil
	}
	return i.MastercardVisaDiscover
}

func (i *InterchangePlusTiered3Fees) GetAmex() *InterchangePlusTiered3FeesAmex {
	if i == nil {
		return nil
	}
	return i.Amex
}

func (i *InterchangePlusTiered3Fees) GetPinDebit() *PinDebit {
	if i == nil {
		return nil
	}
	return i.PinDebit
}

func (i *InterchangePlusTiered3Fees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if i == nil {
		return nil
	}
	return i.ElectronicBenefitsTransfer
}

func (i *InterchangePlusTiered3Fees) GetEnhancedInterchange() *EnhancedInterchange {
	if i == nil {
		return nil
	}
	return i.EnhancedInterchange
}

func (i *InterchangePlusTiered3Fees) GetSpecialityCards() *SpecialityCards {
	if i == nil {
		return nil
	}
	return i.SpecialityCards
}

func (i *InterchangePlusTiered3Fees) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InterchangePlusTiered3Fees) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetMastercardVisaDiscover sets the MastercardVisaDiscover field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3Fees) SetMastercardVisaDiscover(mastercardVisaDiscover *QualRates) {
	i.MastercardVisaDiscover = mastercardVisaDiscover
	i.require(interchangePlusTiered3FeesFieldMastercardVisaDiscover)
}

// SetAmex sets the Amex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3Fees) SetAmex(amex *InterchangePlusTiered3FeesAmex) {
	i.Amex = amex
	i.require(interchangePlusTiered3FeesFieldAmex)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3Fees) SetPinDebit(pinDebit *PinDebit) {
	i.PinDebit = pinDebit
	i.require(interchangePlusTiered3FeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3Fees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	i.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	i.require(interchangePlusTiered3FeesFieldElectronicBenefitsTransfer)
}

// SetEnhancedInterchange sets the EnhancedInterchange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3Fees) SetEnhancedInterchange(enhancedInterchange *EnhancedInterchange) {
	i.EnhancedInterchange = enhancedInterchange
	i.require(interchangePlusTiered3FeesFieldEnhancedInterchange)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InterchangePlusTiered3Fees) SetSpecialityCards(specialityCards *SpecialityCards) {
	i.SpecialityCards = specialityCards
	i.require(interchangePlusTiered3FeesFieldSpecialityCards)
}

func (i *InterchangePlusTiered3Fees) UnmarshalJSON(data []byte) error {
	type unmarshaler InterchangePlusTiered3Fees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InterchangePlusTiered3Fees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InterchangePlusTiered3Fees) MarshalJSON() ([]byte, error) {
	type embed InterchangePlusTiered3Fees
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InterchangePlusTiered3Fees) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Polymorphic object that contains fees for American Express transactions.
//
// The value of the type field determines which variant you should use:
// -	`optBlue` - Amex OptBlue pricing program.
// -	`direct` - Amex Direct pricing program.
type InterchangePlusTiered3FeesAmex struct {
	Type    string
	OptBlue *InterchangePlusTiered3AmexOptBlue
	Direct  *InterchangePlusTiered3AmexDirect
}

func (i *InterchangePlusTiered3FeesAmex) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InterchangePlusTiered3FeesAmex) GetOptBlue() *InterchangePlusTiered3AmexOptBlue {
	if i == nil {
		return nil
	}
	return i.OptBlue
}

func (i *InterchangePlusTiered3FeesAmex) GetDirect() *InterchangePlusTiered3AmexDirect {
	if i == nil {
		return nil
	}
	return i.Direct
}

func (i *InterchangePlusTiered3FeesAmex) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "optBlue":
		value := new(InterchangePlusTiered3AmexOptBlue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.OptBlue = value
	case "direct":
		value := new(InterchangePlusTiered3AmexDirect)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Direct = value
	}
	return nil
}

func (i InterchangePlusTiered3FeesAmex) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.OptBlue != nil {
		return internal.MarshalJSONWithExtraProperty(i.OptBlue, "type", "optBlue")
	}
	if i.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(i.Direct, "type", "direct")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InterchangePlusTiered3FeesAmexVisitor interface {
	VisitOptBlue(*InterchangePlusTiered3AmexOptBlue) error
	VisitDirect(*InterchangePlusTiered3AmexDirect) error
}

func (i *InterchangePlusTiered3FeesAmex) Accept(visitor InterchangePlusTiered3FeesAmexVisitor) error {
	if i.OptBlue != nil {
		return visitor.VisitOptBlue(i.OptBlue)
	}
	if i.Direct != nil {
		return visitor.VisitDirect(i.Direct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InterchangePlusTiered3FeesAmex) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.OptBlue != nil {
		fields = append(fields, "optBlue")
	}
	if i.Direct != nil {
		fields = append(fields, "direct")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

// Object that contains the IP address of the device that sent the request.
var (
	ipAddressFieldType  = big.NewInt(1 << 0)
	ipAddressFieldValue = big.NewInt(1 << 1)
)

type IpAddress struct {
	// Internet protocol version of the IP address.
	Type IpAddressType `json:"type" url:"type"`
	// IP address of the device.
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IpAddress) GetType() IpAddressType {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *IpAddress) GetValue() string {
	if i == nil {
		return ""
	}
	return i.Value
}

func (i *IpAddress) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IpAddress) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IpAddress) SetType(type_ IpAddressType) {
	i.Type = type_
	i.require(ipAddressFieldType)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IpAddress) SetValue(value string) {
	i.Value = value
	i.require(ipAddressFieldValue)
}

func (i *IpAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler IpAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IpAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IpAddress) MarshalJSON() ([]byte, error) {
	type embed IpAddress
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IpAddress) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Internet protocol version of the IP address.
type IpAddressType string

const (
	IpAddressTypeIpv4 IpAddressType = "ipv4"
	IpAddressTypeIpv6 IpAddressType = "ipv6"
)

func NewIpAddressTypeFromString(s string) (IpAddressType, error) {
	switch s {
	case "ipv4":
		return IpAddressTypeIpv4, nil
	case "ipv6":
		return IpAddressTypeIpv6, nil
	}
	var t IpAddressType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IpAddressType) Ptr() *IpAddressType {
	return &i
}

// Object that contains information about the breakdown of the transaction.
var (
	itemizedBreakdownFieldSubtotal       = big.NewInt(1 << 0)
	itemizedBreakdownFieldCashbackAmount = big.NewInt(1 << 1)
	itemizedBreakdownFieldTip            = big.NewInt(1 << 2)
	itemizedBreakdownFieldSurcharge      = big.NewInt(1 << 3)
	itemizedBreakdownFieldDualPricing    = big.NewInt(1 << 4)
	itemizedBreakdownFieldTaxes          = big.NewInt(1 << 5)
	itemizedBreakdownFieldDutyAmount     = big.NewInt(1 << 6)
	itemizedBreakdownFieldFreightAmount  = big.NewInt(1 << 7)
	itemizedBreakdownFieldConvenienceFee = big.NewInt(1 << 8)
	itemizedBreakdownFieldItems          = big.NewInt(1 << 9)
)

type ItemizedBreakdown struct {
	// Amount of the transaction before tax and fees. The value is in the currency’s lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Amount of cashback for the transaction.
	CashbackAmount *int64 `json:"cashbackAmount,omitempty" url:"cashbackAmount,omitempty"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Object that contains surcharge information for the transaction.
	Surcharge *Surcharge `json:"surcharge,omitempty" url:"surcharge,omitempty"`
	// Object that contains dual pricing information for the transaction.
	DualPricing *DualPricing `json:"dualPricing,omitempty" url:"dualPricing,omitempty"`
	// List of taxes.
	Taxes []*RetrievedTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// Amount of duties or fees that apply to the order. The value is in the currency's lowest denomination, for example, cents.
	DutyAmount *int64 `json:"dutyAmount,omitempty" url:"dutyAmount,omitempty"`
	// Amount for shipping in the currency's lowest denomination, for example, cents.
	FreightAmount  *int64          `json:"freightAmount,omitempty" url:"freightAmount,omitempty"`
	ConvenienceFee *ConvenienceFee `json:"convenienceFee,omitempty" url:"convenienceFee,omitempty"`
	// Array of objects that contain information about each item that the customer purchased.
	Items []*LineItem `json:"items,omitempty" url:"items,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ItemizedBreakdown) GetSubtotal() int64 {
	if i == nil {
		return 0
	}
	return i.Subtotal
}

func (i *ItemizedBreakdown) GetCashbackAmount() *int64 {
	if i == nil {
		return nil
	}
	return i.CashbackAmount
}

func (i *ItemizedBreakdown) GetTip() *Tip {
	if i == nil {
		return nil
	}
	return i.Tip
}

func (i *ItemizedBreakdown) GetSurcharge() *Surcharge {
	if i == nil {
		return nil
	}
	return i.Surcharge
}

func (i *ItemizedBreakdown) GetDualPricing() *DualPricing {
	if i == nil {
		return nil
	}
	return i.DualPricing
}

func (i *ItemizedBreakdown) GetTaxes() []*RetrievedTax {
	if i == nil {
		return nil
	}
	return i.Taxes
}

func (i *ItemizedBreakdown) GetDutyAmount() *int64 {
	if i == nil {
		return nil
	}
	return i.DutyAmount
}

func (i *ItemizedBreakdown) GetFreightAmount() *int64 {
	if i == nil {
		return nil
	}
	return i.FreightAmount
}

func (i *ItemizedBreakdown) GetConvenienceFee() *ConvenienceFee {
	if i == nil {
		return nil
	}
	return i.ConvenienceFee
}

func (i *ItemizedBreakdown) GetItems() []*LineItem {
	if i == nil {
		return nil
	}
	return i.Items
}

func (i *ItemizedBreakdown) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemizedBreakdown) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetSubtotal(subtotal int64) {
	i.Subtotal = subtotal
	i.require(itemizedBreakdownFieldSubtotal)
}

// SetCashbackAmount sets the CashbackAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetCashbackAmount(cashbackAmount *int64) {
	i.CashbackAmount = cashbackAmount
	i.require(itemizedBreakdownFieldCashbackAmount)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetTip(tip *Tip) {
	i.Tip = tip
	i.require(itemizedBreakdownFieldTip)
}

// SetSurcharge sets the Surcharge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetSurcharge(surcharge *Surcharge) {
	i.Surcharge = surcharge
	i.require(itemizedBreakdownFieldSurcharge)
}

// SetDualPricing sets the DualPricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetDualPricing(dualPricing *DualPricing) {
	i.DualPricing = dualPricing
	i.require(itemizedBreakdownFieldDualPricing)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetTaxes(taxes []*RetrievedTax) {
	i.Taxes = taxes
	i.require(itemizedBreakdownFieldTaxes)
}

// SetDutyAmount sets the DutyAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetDutyAmount(dutyAmount *int64) {
	i.DutyAmount = dutyAmount
	i.require(itemizedBreakdownFieldDutyAmount)
}

// SetFreightAmount sets the FreightAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetFreightAmount(freightAmount *int64) {
	i.FreightAmount = freightAmount
	i.require(itemizedBreakdownFieldFreightAmount)
}

// SetConvenienceFee sets the ConvenienceFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetConvenienceFee(convenienceFee *ConvenienceFee) {
	i.ConvenienceFee = convenienceFee
	i.require(itemizedBreakdownFieldConvenienceFee)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdown) SetItems(items []*LineItem) {
	i.Items = items
	i.require(itemizedBreakdownFieldItems)
}

func (i *ItemizedBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemizedBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemizedBreakdown(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemizedBreakdown) MarshalJSON() ([]byte, error) {
	type embed ItemizedBreakdown
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *ItemizedBreakdown) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains information about the breakdown of the transaction.
var (
	itemizedBreakdownRequestFieldSubtotal       = big.NewInt(1 << 0)
	itemizedBreakdownRequestFieldCashbackAmount = big.NewInt(1 << 1)
	itemizedBreakdownRequestFieldTip            = big.NewInt(1 << 2)
	itemizedBreakdownRequestFieldSurcharge      = big.NewInt(1 << 3)
	itemizedBreakdownRequestFieldDualPricing    = big.NewInt(1 << 4)
	itemizedBreakdownRequestFieldTaxes          = big.NewInt(1 << 5)
	itemizedBreakdownRequestFieldDutyAmount     = big.NewInt(1 << 6)
	itemizedBreakdownRequestFieldFreightAmount  = big.NewInt(1 << 7)
	itemizedBreakdownRequestFieldConvenienceFee = big.NewInt(1 << 8)
	itemizedBreakdownRequestFieldItems          = big.NewInt(1 << 9)
)

type ItemizedBreakdownRequest struct {
	// Amount of the transaction before tax and fees. The value is in the currency’s lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Amount of cashback for the transaction.
	CashbackAmount *int64 `json:"cashbackAmount,omitempty" url:"cashbackAmount,omitempty"`
	// Object that contains tip information for the transaction.
	Tip *Tip `json:"tip,omitempty" url:"tip,omitempty"`
	// Object that contains surcharge information for the transaction.
	Surcharge *Surcharge `json:"surcharge,omitempty" url:"surcharge,omitempty"`
	// Object that contains dual pricing information for the transaction.
	DualPricing *DualPricing `json:"dualPricing,omitempty" url:"dualPricing,omitempty"`
	// Array of polymorphic tax objects, which contain information about a tax.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`amount` - Tax is a fixed amount.
	// -	`rate` - Tax is a percentage.
	Taxes []*Tax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// Amount of duties or fees that apply to the order. The value is in the currency's lowest denomination, for example, cents.
	DutyAmount *int64 `json:"dutyAmount,omitempty" url:"dutyAmount,omitempty"`
	// Amount for shipping in the currency's lowest denomination, for example, cents.
	FreightAmount  *int64          `json:"freightAmount,omitempty" url:"freightAmount,omitempty"`
	ConvenienceFee *ConvenienceFee `json:"convenienceFee,omitempty" url:"convenienceFee,omitempty"`
	// Array of objects that contain information about each item that the customer purchased.
	Items []*LineItemRequest `json:"items,omitempty" url:"items,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ItemizedBreakdownRequest) GetSubtotal() int64 {
	if i == nil {
		return 0
	}
	return i.Subtotal
}

func (i *ItemizedBreakdownRequest) GetCashbackAmount() *int64 {
	if i == nil {
		return nil
	}
	return i.CashbackAmount
}

func (i *ItemizedBreakdownRequest) GetTip() *Tip {
	if i == nil {
		return nil
	}
	return i.Tip
}

func (i *ItemizedBreakdownRequest) GetSurcharge() *Surcharge {
	if i == nil {
		return nil
	}
	return i.Surcharge
}

func (i *ItemizedBreakdownRequest) GetDualPricing() *DualPricing {
	if i == nil {
		return nil
	}
	return i.DualPricing
}

func (i *ItemizedBreakdownRequest) GetTaxes() []*Tax {
	if i == nil {
		return nil
	}
	return i.Taxes
}

func (i *ItemizedBreakdownRequest) GetDutyAmount() *int64 {
	if i == nil {
		return nil
	}
	return i.DutyAmount
}

func (i *ItemizedBreakdownRequest) GetFreightAmount() *int64 {
	if i == nil {
		return nil
	}
	return i.FreightAmount
}

func (i *ItemizedBreakdownRequest) GetConvenienceFee() *ConvenienceFee {
	if i == nil {
		return nil
	}
	return i.ConvenienceFee
}

func (i *ItemizedBreakdownRequest) GetItems() []*LineItemRequest {
	if i == nil {
		return nil
	}
	return i.Items
}

func (i *ItemizedBreakdownRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemizedBreakdownRequest) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetSubtotal(subtotal int64) {
	i.Subtotal = subtotal
	i.require(itemizedBreakdownRequestFieldSubtotal)
}

// SetCashbackAmount sets the CashbackAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetCashbackAmount(cashbackAmount *int64) {
	i.CashbackAmount = cashbackAmount
	i.require(itemizedBreakdownRequestFieldCashbackAmount)
}

// SetTip sets the Tip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetTip(tip *Tip) {
	i.Tip = tip
	i.require(itemizedBreakdownRequestFieldTip)
}

// SetSurcharge sets the Surcharge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetSurcharge(surcharge *Surcharge) {
	i.Surcharge = surcharge
	i.require(itemizedBreakdownRequestFieldSurcharge)
}

// SetDualPricing sets the DualPricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetDualPricing(dualPricing *DualPricing) {
	i.DualPricing = dualPricing
	i.require(itemizedBreakdownRequestFieldDualPricing)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetTaxes(taxes []*Tax) {
	i.Taxes = taxes
	i.require(itemizedBreakdownRequestFieldTaxes)
}

// SetDutyAmount sets the DutyAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetDutyAmount(dutyAmount *int64) {
	i.DutyAmount = dutyAmount
	i.require(itemizedBreakdownRequestFieldDutyAmount)
}

// SetFreightAmount sets the FreightAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetFreightAmount(freightAmount *int64) {
	i.FreightAmount = freightAmount
	i.require(itemizedBreakdownRequestFieldFreightAmount)
}

// SetConvenienceFee sets the ConvenienceFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetConvenienceFee(convenienceFee *ConvenienceFee) {
	i.ConvenienceFee = convenienceFee
	i.require(itemizedBreakdownRequestFieldConvenienceFee)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ItemizedBreakdownRequest) SetItems(items []*LineItemRequest) {
	i.Items = items
	i.require(itemizedBreakdownRequestFieldItems)
}

func (i *ItemizedBreakdownRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemizedBreakdownRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemizedBreakdownRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemizedBreakdownRequest) MarshalJSON() ([]byte, error) {
	type embed ItemizedBreakdownRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *ItemizedBreakdownRequest) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Object that contains information about the keyed card details.
var (
	keyedCardDetailsFieldKeyedData           = big.NewInt(1 << 0)
	keyedCardDetailsFieldCardholderName      = big.NewInt(1 << 1)
	keyedCardDetailsFieldCardholderSignature = big.NewInt(1 << 2)
	keyedCardDetailsFieldPinDetails          = big.NewInt(1 << 3)
	keyedCardDetailsFieldEbtDetails          = big.NewInt(1 << 4)
)

type KeyedCardDetails struct {
	// Polymorphic object that contains payment card details that the merchant manually entered into the device.
	//
	// The value of the dataFormat parameter determines which variant you should use:
	// -	`fullyEncrypted` - Some payment card details are encrypted.
	// -	`partiallyEncrypted` - Payment card details are in plain text.
	// -	`plainText` - All payment card details are encrypted.
	KeyedData *KeyedCardDetailsKeyedData `json:"keyedData" url:"keyedData"`
	// Cardholder’s name.
	CardholderName *string `json:"cardholderName,omitempty" url:"cardholderName,omitempty"`
	// Cardholder's signature. For more information about how to format the signature, go to [How to send a signature to our gateway](https://docs.payroc.com/knowledge/basic-concepts/signature-capture).
	CardholderSignature *string `json:"cardholderSignature,omitempty" url:"cardholderSignature,omitempty"`
	// Polymorphic object that contains information about the customer's PIN.
	PinDetails *KeyedCardDetailsPinDetails `json:"pinDetails,omitempty" url:"pinDetails,omitempty"`
	EbtDetails *EbtDetailsWithVoucher      `json:"ebtDetails,omitempty" url:"ebtDetails,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KeyedCardDetails) GetKeyedData() *KeyedCardDetailsKeyedData {
	if k == nil {
		return nil
	}
	return k.KeyedData
}

func (k *KeyedCardDetails) GetCardholderName() *string {
	if k == nil {
		return nil
	}
	return k.CardholderName
}

func (k *KeyedCardDetails) GetCardholderSignature() *string {
	if k == nil {
		return nil
	}
	return k.CardholderSignature
}

func (k *KeyedCardDetails) GetPinDetails() *KeyedCardDetailsPinDetails {
	if k == nil {
		return nil
	}
	return k.PinDetails
}

func (k *KeyedCardDetails) GetEbtDetails() *EbtDetailsWithVoucher {
	if k == nil {
		return nil
	}
	return k.EbtDetails
}

func (k *KeyedCardDetails) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KeyedCardDetails) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetKeyedData sets the KeyedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KeyedCardDetails) SetKeyedData(keyedData *KeyedCardDetailsKeyedData) {
	k.KeyedData = keyedData
	k.require(keyedCardDetailsFieldKeyedData)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KeyedCardDetails) SetCardholderName(cardholderName *string) {
	k.CardholderName = cardholderName
	k.require(keyedCardDetailsFieldCardholderName)
}

// SetCardholderSignature sets the CardholderSignature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KeyedCardDetails) SetCardholderSignature(cardholderSignature *string) {
	k.CardholderSignature = cardholderSignature
	k.require(keyedCardDetailsFieldCardholderSignature)
}

// SetPinDetails sets the PinDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KeyedCardDetails) SetPinDetails(pinDetails *KeyedCardDetailsPinDetails) {
	k.PinDetails = pinDetails
	k.require(keyedCardDetailsFieldPinDetails)
}

// SetEbtDetails sets the EbtDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KeyedCardDetails) SetEbtDetails(ebtDetails *EbtDetailsWithVoucher) {
	k.EbtDetails = ebtDetails
	k.require(keyedCardDetailsFieldEbtDetails)
}

func (k *KeyedCardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler KeyedCardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KeyedCardDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KeyedCardDetails) MarshalJSON() ([]byte, error) {
	type embed KeyedCardDetails
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KeyedCardDetails) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// Polymorphic object that contains payment card details that the merchant manually entered into the device.
//
// The value of the dataFormat parameter determines which variant you should use:
// -	`fullyEncrypted` - Some payment card details are encrypted.
// -	`partiallyEncrypted` - Payment card details are in plain text.
// -	`plainText` - All payment card details are encrypted.
type KeyedCardDetailsKeyedData struct {
	DataFormat         string
	FullyEncrypted     *FullyEncryptedKeyedDataFormat
	PartiallyEncrypted *PartiallyEncryptedKeyedDataFormat
	PlainText          *PlainTextKeyedDataFormat
}

func (k *KeyedCardDetailsKeyedData) GetDataFormat() string {
	if k == nil {
		return ""
	}
	return k.DataFormat
}

func (k *KeyedCardDetailsKeyedData) GetFullyEncrypted() *FullyEncryptedKeyedDataFormat {
	if k == nil {
		return nil
	}
	return k.FullyEncrypted
}

func (k *KeyedCardDetailsKeyedData) GetPartiallyEncrypted() *PartiallyEncryptedKeyedDataFormat {
	if k == nil {
		return nil
	}
	return k.PartiallyEncrypted
}

func (k *KeyedCardDetailsKeyedData) GetPlainText() *PlainTextKeyedDataFormat {
	if k == nil {
		return nil
	}
	return k.PlainText
}

func (k *KeyedCardDetailsKeyedData) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		DataFormat string `json:"dataFormat"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	k.DataFormat = unmarshaler.DataFormat
	if unmarshaler.DataFormat == "" {
		return fmt.Errorf("%T did not include discriminant dataFormat", k)
	}
	switch unmarshaler.DataFormat {
	case "fullyEncrypted":
		value := new(FullyEncryptedKeyedDataFormat)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		k.FullyEncrypted = value
	case "partiallyEncrypted":
		value := new(PartiallyEncryptedKeyedDataFormat)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		k.PartiallyEncrypted = value
	case "plainText":
		value := new(PlainTextKeyedDataFormat)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		k.PlainText = value
	}
	return nil
}

func (k KeyedCardDetailsKeyedData) MarshalJSON() ([]byte, error) {
	if err := k.validate(); err != nil {
		return nil, err
	}
	if k.FullyEncrypted != nil {
		return internal.MarshalJSONWithExtraProperty(k.FullyEncrypted, "dataFormat", "fullyEncrypted")
	}
	if k.PartiallyEncrypted != nil {
		return internal.MarshalJSONWithExtraProperty(k.PartiallyEncrypted, "dataFormat", "partiallyEncrypted")
	}
	if k.PlainText != nil {
		return internal.MarshalJSONWithExtraProperty(k.PlainText, "dataFormat", "plainText")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", k)
}

type KeyedCardDetailsKeyedDataVisitor interface {
	VisitFullyEncrypted(*FullyEncryptedKeyedDataFormat) error
	VisitPartiallyEncrypted(*PartiallyEncryptedKeyedDataFormat) error
	VisitPlainText(*PlainTextKeyedDataFormat) error
}

func (k *KeyedCardDetailsKeyedData) Accept(visitor KeyedCardDetailsKeyedDataVisitor) error {
	if k.FullyEncrypted != nil {
		return visitor.VisitFullyEncrypted(k.FullyEncrypted)
	}
	if k.PartiallyEncrypted != nil {
		return visitor.VisitPartiallyEncrypted(k.PartiallyEncrypted)
	}
	if k.PlainText != nil {
		return visitor.VisitPlainText(k.PlainText)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", k)
}

func (k *KeyedCardDetailsKeyedData) validate() error {
	if k == nil {
		return fmt.Errorf("type %T is nil", k)
	}
	var fields []string
	if k.FullyEncrypted != nil {
		fields = append(fields, "fullyEncrypted")
	}
	if k.PartiallyEncrypted != nil {
		fields = append(fields, "partiallyEncrypted")
	}
	if k.PlainText != nil {
		fields = append(fields, "plainText")
	}
	if len(fields) == 0 {
		if k.DataFormat != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", k, k.DataFormat)
		}
		return fmt.Errorf("type %T is empty", k)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", k, fields)
	}
	if k.DataFormat != "" {
		field := fields[0]
		if k.DataFormat != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				k,
				k.DataFormat,
				k,
			)
		}
	}
	return nil
}

// Polymorphic object that contains information about the customer's PIN.
type KeyedCardDetailsPinDetails struct {
	DataFormat string
	Dukpt      *DukptPinDetails
}

func (k *KeyedCardDetailsPinDetails) GetDataFormat() string {
	if k == nil {
		return ""
	}
	return k.DataFormat
}

func (k *KeyedCardDetailsPinDetails) GetDukpt() *DukptPinDetails {
	if k == nil {
		return nil
	}
	return k.Dukpt
}

func (k *KeyedCardDetailsPinDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		DataFormat string `json:"dataFormat"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	k.DataFormat = unmarshaler.DataFormat
	if unmarshaler.DataFormat == "" {
		return fmt.Errorf("%T did not include discriminant dataFormat", k)
	}
	switch unmarshaler.DataFormat {
	case "dukpt":
		value := new(DukptPinDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		k.Dukpt = value
	}
	return nil
}

func (k KeyedCardDetailsPinDetails) MarshalJSON() ([]byte, error) {
	if err := k.validate(); err != nil {
		return nil, err
	}
	if k.Dukpt != nil {
		return internal.MarshalJSONWithExtraProperty(k.Dukpt, "dataFormat", "dukpt")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", k)
}

type KeyedCardDetailsPinDetailsVisitor interface {
	VisitDukpt(*DukptPinDetails) error
}

func (k *KeyedCardDetailsPinDetails) Accept(visitor KeyedCardDetailsPinDetailsVisitor) error {
	if k.Dukpt != nil {
		return visitor.VisitDukpt(k.Dukpt)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", k)
}

func (k *KeyedCardDetailsPinDetails) validate() error {
	if k == nil {
		return fmt.Errorf("type %T is nil", k)
	}
	var fields []string
	if k.Dukpt != nil {
		fields = append(fields, "dukpt")
	}
	if len(fields) == 0 {
		if k.DataFormat != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", k, k.DataFormat)
		}
		return fmt.Errorf("type %T is empty", k)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", k, fields)
	}
	if k.DataFormat != "" {
		field := fields[0]
		if k.DataFormat != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				k,
				k.DataFormat,
				k,
			)
		}
	}
	return nil
}

var (
	legalAddressFieldType       = big.NewInt(1 << 0)
	legalAddressFieldAddress1   = big.NewInt(1 << 1)
	legalAddressFieldAddress2   = big.NewInt(1 << 2)
	legalAddressFieldAddress3   = big.NewInt(1 << 3)
	legalAddressFieldCity       = big.NewInt(1 << 4)
	legalAddressFieldState      = big.NewInt(1 << 5)
	legalAddressFieldCountry    = big.NewInt(1 << 6)
	legalAddressFieldPostalCode = big.NewInt(1 << 7)
)

type LegalAddress struct {
	// Type of address.
	Type AddressTypeType `json:"type" url:"type"`
	// Address line 1.
	Address1 string `json:"address1" url:"address1"`
	// Address line 2.
	Address2 *string `json:"address2,omitempty" url:"address2,omitempty"`
	// Address line 3.
	Address3 *string `json:"address3,omitempty" url:"address3,omitempty"`
	// City.
	City string `json:"city" url:"city"`
	// Name of the state or state abbreviation.
	State string `json:"state" url:"state"`
	// Two-digit country code for the country that the business operates in. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
	Country string `json:"country" url:"country"`
	// Zip code or postal code.
	PostalCode string `json:"postalCode" url:"postalCode"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LegalAddress) GetType() AddressTypeType {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *LegalAddress) GetAddress1() string {
	if l == nil {
		return ""
	}
	return l.Address1
}

func (l *LegalAddress) GetAddress2() *string {
	if l == nil {
		return nil
	}
	return l.Address2
}

func (l *LegalAddress) GetAddress3() *string {
	if l == nil {
		return nil
	}
	return l.Address3
}

func (l *LegalAddress) GetCity() string {
	if l == nil {
		return ""
	}
	return l.City
}

func (l *LegalAddress) GetState() string {
	if l == nil {
		return ""
	}
	return l.State
}

func (l *LegalAddress) GetCountry() string {
	if l == nil {
		return ""
	}
	return l.Country
}

func (l *LegalAddress) GetPostalCode() string {
	if l == nil {
		return ""
	}
	return l.PostalCode
}

func (l *LegalAddress) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LegalAddress) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetType(type_ AddressTypeType) {
	l.Type = type_
	l.require(legalAddressFieldType)
}

// SetAddress1 sets the Address1 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetAddress1(address1 string) {
	l.Address1 = address1
	l.require(legalAddressFieldAddress1)
}

// SetAddress2 sets the Address2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetAddress2(address2 *string) {
	l.Address2 = address2
	l.require(legalAddressFieldAddress2)
}

// SetAddress3 sets the Address3 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetAddress3(address3 *string) {
	l.Address3 = address3
	l.require(legalAddressFieldAddress3)
}

// SetCity sets the City field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetCity(city string) {
	l.City = city
	l.require(legalAddressFieldCity)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetState(state string) {
	l.State = state
	l.require(legalAddressFieldState)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetCountry(country string) {
	l.Country = country
	l.require(legalAddressFieldCountry)
}

// SetPostalCode sets the PostalCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LegalAddress) SetPostalCode(postalCode string) {
	l.PostalCode = postalCode
	l.require(legalAddressFieldPostalCode)
}

func (l *LegalAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler LegalAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LegalAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LegalAddress) MarshalJSON() ([]byte, error) {
	type embed LegalAddress
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LegalAddress) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	lineItemFieldCommodityCode = big.NewInt(1 << 0)
	lineItemFieldProductCode   = big.NewInt(1 << 1)
	lineItemFieldDescription   = big.NewInt(1 << 2)
	lineItemFieldUnitOfMeasure = big.NewInt(1 << 3)
	lineItemFieldUnitPrice     = big.NewInt(1 << 4)
	lineItemFieldQuantity      = big.NewInt(1 << 5)
	lineItemFieldDiscountRate  = big.NewInt(1 << 6)
	lineItemFieldTaxes         = big.NewInt(1 << 7)
)

type LineItem struct {
	// Commodity code of the item.
	CommodityCode *string `json:"commodityCode,omitempty" url:"commodityCode,omitempty"`
	// Product code of the item.
	ProductCode *string `json:"productCode,omitempty" url:"productCode,omitempty"`
	// Description of the item.
	Description   *string        `json:"description,omitempty" url:"description,omitempty"`
	UnitOfMeasure *UnitOfMeasure `json:"unitOfMeasure,omitempty" url:"unitOfMeasure,omitempty"`
	// Price of each unit.
	UnitPrice int64 `json:"unitPrice" url:"unitPrice"`
	// Number of units.
	Quantity float64 `json:"quantity" url:"quantity"`
	// Discount rate that the merchant applies to the item.
	DiscountRate *float64 `json:"discountRate,omitempty" url:"discountRate,omitempty"`
	// Array of objects that contain information about each tax that applies to the item.
	Taxes []*RetrievedTax `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineItem) GetCommodityCode() *string {
	if l == nil {
		return nil
	}
	return l.CommodityCode
}

func (l *LineItem) GetProductCode() *string {
	if l == nil {
		return nil
	}
	return l.ProductCode
}

func (l *LineItem) GetDescription() *string {
	if l == nil {
		return nil
	}
	return l.Description
}

func (l *LineItem) GetUnitOfMeasure() *UnitOfMeasure {
	if l == nil {
		return nil
	}
	return l.UnitOfMeasure
}

func (l *LineItem) GetUnitPrice() int64 {
	if l == nil {
		return 0
	}
	return l.UnitPrice
}

func (l *LineItem) GetQuantity() float64 {
	if l == nil {
		return 0
	}
	return l.Quantity
}

func (l *LineItem) GetDiscountRate() *float64 {
	if l == nil {
		return nil
	}
	return l.DiscountRate
}

func (l *LineItem) GetTaxes() []*RetrievedTax {
	if l == nil {
		return nil
	}
	return l.Taxes
}

func (l *LineItem) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineItem) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetCommodityCode sets the CommodityCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetCommodityCode(commodityCode *string) {
	l.CommodityCode = commodityCode
	l.require(lineItemFieldCommodityCode)
}

// SetProductCode sets the ProductCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetProductCode(productCode *string) {
	l.ProductCode = productCode
	l.require(lineItemFieldProductCode)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetDescription(description *string) {
	l.Description = description
	l.require(lineItemFieldDescription)
}

// SetUnitOfMeasure sets the UnitOfMeasure field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetUnitOfMeasure(unitOfMeasure *UnitOfMeasure) {
	l.UnitOfMeasure = unitOfMeasure
	l.require(lineItemFieldUnitOfMeasure)
}

// SetUnitPrice sets the UnitPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetUnitPrice(unitPrice int64) {
	l.UnitPrice = unitPrice
	l.require(lineItemFieldUnitPrice)
}

// SetQuantity sets the Quantity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetQuantity(quantity float64) {
	l.Quantity = quantity
	l.require(lineItemFieldQuantity)
}

// SetDiscountRate sets the DiscountRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetDiscountRate(discountRate *float64) {
	l.DiscountRate = discountRate
	l.require(lineItemFieldDiscountRate)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItem) SetTaxes(taxes []*RetrievedTax) {
	l.Taxes = taxes
	l.require(lineItemFieldTaxes)
}

func (l *LineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler LineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LineItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineItem) MarshalJSON() ([]byte, error) {
	type embed LineItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LineItem) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// List of line items.
var (
	lineItemBaseFieldCommodityCode = big.NewInt(1 << 0)
	lineItemBaseFieldProductCode   = big.NewInt(1 << 1)
	lineItemBaseFieldDescription   = big.NewInt(1 << 2)
	lineItemBaseFieldUnitOfMeasure = big.NewInt(1 << 3)
	lineItemBaseFieldUnitPrice     = big.NewInt(1 << 4)
	lineItemBaseFieldQuantity      = big.NewInt(1 << 5)
	lineItemBaseFieldDiscountRate  = big.NewInt(1 << 6)
)

type LineItemBase struct {
	// Commodity code of the item.
	CommodityCode *string `json:"commodityCode,omitempty" url:"commodityCode,omitempty"`
	// Product code of the item.
	ProductCode *string `json:"productCode,omitempty" url:"productCode,omitempty"`
	// Description of the item.
	Description   *string        `json:"description,omitempty" url:"description,omitempty"`
	UnitOfMeasure *UnitOfMeasure `json:"unitOfMeasure,omitempty" url:"unitOfMeasure,omitempty"`
	// Price of each unit.
	UnitPrice int64 `json:"unitPrice" url:"unitPrice"`
	// Number of units.
	Quantity float64 `json:"quantity" url:"quantity"`
	// Discount rate that the merchant applies to the item.
	DiscountRate *float64 `json:"discountRate,omitempty" url:"discountRate,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineItemBase) GetCommodityCode() *string {
	if l == nil {
		return nil
	}
	return l.CommodityCode
}

func (l *LineItemBase) GetProductCode() *string {
	if l == nil {
		return nil
	}
	return l.ProductCode
}

func (l *LineItemBase) GetDescription() *string {
	if l == nil {
		return nil
	}
	return l.Description
}

func (l *LineItemBase) GetUnitOfMeasure() *UnitOfMeasure {
	if l == nil {
		return nil
	}
	return l.UnitOfMeasure
}

func (l *LineItemBase) GetUnitPrice() int64 {
	if l == nil {
		return 0
	}
	return l.UnitPrice
}

func (l *LineItemBase) GetQuantity() float64 {
	if l == nil {
		return 0
	}
	return l.Quantity
}

func (l *LineItemBase) GetDiscountRate() *float64 {
	if l == nil {
		return nil
	}
	return l.DiscountRate
}

func (l *LineItemBase) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineItemBase) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetCommodityCode sets the CommodityCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemBase) SetCommodityCode(commodityCode *string) {
	l.CommodityCode = commodityCode
	l.require(lineItemBaseFieldCommodityCode)
}

// SetProductCode sets the ProductCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemBase) SetProductCode(productCode *string) {
	l.ProductCode = productCode
	l.require(lineItemBaseFieldProductCode)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemBase) SetDescription(description *string) {
	l.Description = description
	l.require(lineItemBaseFieldDescription)
}

// SetUnitOfMeasure sets the UnitOfMeasure field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemBase) SetUnitOfMeasure(unitOfMeasure *UnitOfMeasure) {
	l.UnitOfMeasure = unitOfMeasure
	l.require(lineItemBaseFieldUnitOfMeasure)
}

// SetUnitPrice sets the UnitPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemBase) SetUnitPrice(unitPrice int64) {
	l.UnitPrice = unitPrice
	l.require(lineItemBaseFieldUnitPrice)
}

// SetQuantity sets the Quantity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemBase) SetQuantity(quantity float64) {
	l.Quantity = quantity
	l.require(lineItemBaseFieldQuantity)
}

// SetDiscountRate sets the DiscountRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemBase) SetDiscountRate(discountRate *float64) {
	l.DiscountRate = discountRate
	l.require(lineItemBaseFieldDiscountRate)
}

func (l *LineItemBase) UnmarshalJSON(data []byte) error {
	type unmarshaler LineItemBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LineItemBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineItemBase) MarshalJSON() ([]byte, error) {
	type embed LineItemBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LineItemBase) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	lineItemRequestFieldCommodityCode = big.NewInt(1 << 0)
	lineItemRequestFieldProductCode   = big.NewInt(1 << 1)
	lineItemRequestFieldDescription   = big.NewInt(1 << 2)
	lineItemRequestFieldUnitOfMeasure = big.NewInt(1 << 3)
	lineItemRequestFieldUnitPrice     = big.NewInt(1 << 4)
	lineItemRequestFieldQuantity      = big.NewInt(1 << 5)
	lineItemRequestFieldDiscountRate  = big.NewInt(1 << 6)
	lineItemRequestFieldTaxes         = big.NewInt(1 << 7)
)

type LineItemRequest struct {
	// Commodity code of the item.
	CommodityCode *string `json:"commodityCode,omitempty" url:"commodityCode,omitempty"`
	// Product code of the item.
	ProductCode *string `json:"productCode,omitempty" url:"productCode,omitempty"`
	// Description of the item.
	Description   *string        `json:"description,omitempty" url:"description,omitempty"`
	UnitOfMeasure *UnitOfMeasure `json:"unitOfMeasure,omitempty" url:"unitOfMeasure,omitempty"`
	// Price of each unit.
	UnitPrice int64 `json:"unitPrice" url:"unitPrice"`
	// Number of units.
	Quantity float64 `json:"quantity" url:"quantity"`
	// Discount rate that the merchant applies to the item.
	DiscountRate *float64 `json:"discountRate,omitempty" url:"discountRate,omitempty"`
	// Array of objects that contain information about each tax that applies to the item.
	Taxes []*Tax `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LineItemRequest) GetCommodityCode() *string {
	if l == nil {
		return nil
	}
	return l.CommodityCode
}

func (l *LineItemRequest) GetProductCode() *string {
	if l == nil {
		return nil
	}
	return l.ProductCode
}

func (l *LineItemRequest) GetDescription() *string {
	if l == nil {
		return nil
	}
	return l.Description
}

func (l *LineItemRequest) GetUnitOfMeasure() *UnitOfMeasure {
	if l == nil {
		return nil
	}
	return l.UnitOfMeasure
}

func (l *LineItemRequest) GetUnitPrice() int64 {
	if l == nil {
		return 0
	}
	return l.UnitPrice
}

func (l *LineItemRequest) GetQuantity() float64 {
	if l == nil {
		return 0
	}
	return l.Quantity
}

func (l *LineItemRequest) GetDiscountRate() *float64 {
	if l == nil {
		return nil
	}
	return l.DiscountRate
}

func (l *LineItemRequest) GetTaxes() []*Tax {
	if l == nil {
		return nil
	}
	return l.Taxes
}

func (l *LineItemRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LineItemRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetCommodityCode sets the CommodityCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetCommodityCode(commodityCode *string) {
	l.CommodityCode = commodityCode
	l.require(lineItemRequestFieldCommodityCode)
}

// SetProductCode sets the ProductCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetProductCode(productCode *string) {
	l.ProductCode = productCode
	l.require(lineItemRequestFieldProductCode)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetDescription(description *string) {
	l.Description = description
	l.require(lineItemRequestFieldDescription)
}

// SetUnitOfMeasure sets the UnitOfMeasure field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetUnitOfMeasure(unitOfMeasure *UnitOfMeasure) {
	l.UnitOfMeasure = unitOfMeasure
	l.require(lineItemRequestFieldUnitOfMeasure)
}

// SetUnitPrice sets the UnitPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetUnitPrice(unitPrice int64) {
	l.UnitPrice = unitPrice
	l.require(lineItemRequestFieldUnitPrice)
}

// SetQuantity sets the Quantity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetQuantity(quantity float64) {
	l.Quantity = quantity
	l.require(lineItemRequestFieldQuantity)
}

// SetDiscountRate sets the DiscountRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetDiscountRate(discountRate *float64) {
	l.DiscountRate = discountRate
	l.require(lineItemRequestFieldDiscountRate)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LineItemRequest) SetTaxes(taxes []*Tax) {
	l.Taxes = taxes
	l.require(lineItemRequestFieldTaxes)
}

func (l *LineItemRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler LineItemRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LineItemRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LineItemRequest) MarshalJSON() ([]byte, error) {
	type embed LineItemRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LineItemRequest) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Object that contains HATEOAS links for the resource.
var (
	linkFieldRel    = big.NewInt(1 << 0)
	linkFieldMethod = big.NewInt(1 << 1)
	linkFieldHref   = big.NewInt(1 << 2)
)

type Link struct {
	// Indicates the relationship between the current resource and the target resource.
	Rel string `json:"rel" url:"rel"`
	// HTTP method that you need to use with the target resource.
	Method string `json:"method" url:"method"`
	// URL of the target resource.
	Href string `json:"href" url:"href"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *Link) GetRel() string {
	if l == nil {
		return ""
	}
	return l.Rel
}

func (l *Link) GetMethod() string {
	if l == nil {
		return ""
	}
	return l.Method
}

func (l *Link) GetHref() string {
	if l == nil {
		return ""
	}
	return l.Href
}

func (l *Link) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Link) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *Link) SetRel(rel string) {
	l.Rel = rel
	l.require(linkFieldRel)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *Link) SetMethod(method string) {
	l.Method = method
	l.require(linkFieldMethod)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *Link) SetHref(href string) {
	l.Href = href
	l.require(linkFieldHref)
}

func (l *Link) UnmarshalJSON(data []byte) error {
	type unmarshaler Link
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Link(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *Link) MarshalJSON() ([]byte, error) {
	type embed Link
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *Link) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Array of links related to your order items.
var (
	linksFieldLinks = big.NewInt(1 << 0)
)

type Links struct {
	// Polymorphic object that contains information about the processing terminal that the order is linked to.
	Links []*ProcessingTerminalSummary `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *Links) GetLinks() []*ProcessingTerminalSummary {
	if l == nil {
		return nil
	}
	return l.Links
}

func (l *Links) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Links) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *Links) SetLinks(links []*ProcessingTerminalSummary) {
	l.Links = links
	l.require(linksFieldLinks)
}

func (l *Links) UnmarshalJSON(data []byte) error {
	type unmarshaler Links
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Links(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *Links) MarshalJSON() ([]byte, error) {
	type embed Links
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *Links) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	listFundingAccountsFieldLimit   = big.NewInt(1 << 0)
	listFundingAccountsFieldCount   = big.NewInt(1 << 1)
	listFundingAccountsFieldHasMore = big.NewInt(1 << 2)
	listFundingAccountsFieldLinks   = big.NewInt(1 << 3)
	listFundingAccountsFieldData    = big.NewInt(1 << 4)
)

type ListFundingAccounts struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of fundingAccount objects.
	Data []*FundingAccount `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListFundingAccounts) GetLimit() *int {
	if l == nil {
		return nil
	}
	return l.Limit
}

func (l *ListFundingAccounts) GetCount() *int {
	if l == nil {
		return nil
	}
	return l.Count
}

func (l *ListFundingAccounts) GetHasMore() *bool {
	if l == nil {
		return nil
	}
	return l.HasMore
}

func (l *ListFundingAccounts) GetLinks() []*Link {
	if l == nil {
		return nil
	}
	return l.Links
}

func (l *ListFundingAccounts) GetData() []*FundingAccount {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListFundingAccounts) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListFundingAccounts) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListFundingAccounts) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listFundingAccountsFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListFundingAccounts) SetCount(count *int) {
	l.Count = count
	l.require(listFundingAccountsFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListFundingAccounts) SetHasMore(hasMore *bool) {
	l.HasMore = hasMore
	l.require(listFundingAccountsFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListFundingAccounts) SetLinks(links []*Link) {
	l.Links = links
	l.require(listFundingAccountsFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListFundingAccounts) SetData(data []*FundingAccount) {
	l.Data = data
	l.require(listFundingAccountsFieldData)
}

func (l *ListFundingAccounts) UnmarshalJSON(data []byte) error {
	type unmarshaler ListFundingAccounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListFundingAccounts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListFundingAccounts) MarshalJSON() ([]byte, error) {
	type embed ListFundingAccounts
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListFundingAccounts) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates how the merchant batches their transactions.
type ManualBatchClose struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ManualBatchClose) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ManualBatchClose) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

func (m *ManualBatchClose) UnmarshalJSON(data []byte) error {
	type unmarshaler ManualBatchClose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ManualBatchClose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ManualBatchClose) MarshalJSON() ([]byte, error) {
	type embed ManualBatchClose
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *ManualBatchClose) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Object that contains information about the total funds available to the merchant.
var (
	merchantBalanceFieldMerchantId = big.NewInt(1 << 0)
	merchantBalanceFieldFunds      = big.NewInt(1 << 1)
	merchantBalanceFieldPending    = big.NewInt(1 << 2)
	merchantBalanceFieldAvailable  = big.NewInt(1 << 3)
	merchantBalanceFieldCurrency   = big.NewInt(1 << 4)
)

type MerchantBalance struct {
	// Unique identifier that the processor assigned to the merchant.
	MerchantId *string `json:"merchantId,omitempty" url:"merchantId,omitempty"`
	// Total funding balance for the merchant, including pending amounts. The value is in the currency's lowest denomination, for example, cents.
	Funds *int `json:"funds,omitempty" url:"funds,omitempty"`
	// Amount of the funding balance that we have not yet sent to funding accounts. The value is in the currency's lowest denomination, for example, cents.
	Pending *int `json:"pending,omitempty" url:"pending,omitempty"`
	// Amount of the funding balance that you can use in funding instructions. The value is in the currency's lowest denomination, for example, cents.
	Available *int `json:"available,omitempty" url:"available,omitempty"`
	// Currency of the funding balance. We return a value of `USD`.
	Currency *string `json:"currency,omitempty" url:"currency,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantBalance) GetMerchantId() *string {
	if m == nil {
		return nil
	}
	return m.MerchantId
}

func (m *MerchantBalance) GetFunds() *int {
	if m == nil {
		return nil
	}
	return m.Funds
}

func (m *MerchantBalance) GetPending() *int {
	if m == nil {
		return nil
	}
	return m.Pending
}

func (m *MerchantBalance) GetAvailable() *int {
	if m == nil {
		return nil
	}
	return m.Available
}

func (m *MerchantBalance) GetCurrency() *string {
	if m == nil {
		return nil
	}
	return m.Currency
}

func (m *MerchantBalance) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantBalance) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetMerchantId sets the MerchantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantBalance) SetMerchantId(merchantId *string) {
	m.MerchantId = merchantId
	m.require(merchantBalanceFieldMerchantId)
}

// SetFunds sets the Funds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantBalance) SetFunds(funds *int) {
	m.Funds = funds
	m.require(merchantBalanceFieldFunds)
}

// SetPending sets the Pending field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantBalance) SetPending(pending *int) {
	m.Pending = pending
	m.require(merchantBalanceFieldPending)
}

// SetAvailable sets the Available field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantBalance) SetAvailable(available *int) {
	m.Available = available
	m.require(merchantBalanceFieldAvailable)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantBalance) SetCurrency(currency *string) {
	m.Currency = currency
	m.require(merchantBalanceFieldCurrency)
}

func (m *MerchantBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantBalance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantBalance) MarshalJSON() ([]byte, error) {
	type embed MerchantBalance
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MerchantBalance) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	merchantPlatformFieldMerchantPlatformId = big.NewInt(1 << 0)
	merchantPlatformFieldCreatedDate        = big.NewInt(1 << 1)
	merchantPlatformFieldLastModifiedDate   = big.NewInt(1 << 2)
	merchantPlatformFieldBusiness           = big.NewInt(1 << 3)
	merchantPlatformFieldProcessingAccounts = big.NewInt(1 << 4)
	merchantPlatformFieldMetadata           = big.NewInt(1 << 5)
	merchantPlatformFieldLinks              = big.NewInt(1 << 6)
)

type MerchantPlatform struct {
	// Unique identifier that we assigned to the merchant platform.
	MerchantPlatformId *string `json:"merchantPlatformId,omitempty" url:"merchantPlatformId,omitempty"`
	// Date that the merchant platform was created. We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date that the merchant platform was last modified. We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	Business         *Business  `json:"business" url:"business"`
	// Array of processingAccount objects.
	ProcessingAccounts []*MerchantPlatformProcessingAccountsItem `json:"processingAccounts,omitempty" url:"processingAccounts,omitempty"`
	// Object that you can send to include custom metadata in the request.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Array of useful links related to your request.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantPlatform) GetMerchantPlatformId() *string {
	if m == nil {
		return nil
	}
	return m.MerchantPlatformId
}

func (m *MerchantPlatform) GetCreatedDate() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreatedDate
}

func (m *MerchantPlatform) GetLastModifiedDate() *time.Time {
	if m == nil {
		return nil
	}
	return m.LastModifiedDate
}

func (m *MerchantPlatform) GetBusiness() *Business {
	if m == nil {
		return nil
	}
	return m.Business
}

func (m *MerchantPlatform) GetProcessingAccounts() []*MerchantPlatformProcessingAccountsItem {
	if m == nil {
		return nil
	}
	return m.ProcessingAccounts
}

func (m *MerchantPlatform) GetMetadata() map[string]string {
	if m == nil {
		return nil
	}
	return m.Metadata
}

func (m *MerchantPlatform) GetLinks() []*Link {
	if m == nil {
		return nil
	}
	return m.Links
}

func (m *MerchantPlatform) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantPlatform) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetMerchantPlatformId sets the MerchantPlatformId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatform) SetMerchantPlatformId(merchantPlatformId *string) {
	m.MerchantPlatformId = merchantPlatformId
	m.require(merchantPlatformFieldMerchantPlatformId)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatform) SetCreatedDate(createdDate *time.Time) {
	m.CreatedDate = createdDate
	m.require(merchantPlatformFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatform) SetLastModifiedDate(lastModifiedDate *time.Time) {
	m.LastModifiedDate = lastModifiedDate
	m.require(merchantPlatformFieldLastModifiedDate)
}

// SetBusiness sets the Business field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatform) SetBusiness(business *Business) {
	m.Business = business
	m.require(merchantPlatformFieldBusiness)
}

// SetProcessingAccounts sets the ProcessingAccounts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatform) SetProcessingAccounts(processingAccounts []*MerchantPlatformProcessingAccountsItem) {
	m.ProcessingAccounts = processingAccounts
	m.require(merchantPlatformFieldProcessingAccounts)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatform) SetMetadata(metadata map[string]string) {
	m.Metadata = metadata
	m.require(merchantPlatformFieldMetadata)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatform) SetLinks(links []*Link) {
	m.Links = links
	m.require(merchantPlatformFieldLinks)
}

func (m *MerchantPlatform) UnmarshalJSON(data []byte) error {
	type embed MerchantPlatform
	var unmarshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MerchantPlatform(unmarshaler.embed)
	m.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	m.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantPlatform) MarshalJSON() ([]byte, error) {
	type embed MerchantPlatform
	var marshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*m),
		CreatedDate:      internal.NewOptionalDateTime(m.CreatedDate),
		LastModifiedDate: internal.NewOptionalDateTime(m.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MerchantPlatform) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	merchantPlatformProcessingAccountsItemFieldProcessingAccountId = big.NewInt(1 << 0)
	merchantPlatformProcessingAccountsItemFieldDoingBusinessAs     = big.NewInt(1 << 1)
	merchantPlatformProcessingAccountsItemFieldStatus              = big.NewInt(1 << 2)
	merchantPlatformProcessingAccountsItemFieldLink                = big.NewInt(1 << 3)
	merchantPlatformProcessingAccountsItemFieldSignature           = big.NewInt(1 << 4)
)

type MerchantPlatformProcessingAccountsItem struct {
	// Unique identifier that we assigned to the processing account.
	ProcessingAccountId *string `json:"processingAccountId,omitempty" url:"processingAccountId,omitempty"`
	// Trading name of the business.
	DoingBusinessAs string `json:"doingBusinessAs" url:"doingBusinessAs"`
	// Status of the processing account.
	// - `entered` - We have received information about the account, but we have not yet reviewed it.
	// - `pending` - We have reviewed the information about the account, but we have not yet approved it.
	// - `approved` - We have approved the account for processing transactions and funding.
	// - `subjectTo` - We have approved the account, but we are waiting on further information.
	// - `dormant` - Account is closed for a period.
	// - `nonProcessing` - We have approved the account, but the merchant has not yet run a transaction.
	// - `rejected` - We rejected the application for the processing account.
	// - `terminated` - Processing account is closed.
	// - `cancelled` - Merchant withdrew the application for the processing account.
	// - `failed` - An error occurred while we were setting up the processing account.
	//
	// **Note**: You can subscribe to our processingAccount.status.changed event to get notifications when we change the status of a processing account. For more information about how to subscribe to events, go to [Event Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).
	Status *MerchantPlatformProcessingAccountsItemStatus `json:"status,omitempty" url:"status,omitempty"`
	// Object that contains HATEOAS links for the processing account.
	Link      *MerchantPlatformProcessingAccountsItemLink `json:"link,omitempty" url:"link,omitempty"`
	Signature *Signature                                  `json:"signature,omitempty" url:"signature,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantPlatformProcessingAccountsItem) GetProcessingAccountId() *string {
	if m == nil {
		return nil
	}
	return m.ProcessingAccountId
}

func (m *MerchantPlatformProcessingAccountsItem) GetDoingBusinessAs() string {
	if m == nil {
		return ""
	}
	return m.DoingBusinessAs
}

func (m *MerchantPlatformProcessingAccountsItem) GetStatus() *MerchantPlatformProcessingAccountsItemStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

func (m *MerchantPlatformProcessingAccountsItem) GetLink() *MerchantPlatformProcessingAccountsItemLink {
	if m == nil {
		return nil
	}
	return m.Link
}

func (m *MerchantPlatformProcessingAccountsItem) GetSignature() *Signature {
	if m == nil {
		return nil
	}
	return m.Signature
}

func (m *MerchantPlatformProcessingAccountsItem) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantPlatformProcessingAccountsItem) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetProcessingAccountId sets the ProcessingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItem) SetProcessingAccountId(processingAccountId *string) {
	m.ProcessingAccountId = processingAccountId
	m.require(merchantPlatformProcessingAccountsItemFieldProcessingAccountId)
}

// SetDoingBusinessAs sets the DoingBusinessAs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItem) SetDoingBusinessAs(doingBusinessAs string) {
	m.DoingBusinessAs = doingBusinessAs
	m.require(merchantPlatformProcessingAccountsItemFieldDoingBusinessAs)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItem) SetStatus(status *MerchantPlatformProcessingAccountsItemStatus) {
	m.Status = status
	m.require(merchantPlatformProcessingAccountsItemFieldStatus)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItem) SetLink(link *MerchantPlatformProcessingAccountsItemLink) {
	m.Link = link
	m.require(merchantPlatformProcessingAccountsItemFieldLink)
}

// SetSignature sets the Signature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItem) SetSignature(signature *Signature) {
	m.Signature = signature
	m.require(merchantPlatformProcessingAccountsItemFieldSignature)
}

func (m *MerchantPlatformProcessingAccountsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantPlatformProcessingAccountsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantPlatformProcessingAccountsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantPlatformProcessingAccountsItem) MarshalJSON() ([]byte, error) {
	type embed MerchantPlatformProcessingAccountsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MerchantPlatformProcessingAccountsItem) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Object that contains HATEOAS links for the processing account.
var (
	merchantPlatformProcessingAccountsItemLinkFieldRel    = big.NewInt(1 << 0)
	merchantPlatformProcessingAccountsItemLinkFieldHref   = big.NewInt(1 << 1)
	merchantPlatformProcessingAccountsItemLinkFieldMethod = big.NewInt(1 << 2)
)

type MerchantPlatformProcessingAccountsItemLink struct {
	// Relationship to the parent resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// Link to the resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`
	// HTTP method you can use to retrieve the resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantPlatformProcessingAccountsItemLink) GetRel() *string {
	if m == nil {
		return nil
	}
	return m.Rel
}

func (m *MerchantPlatformProcessingAccountsItemLink) GetHref() *string {
	if m == nil {
		return nil
	}
	return m.Href
}

func (m *MerchantPlatformProcessingAccountsItemLink) GetMethod() *string {
	if m == nil {
		return nil
	}
	return m.Method
}

func (m *MerchantPlatformProcessingAccountsItemLink) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantPlatformProcessingAccountsItemLink) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItemLink) SetRel(rel *string) {
	m.Rel = rel
	m.require(merchantPlatformProcessingAccountsItemLinkFieldRel)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItemLink) SetHref(href *string) {
	m.Href = href
	m.require(merchantPlatformProcessingAccountsItemLinkFieldHref)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantPlatformProcessingAccountsItemLink) SetMethod(method *string) {
	m.Method = method
	m.require(merchantPlatformProcessingAccountsItemLinkFieldMethod)
}

func (m *MerchantPlatformProcessingAccountsItemLink) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantPlatformProcessingAccountsItemLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantPlatformProcessingAccountsItemLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantPlatformProcessingAccountsItemLink) MarshalJSON() ([]byte, error) {
	type embed MerchantPlatformProcessingAccountsItemLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MerchantPlatformProcessingAccountsItemLink) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Status of the processing account.
// - `entered` - We have received information about the account, but we have not yet reviewed it.
// - `pending` - We have reviewed the information about the account, but we have not yet approved it.
// - `approved` - We have approved the account for processing transactions and funding.
// - `subjectTo` - We have approved the account, but we are waiting on further information.
// - `dormant` - Account is closed for a period.
// - `nonProcessing` - We have approved the account, but the merchant has not yet run a transaction.
// - `rejected` - We rejected the application for the processing account.
// - `terminated` - Processing account is closed.
// - `cancelled` - Merchant withdrew the application for the processing account.
// - `failed` - An error occurred while we were setting up the processing account.
//
// **Note**: You can subscribe to our processingAccount.status.changed event to get notifications when we change the status of a processing account. For more information about how to subscribe to events, go to [Event Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).
type MerchantPlatformProcessingAccountsItemStatus string

const (
	MerchantPlatformProcessingAccountsItemStatusEntered       MerchantPlatformProcessingAccountsItemStatus = "entered"
	MerchantPlatformProcessingAccountsItemStatusPending       MerchantPlatformProcessingAccountsItemStatus = "pending"
	MerchantPlatformProcessingAccountsItemStatusApproved      MerchantPlatformProcessingAccountsItemStatus = "approved"
	MerchantPlatformProcessingAccountsItemStatusSubjectTo     MerchantPlatformProcessingAccountsItemStatus = "subjectTo"
	MerchantPlatformProcessingAccountsItemStatusDormant       MerchantPlatformProcessingAccountsItemStatus = "dormant"
	MerchantPlatformProcessingAccountsItemStatusNonProcessing MerchantPlatformProcessingAccountsItemStatus = "nonProcessing"
	MerchantPlatformProcessingAccountsItemStatusRejected      MerchantPlatformProcessingAccountsItemStatus = "rejected"
	MerchantPlatformProcessingAccountsItemStatusTerminated    MerchantPlatformProcessingAccountsItemStatus = "terminated"
	MerchantPlatformProcessingAccountsItemStatusCancelled     MerchantPlatformProcessingAccountsItemStatus = "cancelled"
	MerchantPlatformProcessingAccountsItemStatusFailed        MerchantPlatformProcessingAccountsItemStatus = "failed"
)

func NewMerchantPlatformProcessingAccountsItemStatusFromString(s string) (MerchantPlatformProcessingAccountsItemStatus, error) {
	switch s {
	case "entered":
		return MerchantPlatformProcessingAccountsItemStatusEntered, nil
	case "pending":
		return MerchantPlatformProcessingAccountsItemStatusPending, nil
	case "approved":
		return MerchantPlatformProcessingAccountsItemStatusApproved, nil
	case "subjectTo":
		return MerchantPlatformProcessingAccountsItemStatusSubjectTo, nil
	case "dormant":
		return MerchantPlatformProcessingAccountsItemStatusDormant, nil
	case "nonProcessing":
		return MerchantPlatformProcessingAccountsItemStatusNonProcessing, nil
	case "rejected":
		return MerchantPlatformProcessingAccountsItemStatusRejected, nil
	case "terminated":
		return MerchantPlatformProcessingAccountsItemStatusTerminated, nil
	case "cancelled":
		return MerchantPlatformProcessingAccountsItemStatusCancelled, nil
	case "failed":
		return MerchantPlatformProcessingAccountsItemStatusFailed, nil
	}
	var t MerchantPlatformProcessingAccountsItemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MerchantPlatformProcessingAccountsItemStatus) Ptr() *MerchantPlatformProcessingAccountsItemStatus {
	return &m
}

// Object that contains information about the merchant.
var (
	merchantSummaryFieldMerchantId          = big.NewInt(1 << 0)
	merchantSummaryFieldDoingBusinessAs     = big.NewInt(1 << 1)
	merchantSummaryFieldProcessingAccountId = big.NewInt(1 << 2)
	merchantSummaryFieldLink                = big.NewInt(1 << 3)
)

type MerchantSummary struct {
	// Unique identifier that the processor assigned to the merchant.
	MerchantId *string `json:"merchantId,omitempty" url:"merchantId,omitempty"`
	// Trading name of the business.
	DoingBusinessAs *string `json:"doingBusinessAs,omitempty" url:"doingBusinessAs,omitempty"`
	// Unique identifier that we assigned to the processing account.
	ProcessingAccountId *int  `json:"processingAccountId,omitempty" url:"processingAccountId,omitempty"`
	Link                *Link `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantSummary) GetMerchantId() *string {
	if m == nil {
		return nil
	}
	return m.MerchantId
}

func (m *MerchantSummary) GetDoingBusinessAs() *string {
	if m == nil {
		return nil
	}
	return m.DoingBusinessAs
}

func (m *MerchantSummary) GetProcessingAccountId() *int {
	if m == nil {
		return nil
	}
	return m.ProcessingAccountId
}

func (m *MerchantSummary) GetLink() *Link {
	if m == nil {
		return nil
	}
	return m.Link
}

func (m *MerchantSummary) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantSummary) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetMerchantId sets the MerchantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantSummary) SetMerchantId(merchantId *string) {
	m.MerchantId = merchantId
	m.require(merchantSummaryFieldMerchantId)
}

// SetDoingBusinessAs sets the DoingBusinessAs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantSummary) SetDoingBusinessAs(doingBusinessAs *string) {
	m.DoingBusinessAs = doingBusinessAs
	m.require(merchantSummaryFieldDoingBusinessAs)
}

// SetProcessingAccountId sets the ProcessingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantSummary) SetProcessingAccountId(processingAccountId *int) {
	m.ProcessingAccountId = processingAccountId
	m.require(merchantSummaryFieldProcessingAccountId)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MerchantSummary) SetLink(link *Link) {
	m.Link = link
	m.require(merchantSummaryFieldLink)
}

func (m *MerchantSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantSummary) MarshalJSON() ([]byte, error) {
	type embed MerchantSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MerchantSummary) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type Notification struct {
	Type    string
	Webhook *Webhook
}

func (n *Notification) GetType() string {
	if n == nil {
		return ""
	}
	return n.Type
}

func (n *Notification) GetWebhook() *Webhook {
	if n == nil {
		return nil
	}
	return n.Webhook
}

func (n *Notification) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", n)
	}
	switch unmarshaler.Type {
	case "webhook":
		value := new(Webhook)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Webhook = value
	}
	return nil
}

func (n Notification) MarshalJSON() ([]byte, error) {
	if err := n.validate(); err != nil {
		return nil, err
	}
	if n.Webhook != nil {
		return internal.MarshalJSONWithExtraProperty(n.Webhook, "type", "webhook")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NotificationVisitor interface {
	VisitWebhook(*Webhook) error
}

func (n *Notification) Accept(visitor NotificationVisitor) error {
	if n.Webhook != nil {
		return visitor.VisitWebhook(n.Webhook)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

func (n *Notification) validate() error {
	if n == nil {
		return fmt.Errorf("type %T is nil", n)
	}
	var fields []string
	if n.Webhook != nil {
		fields = append(fields, "webhook")
	}
	if len(fields) == 0 {
		if n.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", n, n.Type)
		}
		return fmt.Errorf("type %T is empty", n)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", n, fields)
	}
	if n.Type != "" {
		field := fields[0]
		if n.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				n,
				n.Type,
				n,
			)
		}
	}
	return nil
}

// Object that contains information about the transaction if the merchant ran it when the terminal was offline.
var (
	offlineProcessingFieldOperation    = big.NewInt(1 << 0)
	offlineProcessingFieldApprovalCode = big.NewInt(1 << 1)
	offlineProcessingFieldDateTime     = big.NewInt(1 << 2)
)

type OfflineProcessing struct {
	// Status of the transaction.
	Operation OfflineProcessingOperation `json:"operation" url:"operation"`
	// Approval code for the transaction from the processor.
	ApprovalCode *string `json:"approvalCode,omitempty" url:"approvalCode,omitempty"`
	// Date and time that the merchant ran the transaction. The date follows the ISO 8601 standard.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OfflineProcessing) GetOperation() OfflineProcessingOperation {
	if o == nil {
		return ""
	}
	return o.Operation
}

func (o *OfflineProcessing) GetApprovalCode() *string {
	if o == nil {
		return nil
	}
	return o.ApprovalCode
}

func (o *OfflineProcessing) GetDateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.DateTime
}

func (o *OfflineProcessing) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OfflineProcessing) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetOperation sets the Operation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OfflineProcessing) SetOperation(operation OfflineProcessingOperation) {
	o.Operation = operation
	o.require(offlineProcessingFieldOperation)
}

// SetApprovalCode sets the ApprovalCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OfflineProcessing) SetApprovalCode(approvalCode *string) {
	o.ApprovalCode = approvalCode
	o.require(offlineProcessingFieldApprovalCode)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OfflineProcessing) SetDateTime(dateTime *time.Time) {
	o.DateTime = dateTime
	o.require(offlineProcessingFieldDateTime)
}

func (o *OfflineProcessing) UnmarshalJSON(data []byte) error {
	type embed OfflineProcessing
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = OfflineProcessing(unmarshaler.embed)
	o.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OfflineProcessing) MarshalJSON() ([]byte, error) {
	type embed OfflineProcessing
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*o),
		DateTime: internal.NewOptionalDateTime(o.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OfflineProcessing) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Status of the transaction.
type OfflineProcessingOperation string

const (
	OfflineProcessingOperationOfflineDecline        OfflineProcessingOperation = "offlineDecline"
	OfflineProcessingOperationOfflineApproval       OfflineProcessingOperation = "offlineApproval"
	OfflineProcessingOperationDeferredAuthorization OfflineProcessingOperation = "deferredAuthorization"
)

func NewOfflineProcessingOperationFromString(s string) (OfflineProcessingOperation, error) {
	switch s {
	case "offlineDecline":
		return OfflineProcessingOperationOfflineDecline, nil
	case "offlineApproval":
		return OfflineProcessingOperationOfflineApproval, nil
	case "deferredAuthorization":
		return OfflineProcessingOperationDeferredAuthorization, nil
	}
	var t OfflineProcessingOperation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OfflineProcessingOperation) Ptr() *OfflineProcessingOperation {
	return &o
}

// Object that contains details about the transaction.
var (
	orderFieldOrderId     = big.NewInt(1 << 0)
	orderFieldDateTime    = big.NewInt(1 << 1)
	orderFieldDescription = big.NewInt(1 << 2)
	orderFieldAmount      = big.NewInt(1 << 3)
	orderFieldCurrency    = big.NewInt(1 << 4)
)

type Order struct {
	// Unique identifier that the merchant assigns to the transaction.
	OrderId string `json:"orderId" url:"orderId"`
	// Date and time that the processor processed the transaction. Our gateway returns this value in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total amount of the transaction. The value is in the currency’s lowest denomination, for example, cents.
	Amount   int64    `json:"amount" url:"amount"`
	Currency Currency `json:"currency" url:"currency"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Order) GetOrderId() string {
	if o == nil {
		return ""
	}
	return o.OrderId
}

func (o *Order) GetDateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.DateTime
}

func (o *Order) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Order) GetAmount() int64 {
	if o == nil {
		return 0
	}
	return o.Amount
}

func (o *Order) GetCurrency() Currency {
	if o == nil {
		return ""
	}
	return o.Currency
}

func (o *Order) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Order) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Order) SetOrderId(orderId string) {
	o.OrderId = orderId
	o.require(orderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Order) SetDateTime(dateTime *time.Time) {
	o.DateTime = dateTime
	o.require(orderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Order) SetDescription(description *string) {
	o.Description = description
	o.require(orderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Order) SetAmount(amount int64) {
	o.Amount = amount
	o.require(orderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Order) SetCurrency(currency Currency) {
	o.Currency = currency
	o.require(orderFieldCurrency)
}

func (o *Order) UnmarshalJSON(data []byte) error {
	type embed Order
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Order(unmarshaler.embed)
	o.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Order) MarshalJSON() ([]byte, error) {
	type embed Order
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*o),
		DateTime: internal.NewOptionalDateTime(o.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *Order) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that contains information about the adjustment to the transaction. Send this object if the merchant is adjusting the order details.
var (
	orderAdjustmentFieldAmount    = big.NewInt(1 << 0)
	orderAdjustmentFieldBreakdown = big.NewInt(1 << 1)
)

type OrderAdjustment struct {
	// Total amount of the transaction.
	Amount    int64                `json:"amount" url:"amount"`
	Breakdown *BreakdownAdjustment `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderAdjustment) GetAmount() int64 {
	if o == nil {
		return 0
	}
	return o.Amount
}

func (o *OrderAdjustment) GetBreakdown() *BreakdownAdjustment {
	if o == nil {
		return nil
	}
	return o.Breakdown
}

func (o *OrderAdjustment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderAdjustment) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderAdjustment) SetAmount(amount int64) {
	o.Amount = amount
	o.require(orderAdjustmentFieldAmount)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderAdjustment) SetBreakdown(breakdown *BreakdownAdjustment) {
	o.Breakdown = breakdown
	o.require(orderAdjustmentFieldBreakdown)
}

func (o *OrderAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderAdjustment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderAdjustment) MarshalJSON() ([]byte, error) {
	type embed OrderAdjustment
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderAdjustment) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	orderItemFieldType               = big.NewInt(1 << 0)
	orderItemFieldSolutionTemplateId = big.NewInt(1 << 1)
	orderItemFieldSolutionQuantity   = big.NewInt(1 << 2)
	orderItemFieldDeviceCondition    = big.NewInt(1 << 3)
	orderItemFieldSolutionSetup      = big.NewInt(1 << 4)
)

type OrderItem struct {
	// Type of item.
	Type OrderItemType `json:"type" url:"type"`
	// Unique identifier of the solution. Send one of the following values:
	// - `Roc Services_DX8000`
	// - `Roc Services_DX4000`
	// - `Roc Services_Web`
	// - `Roc Services_Mobile`
	// - `Payroc DX8000`
	// - `Payroc DX4000`
	// - `Payroc RX7000_Cloud`
	// - `Payroc DX8000_Cloud`
	// - `Payroc DX4000_Cloud`
	// - `Payroc A920Pro`
	// - `Payroc A80`
	// - `Payroc A920Pro_Cloud`
	// - `Payroc A80_Cloud`
	// - `Roc Terminal Plus_N950`
	// - `Roc Terminal Plus_N950-S`
	// - `Roc Terminal Plus_X800`
	// - `Gateway_Payroc`
	// - `VAR_Only_TSYS`
	// - `ROC Services Chipper3X`
	// - `BBPOS Chipper 3X`
	// - `Augusta EMV`
	// - `Ingenico - AXIUM Full Functional Base`
	// - `Pax A920 Charging Base`
	// - `Pax A920 Comms Base`
	// - `A920 Pro Ethernet`
	// - `Axium Bundle`
	SolutionTemplateId string `json:"solutionTemplateId" url:"solutionTemplateId"`
	// Quantity of the solution.
	SolutionQuantity *int `json:"solutionQuantity,omitempty" url:"solutionQuantity,omitempty"`
	// Indicates if the order contains a new item or a refurbished item.
	DeviceCondition *OrderItemDeviceCondition `json:"deviceCondition,omitempty" url:"deviceCondition,omitempty"`
	// Object that contains the settings for the solution, including gateway settings, device settings, and application settings.
	SolutionSetup *OrderItemSolutionSetup `json:"solutionSetup,omitempty" url:"solutionSetup,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItem) GetType() OrderItemType {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *OrderItem) GetSolutionTemplateId() string {
	if o == nil {
		return ""
	}
	return o.SolutionTemplateId
}

func (o *OrderItem) GetSolutionQuantity() *int {
	if o == nil {
		return nil
	}
	return o.SolutionQuantity
}

func (o *OrderItem) GetDeviceCondition() *OrderItemDeviceCondition {
	if o == nil {
		return nil
	}
	return o.DeviceCondition
}

func (o *OrderItem) GetSolutionSetup() *OrderItemSolutionSetup {
	if o == nil {
		return nil
	}
	return o.SolutionSetup
}

func (o *OrderItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItem) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItem) SetType(type_ OrderItemType) {
	o.Type = type_
	o.require(orderItemFieldType)
}

// SetSolutionTemplateId sets the SolutionTemplateId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItem) SetSolutionTemplateId(solutionTemplateId string) {
	o.SolutionTemplateId = solutionTemplateId
	o.require(orderItemFieldSolutionTemplateId)
}

// SetSolutionQuantity sets the SolutionQuantity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItem) SetSolutionQuantity(solutionQuantity *int) {
	o.SolutionQuantity = solutionQuantity
	o.require(orderItemFieldSolutionQuantity)
}

// SetDeviceCondition sets the DeviceCondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItem) SetDeviceCondition(deviceCondition *OrderItemDeviceCondition) {
	o.DeviceCondition = deviceCondition
	o.require(orderItemFieldDeviceCondition)
}

// SetSolutionSetup sets the SolutionSetup field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItem) SetSolutionSetup(solutionSetup *OrderItemSolutionSetup) {
	o.SolutionSetup = solutionSetup
	o.require(orderItemFieldSolutionSetup)
}

func (o *OrderItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItem) MarshalJSON() ([]byte, error) {
	type embed OrderItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItem) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates if the order contains a new item or a refurbished item.
type OrderItemDeviceCondition string

const (
	OrderItemDeviceConditionNew         OrderItemDeviceCondition = "new"
	OrderItemDeviceConditionRefurbished OrderItemDeviceCondition = "refurbished"
)

func NewOrderItemDeviceConditionFromString(s string) (OrderItemDeviceCondition, error) {
	switch s {
	case "new":
		return OrderItemDeviceConditionNew, nil
	case "refurbished":
		return OrderItemDeviceConditionRefurbished, nil
	}
	var t OrderItemDeviceCondition
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderItemDeviceCondition) Ptr() *OrderItemDeviceCondition {
	return &o
}

// Object that contains the settings for the solution, including gateway settings, device settings, and application settings.
var (
	orderItemSolutionSetupFieldTimezone             = big.NewInt(1 << 0)
	orderItemSolutionSetupFieldIndustryTemplateId   = big.NewInt(1 << 1)
	orderItemSolutionSetupFieldGatewaySettings      = big.NewInt(1 << 2)
	orderItemSolutionSetupFieldApplicationSettings  = big.NewInt(1 << 3)
	orderItemSolutionSetupFieldDeviceSettings       = big.NewInt(1 << 4)
	orderItemSolutionSetupFieldBatchClosure         = big.NewInt(1 << 5)
	orderItemSolutionSetupFieldReceiptNotifications = big.NewInt(1 << 6)
	orderItemSolutionSetupFieldTaxes                = big.NewInt(1 << 7)
	orderItemSolutionSetupFieldTips                 = big.NewInt(1 << 8)
	orderItemSolutionSetupFieldTokenization         = big.NewInt(1 << 9)
)

type OrderItemSolutionSetup struct {
	Timezone *SchemasTimezone `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Unique identifier of the industry template you want to apply to the solution. Send one of the following values:
	// - `Retail`
	// - `Restaurant`
	// - `Moto`
	// - `Ecommerce`
	IndustryTemplateId *string `json:"industryTemplateId,omitempty" url:"industryTemplateId,omitempty"`
	// Object that contains the gateway settings for the solution.
	GatewaySettings *OrderItemSolutionSetupGatewaySettings `json:"gatewaySettings,omitempty" url:"gatewaySettings,omitempty"`
	// Object that contains the application settings for the solution.
	ApplicationSettings *OrderItemSolutionSetupApplicationSettings `json:"applicationSettings,omitempty" url:"applicationSettings,omitempty"`
	// Object that contains the device settings if the solution includes a terminal or a peripheral device such as a printer.
	DeviceSettings *OrderItemSolutionSetupDeviceSettings `json:"deviceSettings,omitempty" url:"deviceSettings,omitempty"`
	// Object that contains information about when and how the terminal closes the batch.
	BatchClosure *OrderItemSolutionSetupBatchClosure `json:"batchClosure,omitempty" url:"batchClosure,omitempty"`
	// Object that indicates if the terminal can send email receipts, text receipts, or both.
	ReceiptNotifications *OrderItemSolutionSetupReceiptNotifications `json:"receiptNotifications,omitempty" url:"receiptNotifications,omitempty"`
	// Array of tax objects that contains the taxes that apply to the merchant's transactions.
	Taxes []*OrderItemSolutionSetupTaxesItem `json:"taxes,omitempty" url:"taxes,omitempty"`
	// Object that contains the tip options for transactions ran on the terminal.
	Tips *OrderItemSolutionSetupTips `json:"tips,omitempty" url:"tips,omitempty"`
	// Indicates if the terminal can tokenize customer's payment details. For more information about tokenization, go to [Tokenization.](https://docs.payroc.com/knowledge/basic-concepts/tokenization)
	Tokenization *bool `json:"tokenization,omitempty" url:"tokenization,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetup) GetTimezone() *SchemasTimezone {
	if o == nil {
		return nil
	}
	return o.Timezone
}

func (o *OrderItemSolutionSetup) GetIndustryTemplateId() *string {
	if o == nil {
		return nil
	}
	return o.IndustryTemplateId
}

func (o *OrderItemSolutionSetup) GetGatewaySettings() *OrderItemSolutionSetupGatewaySettings {
	if o == nil {
		return nil
	}
	return o.GatewaySettings
}

func (o *OrderItemSolutionSetup) GetApplicationSettings() *OrderItemSolutionSetupApplicationSettings {
	if o == nil {
		return nil
	}
	return o.ApplicationSettings
}

func (o *OrderItemSolutionSetup) GetDeviceSettings() *OrderItemSolutionSetupDeviceSettings {
	if o == nil {
		return nil
	}
	return o.DeviceSettings
}

func (o *OrderItemSolutionSetup) GetBatchClosure() *OrderItemSolutionSetupBatchClosure {
	if o == nil {
		return nil
	}
	return o.BatchClosure
}

func (o *OrderItemSolutionSetup) GetReceiptNotifications() *OrderItemSolutionSetupReceiptNotifications {
	if o == nil {
		return nil
	}
	return o.ReceiptNotifications
}

func (o *OrderItemSolutionSetup) GetTaxes() []*OrderItemSolutionSetupTaxesItem {
	if o == nil {
		return nil
	}
	return o.Taxes
}

func (o *OrderItemSolutionSetup) GetTips() *OrderItemSolutionSetupTips {
	if o == nil {
		return nil
	}
	return o.Tips
}

func (o *OrderItemSolutionSetup) GetTokenization() *bool {
	if o == nil {
		return nil
	}
	return o.Tokenization
}

func (o *OrderItemSolutionSetup) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetup) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetTimezone(timezone *SchemasTimezone) {
	o.Timezone = timezone
	o.require(orderItemSolutionSetupFieldTimezone)
}

// SetIndustryTemplateId sets the IndustryTemplateId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetIndustryTemplateId(industryTemplateId *string) {
	o.IndustryTemplateId = industryTemplateId
	o.require(orderItemSolutionSetupFieldIndustryTemplateId)
}

// SetGatewaySettings sets the GatewaySettings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetGatewaySettings(gatewaySettings *OrderItemSolutionSetupGatewaySettings) {
	o.GatewaySettings = gatewaySettings
	o.require(orderItemSolutionSetupFieldGatewaySettings)
}

// SetApplicationSettings sets the ApplicationSettings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetApplicationSettings(applicationSettings *OrderItemSolutionSetupApplicationSettings) {
	o.ApplicationSettings = applicationSettings
	o.require(orderItemSolutionSetupFieldApplicationSettings)
}

// SetDeviceSettings sets the DeviceSettings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetDeviceSettings(deviceSettings *OrderItemSolutionSetupDeviceSettings) {
	o.DeviceSettings = deviceSettings
	o.require(orderItemSolutionSetupFieldDeviceSettings)
}

// SetBatchClosure sets the BatchClosure field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetBatchClosure(batchClosure *OrderItemSolutionSetupBatchClosure) {
	o.BatchClosure = batchClosure
	o.require(orderItemSolutionSetupFieldBatchClosure)
}

// SetReceiptNotifications sets the ReceiptNotifications field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetReceiptNotifications(receiptNotifications *OrderItemSolutionSetupReceiptNotifications) {
	o.ReceiptNotifications = receiptNotifications
	o.require(orderItemSolutionSetupFieldReceiptNotifications)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetTaxes(taxes []*OrderItemSolutionSetupTaxesItem) {
	o.Taxes = taxes
	o.require(orderItemSolutionSetupFieldTaxes)
}

// SetTips sets the Tips field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetTips(tips *OrderItemSolutionSetupTips) {
	o.Tips = tips
	o.require(orderItemSolutionSetupFieldTips)
}

// SetTokenization sets the Tokenization field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetup) SetTokenization(tokenization *bool) {
	o.Tokenization = tokenization
	o.require(orderItemSolutionSetupFieldTokenization)
}

func (o *OrderItemSolutionSetup) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetup) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetup
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetup) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that contains the application settings for the solution.
var (
	orderItemSolutionSetupApplicationSettingsFieldClerkPrompt = big.NewInt(1 << 0)
	orderItemSolutionSetupApplicationSettingsFieldSecurity    = big.NewInt(1 << 1)
)

type OrderItemSolutionSetupApplicationSettings struct {
	// Indicates if the terminal should prompt the clerk, for example, if the terminal should prompt when the clerk needs to enter an amount on the terminal.
	ClerkPrompt *bool `json:"clerkPrompt,omitempty" url:"clerkPrompt,omitempty"`
	// Object that contains the password settings when running specific transaction types.
	Security *OrderItemSolutionSetupApplicationSettingsSecurity `json:"security,omitempty" url:"security,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetupApplicationSettings) GetClerkPrompt() *bool {
	if o == nil {
		return nil
	}
	return o.ClerkPrompt
}

func (o *OrderItemSolutionSetupApplicationSettings) GetSecurity() *OrderItemSolutionSetupApplicationSettingsSecurity {
	if o == nil {
		return nil
	}
	return o.Security
}

func (o *OrderItemSolutionSetupApplicationSettings) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetupApplicationSettings) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetClerkPrompt sets the ClerkPrompt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupApplicationSettings) SetClerkPrompt(clerkPrompt *bool) {
	o.ClerkPrompt = clerkPrompt
	o.require(orderItemSolutionSetupApplicationSettingsFieldClerkPrompt)
}

// SetSecurity sets the Security field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupApplicationSettings) SetSecurity(security *OrderItemSolutionSetupApplicationSettingsSecurity) {
	o.Security = security
	o.require(orderItemSolutionSetupApplicationSettingsFieldSecurity)
}

func (o *OrderItemSolutionSetupApplicationSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetupApplicationSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetupApplicationSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetupApplicationSettings) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetupApplicationSettings
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetupApplicationSettings) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that contains the password settings when running specific transaction types.
var (
	orderItemSolutionSetupApplicationSettingsSecurityFieldRefundPassword    = big.NewInt(1 << 0)
	orderItemSolutionSetupApplicationSettingsSecurityFieldKeyedSalePassword = big.NewInt(1 << 1)
	orderItemSolutionSetupApplicationSettingsSecurityFieldReversalPassword  = big.NewInt(1 << 2)
)

type OrderItemSolutionSetupApplicationSettingsSecurity struct {
	// Indicates if the terminal should prompt the clerk for a password when running a refund.
	RefundPassword *bool `json:"refundPassword,omitempty" url:"refundPassword,omitempty"`
	// Indicates if the terminal should prompt the clerk for a password when running a keyed sale.
	KeyedSalePassword *bool `json:"keyedSalePassword,omitempty" url:"keyedSalePassword,omitempty"`
	// Indicates if the terminal should prompt the clerk for a password when cancelling a transaction.
	ReversalPassword *bool `json:"reversalPassword,omitempty" url:"reversalPassword,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) GetRefundPassword() *bool {
	if o == nil {
		return nil
	}
	return o.RefundPassword
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) GetKeyedSalePassword() *bool {
	if o == nil {
		return nil
	}
	return o.KeyedSalePassword
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) GetReversalPassword() *bool {
	if o == nil {
		return nil
	}
	return o.ReversalPassword
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetRefundPassword sets the RefundPassword field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupApplicationSettingsSecurity) SetRefundPassword(refundPassword *bool) {
	o.RefundPassword = refundPassword
	o.require(orderItemSolutionSetupApplicationSettingsSecurityFieldRefundPassword)
}

// SetKeyedSalePassword sets the KeyedSalePassword field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupApplicationSettingsSecurity) SetKeyedSalePassword(keyedSalePassword *bool) {
	o.KeyedSalePassword = keyedSalePassword
	o.require(orderItemSolutionSetupApplicationSettingsSecurityFieldKeyedSalePassword)
}

// SetReversalPassword sets the ReversalPassword field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupApplicationSettingsSecurity) SetReversalPassword(reversalPassword *bool) {
	o.ReversalPassword = reversalPassword
	o.require(orderItemSolutionSetupApplicationSettingsSecurityFieldReversalPassword)
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetupApplicationSettingsSecurity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetupApplicationSettingsSecurity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetupApplicationSettingsSecurity
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetupApplicationSettingsSecurity) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that contains information about when and how the terminal closes the batch.
type OrderItemSolutionSetupBatchClosure struct {
	BatchCloseType string
	Automatic      *AutomaticBatchClose
	Manual         *ManualBatchClose
}

func (o *OrderItemSolutionSetupBatchClosure) GetBatchCloseType() string {
	if o == nil {
		return ""
	}
	return o.BatchCloseType
}

func (o *OrderItemSolutionSetupBatchClosure) GetAutomatic() *AutomaticBatchClose {
	if o == nil {
		return nil
	}
	return o.Automatic
}

func (o *OrderItemSolutionSetupBatchClosure) GetManual() *ManualBatchClose {
	if o == nil {
		return nil
	}
	return o.Manual
}

func (o *OrderItemSolutionSetupBatchClosure) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		BatchCloseType string `json:"batchCloseType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.BatchCloseType = unmarshaler.BatchCloseType
	if unmarshaler.BatchCloseType == "" {
		return fmt.Errorf("%T did not include discriminant batchCloseType", o)
	}
	switch unmarshaler.BatchCloseType {
	case "automatic":
		value := new(AutomaticBatchClose)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Automatic = value
	case "manual":
		value := new(ManualBatchClose)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Manual = value
	}
	return nil
}

func (o OrderItemSolutionSetupBatchClosure) MarshalJSON() ([]byte, error) {
	if err := o.validate(); err != nil {
		return nil, err
	}
	if o.Automatic != nil {
		return internal.MarshalJSONWithExtraProperty(o.Automatic, "batchCloseType", "automatic")
	}
	if o.Manual != nil {
		return internal.MarshalJSONWithExtraProperty(o.Manual, "batchCloseType", "manual")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type OrderItemSolutionSetupBatchClosureVisitor interface {
	VisitAutomatic(*AutomaticBatchClose) error
	VisitManual(*ManualBatchClose) error
}

func (o *OrderItemSolutionSetupBatchClosure) Accept(visitor OrderItemSolutionSetupBatchClosureVisitor) error {
	if o.Automatic != nil {
		return visitor.VisitAutomatic(o.Automatic)
	}
	if o.Manual != nil {
		return visitor.VisitManual(o.Manual)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

func (o *OrderItemSolutionSetupBatchClosure) validate() error {
	if o == nil {
		return fmt.Errorf("type %T is nil", o)
	}
	var fields []string
	if o.Automatic != nil {
		fields = append(fields, "automatic")
	}
	if o.Manual != nil {
		fields = append(fields, "manual")
	}
	if len(fields) == 0 {
		if o.BatchCloseType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", o, o.BatchCloseType)
		}
		return fmt.Errorf("type %T is empty", o)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", o, fields)
	}
	if o.BatchCloseType != "" {
		field := fields[0]
		if o.BatchCloseType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				o,
				o.BatchCloseType,
				o,
			)
		}
	}
	return nil
}

// Object that contains the device settings if the solution includes a terminal or a peripheral device such as a printer.
var (
	orderItemSolutionSetupDeviceSettingsFieldNumberOfMobileUsers = big.NewInt(1 << 0)
	orderItemSolutionSetupDeviceSettingsFieldCommunicationType   = big.NewInt(1 << 1)
)

type OrderItemSolutionSetupDeviceSettings struct {
	// Number of users that we need to set up for mobile solutions.
	NumberOfMobileUsers *int `json:"numberOfMobileUsers,omitempty" url:"numberOfMobileUsers,omitempty"`
	// Method of connection between a terminal or a peripheral device and the host.
	CommunicationType *OrderItemSolutionSetupDeviceSettingsCommunicationType `json:"communicationType,omitempty" url:"communicationType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetupDeviceSettings) GetNumberOfMobileUsers() *int {
	if o == nil {
		return nil
	}
	return o.NumberOfMobileUsers
}

func (o *OrderItemSolutionSetupDeviceSettings) GetCommunicationType() *OrderItemSolutionSetupDeviceSettingsCommunicationType {
	if o == nil {
		return nil
	}
	return o.CommunicationType
}

func (o *OrderItemSolutionSetupDeviceSettings) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetupDeviceSettings) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetNumberOfMobileUsers sets the NumberOfMobileUsers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupDeviceSettings) SetNumberOfMobileUsers(numberOfMobileUsers *int) {
	o.NumberOfMobileUsers = numberOfMobileUsers
	o.require(orderItemSolutionSetupDeviceSettingsFieldNumberOfMobileUsers)
}

// SetCommunicationType sets the CommunicationType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupDeviceSettings) SetCommunicationType(communicationType *OrderItemSolutionSetupDeviceSettingsCommunicationType) {
	o.CommunicationType = communicationType
	o.require(orderItemSolutionSetupDeviceSettingsFieldCommunicationType)
}

func (o *OrderItemSolutionSetupDeviceSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetupDeviceSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetupDeviceSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetupDeviceSettings) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetupDeviceSettings
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetupDeviceSettings) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Method of connection between a terminal or a peripheral device and the host.
type OrderItemSolutionSetupDeviceSettingsCommunicationType string

const (
	OrderItemSolutionSetupDeviceSettingsCommunicationTypeBluetooth OrderItemSolutionSetupDeviceSettingsCommunicationType = "bluetooth"
	OrderItemSolutionSetupDeviceSettingsCommunicationTypeCellular  OrderItemSolutionSetupDeviceSettingsCommunicationType = "cellular"
	OrderItemSolutionSetupDeviceSettingsCommunicationTypeEthernet  OrderItemSolutionSetupDeviceSettingsCommunicationType = "ethernet"
	OrderItemSolutionSetupDeviceSettingsCommunicationTypeWifi      OrderItemSolutionSetupDeviceSettingsCommunicationType = "wifi"
)

func NewOrderItemSolutionSetupDeviceSettingsCommunicationTypeFromString(s string) (OrderItemSolutionSetupDeviceSettingsCommunicationType, error) {
	switch s {
	case "bluetooth":
		return OrderItemSolutionSetupDeviceSettingsCommunicationTypeBluetooth, nil
	case "cellular":
		return OrderItemSolutionSetupDeviceSettingsCommunicationTypeCellular, nil
	case "ethernet":
		return OrderItemSolutionSetupDeviceSettingsCommunicationTypeEthernet, nil
	case "wifi":
		return OrderItemSolutionSetupDeviceSettingsCommunicationTypeWifi, nil
	}
	var t OrderItemSolutionSetupDeviceSettingsCommunicationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderItemSolutionSetupDeviceSettingsCommunicationType) Ptr() *OrderItemSolutionSetupDeviceSettingsCommunicationType {
	return &o
}

// Object that contains the gateway settings for the solution.
var (
	orderItemSolutionSetupGatewaySettingsFieldMerchantPortfolioId = big.NewInt(1 << 0)
	orderItemSolutionSetupGatewaySettingsFieldMerchantTemplateId  = big.NewInt(1 << 1)
	orderItemSolutionSetupGatewaySettingsFieldUserTemplateId      = big.NewInt(1 << 2)
	orderItemSolutionSetupGatewaySettingsFieldTerminalTemplateId  = big.NewInt(1 << 3)
)

type OrderItemSolutionSetupGatewaySettings struct {
	// Unique identifier of the merchant portfolio.
	MerchantPortfolioId *string `json:"merchantPortfolioId,omitempty" url:"merchantPortfolioId,omitempty"`
	// Unique identifier of the gateway merchant template.
	MerchantTemplateId *string `json:"merchantTemplateId,omitempty" url:"merchantTemplateId,omitempty"`
	// Unique identifier of the gateway user template.
	UserTemplateId *string `json:"userTemplateId,omitempty" url:"userTemplateId,omitempty"`
	// Unique identifier of the gateway terminal template.
	TerminalTemplateId *string `json:"terminalTemplateId,omitempty" url:"terminalTemplateId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetupGatewaySettings) GetMerchantPortfolioId() *string {
	if o == nil {
		return nil
	}
	return o.MerchantPortfolioId
}

func (o *OrderItemSolutionSetupGatewaySettings) GetMerchantTemplateId() *string {
	if o == nil {
		return nil
	}
	return o.MerchantTemplateId
}

func (o *OrderItemSolutionSetupGatewaySettings) GetUserTemplateId() *string {
	if o == nil {
		return nil
	}
	return o.UserTemplateId
}

func (o *OrderItemSolutionSetupGatewaySettings) GetTerminalTemplateId() *string {
	if o == nil {
		return nil
	}
	return o.TerminalTemplateId
}

func (o *OrderItemSolutionSetupGatewaySettings) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetupGatewaySettings) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetMerchantPortfolioId sets the MerchantPortfolioId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupGatewaySettings) SetMerchantPortfolioId(merchantPortfolioId *string) {
	o.MerchantPortfolioId = merchantPortfolioId
	o.require(orderItemSolutionSetupGatewaySettingsFieldMerchantPortfolioId)
}

// SetMerchantTemplateId sets the MerchantTemplateId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupGatewaySettings) SetMerchantTemplateId(merchantTemplateId *string) {
	o.MerchantTemplateId = merchantTemplateId
	o.require(orderItemSolutionSetupGatewaySettingsFieldMerchantTemplateId)
}

// SetUserTemplateId sets the UserTemplateId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupGatewaySettings) SetUserTemplateId(userTemplateId *string) {
	o.UserTemplateId = userTemplateId
	o.require(orderItemSolutionSetupGatewaySettingsFieldUserTemplateId)
}

// SetTerminalTemplateId sets the TerminalTemplateId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupGatewaySettings) SetTerminalTemplateId(terminalTemplateId *string) {
	o.TerminalTemplateId = terminalTemplateId
	o.require(orderItemSolutionSetupGatewaySettingsFieldTerminalTemplateId)
}

func (o *OrderItemSolutionSetupGatewaySettings) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetupGatewaySettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetupGatewaySettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetupGatewaySettings) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetupGatewaySettings
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetupGatewaySettings) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that indicates if the terminal can send email receipts, text receipts, or both.
var (
	orderItemSolutionSetupReceiptNotificationsFieldEmailReceipt = big.NewInt(1 << 0)
	orderItemSolutionSetupReceiptNotificationsFieldSmsReceipt   = big.NewInt(1 << 1)
)

type OrderItemSolutionSetupReceiptNotifications struct {
	// Indicates if the terminal can send receipts by email.
	EmailReceipt *bool `json:"emailReceipt,omitempty" url:"emailReceipt,omitempty"`
	// Indicates if the terminal can send receipts by text message.
	SmsReceipt *bool `json:"smsReceipt,omitempty" url:"smsReceipt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetupReceiptNotifications) GetEmailReceipt() *bool {
	if o == nil {
		return nil
	}
	return o.EmailReceipt
}

func (o *OrderItemSolutionSetupReceiptNotifications) GetSmsReceipt() *bool {
	if o == nil {
		return nil
	}
	return o.SmsReceipt
}

func (o *OrderItemSolutionSetupReceiptNotifications) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetupReceiptNotifications) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetEmailReceipt sets the EmailReceipt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupReceiptNotifications) SetEmailReceipt(emailReceipt *bool) {
	o.EmailReceipt = emailReceipt
	o.require(orderItemSolutionSetupReceiptNotificationsFieldEmailReceipt)
}

// SetSmsReceipt sets the SmsReceipt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupReceiptNotifications) SetSmsReceipt(smsReceipt *bool) {
	o.SmsReceipt = smsReceipt
	o.require(orderItemSolutionSetupReceiptNotificationsFieldSmsReceipt)
}

func (o *OrderItemSolutionSetupReceiptNotifications) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetupReceiptNotifications
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetupReceiptNotifications(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetupReceiptNotifications) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetupReceiptNotifications
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetupReceiptNotifications) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Tax that applies to the merchant's transactions.
var (
	orderItemSolutionSetupTaxesItemFieldTaxRate  = big.NewInt(1 << 0)
	orderItemSolutionSetupTaxesItemFieldTaxLabel = big.NewInt(1 << 1)
)

type OrderItemSolutionSetupTaxesItem struct {
	// Rate of tax that the terminal applies to each transaction.
	TaxRate float64 `json:"taxRate" url:"taxRate"`
	// Short description of the tax rate, for example, "Sales Tax".
	TaxLabel string `json:"taxLabel" url:"taxLabel"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetupTaxesItem) GetTaxRate() float64 {
	if o == nil {
		return 0
	}
	return o.TaxRate
}

func (o *OrderItemSolutionSetupTaxesItem) GetTaxLabel() string {
	if o == nil {
		return ""
	}
	return o.TaxLabel
}

func (o *OrderItemSolutionSetupTaxesItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetupTaxesItem) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetTaxRate sets the TaxRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupTaxesItem) SetTaxRate(taxRate float64) {
	o.TaxRate = taxRate
	o.require(orderItemSolutionSetupTaxesItemFieldTaxRate)
}

// SetTaxLabel sets the TaxLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupTaxesItem) SetTaxLabel(taxLabel string) {
	o.TaxLabel = taxLabel
	o.require(orderItemSolutionSetupTaxesItemFieldTaxLabel)
}

func (o *OrderItemSolutionSetupTaxesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetupTaxesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetupTaxesItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetupTaxesItem) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetupTaxesItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetupTaxesItem) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that contains the tip options for transactions ran on the terminal.
var (
	orderItemSolutionSetupTipsFieldEnabled = big.NewInt(1 << 0)
)

type OrderItemSolutionSetupTips struct {
	// Indicates if the terminal can accept tips.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderItemSolutionSetupTips) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *OrderItemSolutionSetupTips) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderItemSolutionSetupTips) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OrderItemSolutionSetupTips) SetEnabled(enabled *bool) {
	o.Enabled = enabled
	o.require(orderItemSolutionSetupTipsFieldEnabled)
}

func (o *OrderItemSolutionSetupTips) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderItemSolutionSetupTips
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderItemSolutionSetupTips(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderItemSolutionSetupTips) MarshalJSON() ([]byte, error) {
	type embed OrderItemSolutionSetupTips
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OrderItemSolutionSetupTips) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Type of item.
type OrderItemType string

const (
	OrderItemTypeSolution OrderItemType = "solution"
)

func NewOrderItemTypeFromString(s string) (OrderItemType, error) {
	switch s {
	case "solution":
		return OrderItemTypeSolution, nil
	}
	var t OrderItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderItemType) Ptr() *OrderItemType {
	return &o
}

var (
	ownerFieldOwnerId        = big.NewInt(1 << 0)
	ownerFieldFirstName      = big.NewInt(1 << 1)
	ownerFieldMiddleName     = big.NewInt(1 << 2)
	ownerFieldLastName       = big.NewInt(1 << 3)
	ownerFieldDateOfBirth    = big.NewInt(1 << 4)
	ownerFieldAddress        = big.NewInt(1 << 5)
	ownerFieldIdentifiers    = big.NewInt(1 << 6)
	ownerFieldContactMethods = big.NewInt(1 << 7)
	ownerFieldRelationship   = big.NewInt(1 << 8)
)

type Owner struct {
	// Unique identifier that we assigned to the owner.
	OwnerId *int `json:"ownerId,omitempty" url:"ownerId,omitempty"`
	// Owner's first name.
	FirstName string `json:"firstName" url:"firstName"`
	// Owner's middle name.
	MiddleName *string `json:"middleName,omitempty" url:"middleName,omitempty"`
	// Owner's last name.
	LastName string `json:"lastName" url:"lastName"`
	// Owner's date of birth. The format of this value is **YYYY-MM-DD**.
	DateOfBirth time.Time `json:"dateOfBirth" url:"dateOfBirth" format:"date"`
	Address     *Address  `json:"address" url:"address"`
	// Array of IDs.
	Identifiers []*Identifier `json:"identifiers" url:"identifiers"`
	// Array of polymorphic objects, which contain contact information.
	//
	// **Note:** If you are adding information about an owner, you must provide at least an email address. If you are adding information about a contact, you must provide at least a contact number.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods" url:"contactMethods"`
	// Object that contains information about the owner's relationship to the business.
	Relationship *OwnerRelationship `json:"relationship" url:"relationship"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Owner) GetOwnerId() *int {
	if o == nil {
		return nil
	}
	return o.OwnerId
}

func (o *Owner) GetFirstName() string {
	if o == nil {
		return ""
	}
	return o.FirstName
}

func (o *Owner) GetMiddleName() *string {
	if o == nil {
		return nil
	}
	return o.MiddleName
}

func (o *Owner) GetLastName() string {
	if o == nil {
		return ""
	}
	return o.LastName
}

func (o *Owner) GetDateOfBirth() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.DateOfBirth
}

func (o *Owner) GetAddress() *Address {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *Owner) GetIdentifiers() []*Identifier {
	if o == nil {
		return nil
	}
	return o.Identifiers
}

func (o *Owner) GetContactMethods() []*ContactMethod {
	if o == nil {
		return nil
	}
	return o.ContactMethods
}

func (o *Owner) GetRelationship() *OwnerRelationship {
	if o == nil {
		return nil
	}
	return o.Relationship
}

func (o *Owner) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Owner) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetOwnerId sets the OwnerId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetOwnerId(ownerId *int) {
	o.OwnerId = ownerId
	o.require(ownerFieldOwnerId)
}

// SetFirstName sets the FirstName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetFirstName(firstName string) {
	o.FirstName = firstName
	o.require(ownerFieldFirstName)
}

// SetMiddleName sets the MiddleName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetMiddleName(middleName *string) {
	o.MiddleName = middleName
	o.require(ownerFieldMiddleName)
}

// SetLastName sets the LastName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetLastName(lastName string) {
	o.LastName = lastName
	o.require(ownerFieldLastName)
}

// SetDateOfBirth sets the DateOfBirth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetDateOfBirth(dateOfBirth time.Time) {
	o.DateOfBirth = dateOfBirth
	o.require(ownerFieldDateOfBirth)
}

// SetAddress sets the Address field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetAddress(address *Address) {
	o.Address = address
	o.require(ownerFieldAddress)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetIdentifiers(identifiers []*Identifier) {
	o.Identifiers = identifiers
	o.require(ownerFieldIdentifiers)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetContactMethods(contactMethods []*ContactMethod) {
	o.ContactMethods = contactMethods
	o.require(ownerFieldContactMethods)
}

// SetRelationship sets the Relationship field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *Owner) SetRelationship(relationship *OwnerRelationship) {
	o.Relationship = relationship
	o.require(ownerFieldRelationship)
}

func (o *Owner) UnmarshalJSON(data []byte) error {
	type embed Owner
	var unmarshaler = struct {
		embed
		DateOfBirth *internal.Date `json:"dateOfBirth"`
	}{
		embed: embed(*o),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*o = Owner(unmarshaler.embed)
	o.DateOfBirth = unmarshaler.DateOfBirth.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Owner) MarshalJSON() ([]byte, error) {
	type embed Owner
	var marshaler = struct {
		embed
		DateOfBirth *internal.Date `json:"dateOfBirth"`
	}{
		embed:       embed(*o),
		DateOfBirth: internal.NewDate(o.DateOfBirth),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *Owner) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that contains information about the owner's relationship to the business.
var (
	ownerRelationshipFieldEquityPercentage      = big.NewInt(1 << 0)
	ownerRelationshipFieldTitle                 = big.NewInt(1 << 1)
	ownerRelationshipFieldIsControlProng        = big.NewInt(1 << 2)
	ownerRelationshipFieldIsAuthorizedSignatory = big.NewInt(1 << 3)
)

type OwnerRelationship struct {
	// Percentage equity stake that the owner holds in the business.
	EquityPercentage *float64 `json:"equityPercentage,omitempty" url:"equityPercentage,omitempty"`
	// Owner's job title.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Indicates if the owner is a control prong. You can identify only one control prong for a business.
	IsControlProng bool `json:"isControlProng" url:"isControlProng"`
	// Indicates if the owner is an authorized signatory.
	IsAuthorizedSignatory *bool `json:"isAuthorizedSignatory,omitempty" url:"isAuthorizedSignatory,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OwnerRelationship) GetEquityPercentage() *float64 {
	if o == nil {
		return nil
	}
	return o.EquityPercentage
}

func (o *OwnerRelationship) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *OwnerRelationship) GetIsControlProng() bool {
	if o == nil {
		return false
	}
	return o.IsControlProng
}

func (o *OwnerRelationship) GetIsAuthorizedSignatory() *bool {
	if o == nil {
		return nil
	}
	return o.IsAuthorizedSignatory
}

func (o *OwnerRelationship) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OwnerRelationship) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetEquityPercentage sets the EquityPercentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OwnerRelationship) SetEquityPercentage(equityPercentage *float64) {
	o.EquityPercentage = equityPercentage
	o.require(ownerRelationshipFieldEquityPercentage)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OwnerRelationship) SetTitle(title *string) {
	o.Title = title
	o.require(ownerRelationshipFieldTitle)
}

// SetIsControlProng sets the IsControlProng field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OwnerRelationship) SetIsControlProng(isControlProng bool) {
	o.IsControlProng = isControlProng
	o.require(ownerRelationshipFieldIsControlProng)
}

// SetIsAuthorizedSignatory sets the IsAuthorizedSignatory field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OwnerRelationship) SetIsAuthorizedSignatory(isAuthorizedSignatory *bool) {
	o.IsAuthorizedSignatory = isAuthorizedSignatory
	o.require(ownerRelationshipFieldIsAuthorizedSignatory)
}

func (o *OwnerRelationship) UnmarshalJSON(data []byte) error {
	type unmarshaler OwnerRelationship
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OwnerRelationship(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OwnerRelationship) MarshalJSON() ([]byte, error) {
	type embed OwnerRelationship
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OwnerRelationship) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Object that contains the customer's account details.
var (
	padBankAccountFieldNameOnAccount     = big.NewInt(1 << 0)
	padBankAccountFieldAccountNumber     = big.NewInt(1 << 1)
	padBankAccountFieldTransitNumber     = big.NewInt(1 << 2)
	padBankAccountFieldInstitutionNumber = big.NewInt(1 << 3)
	padBankAccountFieldSecureToken       = big.NewInt(1 << 4)
)

type PadBankAccount struct {
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer's bank account number. We mask all digits except the last four digits.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Five-digit code that represents the customer's banking branch.
	TransitNumber string `json:"transitNumber" url:"transitNumber"`
	// Three-digit code that represents the customer's bank.
	InstitutionNumber string              `json:"institutionNumber" url:"institutionNumber"`
	SecureToken       *SecureTokenSummary `json:"secureToken,omitempty" url:"secureToken,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PadBankAccount) GetNameOnAccount() string {
	if p == nil {
		return ""
	}
	return p.NameOnAccount
}

func (p *PadBankAccount) GetAccountNumber() string {
	if p == nil {
		return ""
	}
	return p.AccountNumber
}

func (p *PadBankAccount) GetTransitNumber() string {
	if p == nil {
		return ""
	}
	return p.TransitNumber
}

func (p *PadBankAccount) GetInstitutionNumber() string {
	if p == nil {
		return ""
	}
	return p.InstitutionNumber
}

func (p *PadBankAccount) GetSecureToken() *SecureTokenSummary {
	if p == nil {
		return nil
	}
	return p.SecureToken
}

func (p *PadBankAccount) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PadBankAccount) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadBankAccount) SetNameOnAccount(nameOnAccount string) {
	p.NameOnAccount = nameOnAccount
	p.require(padBankAccountFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadBankAccount) SetAccountNumber(accountNumber string) {
	p.AccountNumber = accountNumber
	p.require(padBankAccountFieldAccountNumber)
}

// SetTransitNumber sets the TransitNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadBankAccount) SetTransitNumber(transitNumber string) {
	p.TransitNumber = transitNumber
	p.require(padBankAccountFieldTransitNumber)
}

// SetInstitutionNumber sets the InstitutionNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadBankAccount) SetInstitutionNumber(institutionNumber string) {
	p.InstitutionNumber = institutionNumber
	p.require(padBankAccountFieldInstitutionNumber)
}

// SetSecureToken sets the SecureToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadBankAccount) SetSecureToken(secureToken *SecureTokenSummary) {
	p.SecureToken = secureToken
	p.require(padBankAccountFieldSecureToken)
}

func (p *PadBankAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler PadBankAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PadBankAccount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PadBankAccount) MarshalJSON() ([]byte, error) {
	type embed PadBankAccount
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PadBankAccount) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the payment details for the customer’s preauthorized electronic debit (PAD) transactions.
var (
	padPayloadFieldAccountType       = big.NewInt(1 << 0)
	padPayloadFieldNameOnAccount     = big.NewInt(1 << 1)
	padPayloadFieldAccountNumber     = big.NewInt(1 << 2)
	padPayloadFieldTransitNumber     = big.NewInt(1 << 3)
	padPayloadFieldInstitutionNumber = big.NewInt(1 << 4)
)

type PadPayload struct {
	// Indicates the customer’s account type.
	// **Note:** For bank account details, send a value for accountType.
	AccountType *PadPayloadAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer's account number.
	// **Note:** In responses, our gateway shows only the last four digits of the account number, for example, `*****5929`.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Five-digit number that identifies the customer's bank branch.
	TransitNumber string `json:"transitNumber" url:"transitNumber"`
	// Three-digit number that identifies the customer's bank.
	InstitutionNumber string `json:"institutionNumber" url:"institutionNumber"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PadPayload) GetAccountType() *PadPayloadAccountType {
	if p == nil {
		return nil
	}
	return p.AccountType
}

func (p *PadPayload) GetNameOnAccount() string {
	if p == nil {
		return ""
	}
	return p.NameOnAccount
}

func (p *PadPayload) GetAccountNumber() string {
	if p == nil {
		return ""
	}
	return p.AccountNumber
}

func (p *PadPayload) GetTransitNumber() string {
	if p == nil {
		return ""
	}
	return p.TransitNumber
}

func (p *PadPayload) GetInstitutionNumber() string {
	if p == nil {
		return ""
	}
	return p.InstitutionNumber
}

func (p *PadPayload) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PadPayload) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadPayload) SetAccountType(accountType *PadPayloadAccountType) {
	p.AccountType = accountType
	p.require(padPayloadFieldAccountType)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadPayload) SetNameOnAccount(nameOnAccount string) {
	p.NameOnAccount = nameOnAccount
	p.require(padPayloadFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadPayload) SetAccountNumber(accountNumber string) {
	p.AccountNumber = accountNumber
	p.require(padPayloadFieldAccountNumber)
}

// SetTransitNumber sets the TransitNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadPayload) SetTransitNumber(transitNumber string) {
	p.TransitNumber = transitNumber
	p.require(padPayloadFieldTransitNumber)
}

// SetInstitutionNumber sets the InstitutionNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadPayload) SetInstitutionNumber(institutionNumber string) {
	p.InstitutionNumber = institutionNumber
	p.require(padPayloadFieldInstitutionNumber)
}

func (p *PadPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler PadPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PadPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PadPayload) MarshalJSON() ([]byte, error) {
	type embed PadPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PadPayload) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the customer’s account type.
// **Note:** For bank account details, send a value for accountType.
type PadPayloadAccountType string

const (
	PadPayloadAccountTypeChecking PadPayloadAccountType = "checking"
	PadPayloadAccountTypeSavings  PadPayloadAccountType = "savings"
)

func NewPadPayloadAccountTypeFromString(s string) (PadPayloadAccountType, error) {
	switch s {
	case "checking":
		return PadPayloadAccountTypeChecking, nil
	case "savings":
		return PadPayloadAccountTypeSavings, nil
	}
	var t PadPayloadAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PadPayloadAccountType) Ptr() *PadPayloadAccountType {
	return &p
}

// Object that contains the customer's account details.
var (
	padSourceFieldNameOnAccount     = big.NewInt(1 << 0)
	padSourceFieldAccountNumber     = big.NewInt(1 << 1)
	padSourceFieldTransitNumber     = big.NewInt(1 << 2)
	padSourceFieldInstitutionNumber = big.NewInt(1 << 3)
)

type PadSource struct {
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer's account number.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Five-digit code that represents the customer's banking branch.
	TransitNumber string `json:"transitNumber" url:"transitNumber"`
	// Three-digit code that represents the customer's bank.
	InstitutionNumber string `json:"institutionNumber" url:"institutionNumber"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PadSource) GetNameOnAccount() string {
	if p == nil {
		return ""
	}
	return p.NameOnAccount
}

func (p *PadSource) GetAccountNumber() string {
	if p == nil {
		return ""
	}
	return p.AccountNumber
}

func (p *PadSource) GetTransitNumber() string {
	if p == nil {
		return ""
	}
	return p.TransitNumber
}

func (p *PadSource) GetInstitutionNumber() string {
	if p == nil {
		return ""
	}
	return p.InstitutionNumber
}

func (p *PadSource) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PadSource) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSource) SetNameOnAccount(nameOnAccount string) {
	p.NameOnAccount = nameOnAccount
	p.require(padSourceFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSource) SetAccountNumber(accountNumber string) {
	p.AccountNumber = accountNumber
	p.require(padSourceFieldAccountNumber)
}

// SetTransitNumber sets the TransitNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSource) SetTransitNumber(transitNumber string) {
	p.TransitNumber = transitNumber
	p.require(padSourceFieldTransitNumber)
}

// SetInstitutionNumber sets the InstitutionNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSource) SetInstitutionNumber(institutionNumber string) {
	p.InstitutionNumber = institutionNumber
	p.require(padSourceFieldInstitutionNumber)
}

func (p *PadSource) UnmarshalJSON(data []byte) error {
	type unmarshaler PadSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PadSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PadSource) MarshalJSON() ([]byte, error) {
	type embed PadSource
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PadSource) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	padSourceWithAccountTypeFieldNameOnAccount     = big.NewInt(1 << 0)
	padSourceWithAccountTypeFieldAccountNumber     = big.NewInt(1 << 1)
	padSourceWithAccountTypeFieldTransitNumber     = big.NewInt(1 << 2)
	padSourceWithAccountTypeFieldInstitutionNumber = big.NewInt(1 << 3)
	padSourceWithAccountTypeFieldAccountType       = big.NewInt(1 << 4)
)

type PadSourceWithAccountType struct {
	// Customer's name.
	NameOnAccount string `json:"nameOnAccount" url:"nameOnAccount"`
	// Customer's account number.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`
	// Five-digit code that represents the customer's banking branch.
	TransitNumber string `json:"transitNumber" url:"transitNumber"`
	// Three-digit code that represents the customer's bank.
	InstitutionNumber string `json:"institutionNumber" url:"institutionNumber"`
	// Indicates the customer's account type.
	AccountType *PadSourceWithAccountTypeAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PadSourceWithAccountType) GetNameOnAccount() string {
	if p == nil {
		return ""
	}
	return p.NameOnAccount
}

func (p *PadSourceWithAccountType) GetAccountNumber() string {
	if p == nil {
		return ""
	}
	return p.AccountNumber
}

func (p *PadSourceWithAccountType) GetTransitNumber() string {
	if p == nil {
		return ""
	}
	return p.TransitNumber
}

func (p *PadSourceWithAccountType) GetInstitutionNumber() string {
	if p == nil {
		return ""
	}
	return p.InstitutionNumber
}

func (p *PadSourceWithAccountType) GetAccountType() *PadSourceWithAccountTypeAccountType {
	if p == nil {
		return nil
	}
	return p.AccountType
}

func (p *PadSourceWithAccountType) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PadSourceWithAccountType) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSourceWithAccountType) SetNameOnAccount(nameOnAccount string) {
	p.NameOnAccount = nameOnAccount
	p.require(padSourceWithAccountTypeFieldNameOnAccount)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSourceWithAccountType) SetAccountNumber(accountNumber string) {
	p.AccountNumber = accountNumber
	p.require(padSourceWithAccountTypeFieldAccountNumber)
}

// SetTransitNumber sets the TransitNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSourceWithAccountType) SetTransitNumber(transitNumber string) {
	p.TransitNumber = transitNumber
	p.require(padSourceWithAccountTypeFieldTransitNumber)
}

// SetInstitutionNumber sets the InstitutionNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSourceWithAccountType) SetInstitutionNumber(institutionNumber string) {
	p.InstitutionNumber = institutionNumber
	p.require(padSourceWithAccountTypeFieldInstitutionNumber)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PadSourceWithAccountType) SetAccountType(accountType *PadSourceWithAccountTypeAccountType) {
	p.AccountType = accountType
	p.require(padSourceWithAccountTypeFieldAccountType)
}

func (p *PadSourceWithAccountType) UnmarshalJSON(data []byte) error {
	type unmarshaler PadSourceWithAccountType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PadSourceWithAccountType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PadSourceWithAccountType) MarshalJSON() ([]byte, error) {
	type embed PadSourceWithAccountType
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PadSourceWithAccountType) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the customer's account type.
type PadSourceWithAccountTypeAccountType string

const (
	PadSourceWithAccountTypeAccountTypeChecking PadSourceWithAccountTypeAccountType = "checking"
	PadSourceWithAccountTypeAccountTypeSavings  PadSourceWithAccountTypeAccountType = "savings"
)

func NewPadSourceWithAccountTypeAccountTypeFromString(s string) (PadSourceWithAccountTypeAccountType, error) {
	switch s {
	case "checking":
		return PadSourceWithAccountTypeAccountTypeChecking, nil
	case "savings":
		return PadSourceWithAccountTypeAccountTypeSavings, nil
	}
	var t PadSourceWithAccountTypeAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PadSourceWithAccountTypeAccountType) Ptr() *PadSourceWithAccountTypeAccountType {
	return &p
}

var (
	paginatedContactsFieldLimit   = big.NewInt(1 << 0)
	paginatedContactsFieldCount   = big.NewInt(1 << 1)
	paginatedContactsFieldHasMore = big.NewInt(1 << 2)
	paginatedContactsFieldLinks   = big.NewInt(1 << 3)
	paginatedContactsFieldData    = big.NewInt(1 << 4)
)

type PaginatedContacts struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of contact objects.
	Data []*Contact `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedContacts) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedContacts) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedContacts) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedContacts) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedContacts) GetData() []*Contact {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedContacts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedContacts) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedContacts) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedContactsFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedContacts) SetCount(count *int) {
	p.Count = count
	p.require(paginatedContactsFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedContacts) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedContactsFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedContacts) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedContactsFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedContacts) SetData(data []*Contact) {
	p.Data = data
	p.require(paginatedContactsFieldData)
}

func (p *PaginatedContacts) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedContacts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedContacts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedContacts) MarshalJSON() ([]byte, error) {
	type embed PaginatedContacts
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedContacts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paginatedEventSubscriptionsFieldLimit   = big.NewInt(1 << 0)
	paginatedEventSubscriptionsFieldCount   = big.NewInt(1 << 1)
	paginatedEventSubscriptionsFieldHasMore = big.NewInt(1 << 2)
	paginatedEventSubscriptionsFieldLinks   = big.NewInt(1 << 3)
	paginatedEventSubscriptionsFieldData    = big.NewInt(1 << 4)
)

type PaginatedEventSubscriptions struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of eventSubscription objects.
	Data []*EventSubscription `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedEventSubscriptions) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedEventSubscriptions) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedEventSubscriptions) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedEventSubscriptions) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedEventSubscriptions) GetData() []*EventSubscription {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedEventSubscriptions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedEventSubscriptions) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedEventSubscriptions) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedEventSubscriptionsFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedEventSubscriptions) SetCount(count *int) {
	p.Count = count
	p.require(paginatedEventSubscriptionsFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedEventSubscriptions) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedEventSubscriptionsFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedEventSubscriptions) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedEventSubscriptionsFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedEventSubscriptions) SetData(data []*EventSubscription) {
	p.Data = data
	p.require(paginatedEventSubscriptionsFieldData)
}

func (p *PaginatedEventSubscriptions) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedEventSubscriptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedEventSubscriptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedEventSubscriptions) MarshalJSON() ([]byte, error) {
	type embed PaginatedEventSubscriptions
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedEventSubscriptions) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paginatedFundRecipientsFieldLimit   = big.NewInt(1 << 0)
	paginatedFundRecipientsFieldCount   = big.NewInt(1 << 1)
	paginatedFundRecipientsFieldHasMore = big.NewInt(1 << 2)
	paginatedFundRecipientsFieldLinks   = big.NewInt(1 << 3)
	paginatedFundRecipientsFieldData    = big.NewInt(1 << 4)
)

type PaginatedFundRecipients struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// An array of funding recipients
	Data []*FundingRecipient `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedFundRecipients) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedFundRecipients) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedFundRecipients) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedFundRecipients) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedFundRecipients) GetData() []*FundingRecipient {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedFundRecipients) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedFundRecipients) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFundRecipients) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedFundRecipientsFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFundRecipients) SetCount(count *int) {
	p.Count = count
	p.require(paginatedFundRecipientsFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFundRecipients) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedFundRecipientsFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFundRecipients) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedFundRecipientsFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedFundRecipients) SetData(data []*FundingRecipient) {
	p.Data = data
	p.require(paginatedFundRecipientsFieldData)
}

func (p *PaginatedFundRecipients) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedFundRecipients
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedFundRecipients(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedFundRecipients) MarshalJSON() ([]byte, error) {
	type embed PaginatedFundRecipients
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedFundRecipients) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Contains the pagination properties that you use to navigate through a list of results.
var (
	paginatedListFieldLimit   = big.NewInt(1 << 0)
	paginatedListFieldCount   = big.NewInt(1 << 1)
	paginatedListFieldHasMore = big.NewInt(1 << 2)
	paginatedListFieldLinks   = big.NewInt(1 << 3)
)

type PaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedList) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedList) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedList) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedList) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedList) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedList) SetCount(count *int) {
	p.Count = count
	p.require(paginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedList) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedList) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedListFieldLinks)
}

func (p *PaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedList) MarshalJSON() ([]byte, error) {
	type embed PaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paginatedMerchantsFieldLimit   = big.NewInt(1 << 0)
	paginatedMerchantsFieldCount   = big.NewInt(1 << 1)
	paginatedMerchantsFieldHasMore = big.NewInt(1 << 2)
	paginatedMerchantsFieldLinks   = big.NewInt(1 << 3)
	paginatedMerchantsFieldData    = big.NewInt(1 << 4)
)

type PaginatedMerchants struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of merchantPlatform objects.
	Data []*MerchantPlatform `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedMerchants) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedMerchants) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedMerchants) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedMerchants) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedMerchants) GetData() []*MerchantPlatform {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedMerchants) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedMerchants) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedMerchants) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedMerchantsFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedMerchants) SetCount(count *int) {
	p.Count = count
	p.require(paginatedMerchantsFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedMerchants) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedMerchantsFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedMerchants) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedMerchantsFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedMerchants) SetData(data []*MerchantPlatform) {
	p.Data = data
	p.require(paginatedMerchantsFieldData)
}

func (p *PaginatedMerchants) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedMerchants
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedMerchants(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedMerchants) MarshalJSON() ([]byte, error) {
	type embed PaginatedMerchants
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedMerchants) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paginatedOwnersFieldLimit   = big.NewInt(1 << 0)
	paginatedOwnersFieldCount   = big.NewInt(1 << 1)
	paginatedOwnersFieldHasMore = big.NewInt(1 << 2)
	paginatedOwnersFieldLinks   = big.NewInt(1 << 3)
	paginatedOwnersFieldData    = big.NewInt(1 << 4)
)

type PaginatedOwners struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of owner objects.
	Data []*Owner `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedOwners) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedOwners) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedOwners) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedOwners) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedOwners) GetData() []*Owner {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedOwners) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedOwners) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedOwners) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedOwnersFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedOwners) SetCount(count *int) {
	p.Count = count
	p.require(paginatedOwnersFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedOwners) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedOwnersFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedOwners) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedOwnersFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedOwners) SetData(data []*Owner) {
	p.Data = data
	p.require(paginatedOwnersFieldData)
}

func (p *PaginatedOwners) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedOwners
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedOwners(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedOwners) MarshalJSON() ([]byte, error) {
	type embed PaginatedOwners
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedOwners) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about your pricing intents.
var (
	paginatedPricingIntentFieldLimit   = big.NewInt(1 << 0)
	paginatedPricingIntentFieldCount   = big.NewInt(1 << 1)
	paginatedPricingIntentFieldHasMore = big.NewInt(1 << 2)
	paginatedPricingIntentFieldLinks   = big.NewInt(1 << 3)
	paginatedPricingIntentFieldData    = big.NewInt(1 << 4)
)

type PaginatedPricingIntent struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of pricing intent objects.
	Data []PricingIntent `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedPricingIntent) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedPricingIntent) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedPricingIntent) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedPricingIntent) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedPricingIntent) GetData() []PricingIntent {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedPricingIntent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedPricingIntent) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedPricingIntent) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedPricingIntentFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedPricingIntent) SetCount(count *int) {
	p.Count = count
	p.require(paginatedPricingIntentFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedPricingIntent) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedPricingIntentFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedPricingIntent) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedPricingIntentFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedPricingIntent) SetData(data []PricingIntent) {
	p.Data = data
	p.require(paginatedPricingIntentFieldData)
}

func (p *PaginatedPricingIntent) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedPricingIntent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedPricingIntent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedPricingIntent) MarshalJSON() ([]byte, error) {
	type embed PaginatedPricingIntent
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedPricingIntent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paginatedProcessingAccountsFieldLimit   = big.NewInt(1 << 0)
	paginatedProcessingAccountsFieldCount   = big.NewInt(1 << 1)
	paginatedProcessingAccountsFieldHasMore = big.NewInt(1 << 2)
	paginatedProcessingAccountsFieldLinks   = big.NewInt(1 << 3)
	paginatedProcessingAccountsFieldData    = big.NewInt(1 << 4)
)

type PaginatedProcessingAccounts struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of processingAccount objects.
	Data []*ProcessingAccount `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedProcessingAccounts) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedProcessingAccounts) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedProcessingAccounts) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedProcessingAccounts) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedProcessingAccounts) GetData() []*ProcessingAccount {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedProcessingAccounts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedProcessingAccounts) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingAccounts) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedProcessingAccountsFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingAccounts) SetCount(count *int) {
	p.Count = count
	p.require(paginatedProcessingAccountsFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingAccounts) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedProcessingAccountsFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingAccounts) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedProcessingAccountsFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingAccounts) SetData(data []*ProcessingAccount) {
	p.Data = data
	p.require(paginatedProcessingAccountsFieldData)
}

func (p *PaginatedProcessingAccounts) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedProcessingAccounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedProcessingAccounts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedProcessingAccounts) MarshalJSON() ([]byte, error) {
	type embed PaginatedProcessingAccounts
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedProcessingAccounts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paginatedProcessingTerminalsFieldLimit   = big.NewInt(1 << 0)
	paginatedProcessingTerminalsFieldCount   = big.NewInt(1 << 1)
	paginatedProcessingTerminalsFieldHasMore = big.NewInt(1 << 2)
	paginatedProcessingTerminalsFieldLinks   = big.NewInt(1 << 3)
	paginatedProcessingTerminalsFieldData    = big.NewInt(1 << 4)
)

type PaginatedProcessingTerminals struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of processing terminal objects.
	Data []*ProcessingTerminal `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedProcessingTerminals) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaginatedProcessingTerminals) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaginatedProcessingTerminals) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaginatedProcessingTerminals) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaginatedProcessingTerminals) GetData() []*ProcessingTerminal {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedProcessingTerminals) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedProcessingTerminals) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingTerminals) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paginatedProcessingTerminalsFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingTerminals) SetCount(count *int) {
	p.Count = count
	p.require(paginatedProcessingTerminalsFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingTerminals) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paginatedProcessingTerminalsFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingTerminals) SetLinks(links []*Link) {
	p.Links = links
	p.require(paginatedProcessingTerminalsFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedProcessingTerminals) SetData(data []*ProcessingTerminal) {
	p.Data = data
	p.require(paginatedProcessingTerminalsFieldData)
}

func (p *PaginatedProcessingTerminals) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedProcessingTerminals
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedProcessingTerminals(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedProcessingTerminals) MarshalJSON() ([]byte, error) {
	type embed PaginatedProcessingTerminals
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedProcessingTerminals) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the partially-encrypted card data for keyed transactions.
var (
	partiallyEncryptedKeyedDataFormatFieldDevice       = big.NewInt(1 << 0)
	partiallyEncryptedKeyedDataFormatFieldEncryptedPan = big.NewInt(1 << 1)
	partiallyEncryptedKeyedDataFormatFieldMaskedPan    = big.NewInt(1 << 2)
	partiallyEncryptedKeyedDataFormatFieldExpiryDate   = big.NewInt(1 << 3)
	partiallyEncryptedKeyedDataFormatFieldCvv          = big.NewInt(1 << 4)
	partiallyEncryptedKeyedDataFormatFieldCvvEncrypted = big.NewInt(1 << 5)
	partiallyEncryptedKeyedDataFormatFieldIssueNumber  = big.NewInt(1 << 6)
)

type PartiallyEncryptedKeyedDataFormat struct {
	Device *EncryptionCapableDevice `json:"device" url:"device"`
	// Encrypted card number.
	EncryptedPan string `json:"encryptedPan" url:"encryptedPan"`
	// Masked card number.
	// The gateway shows only the first six digits and the last four digits of the account number. For example, `453985******7062`.
	MaskedPan string `json:"maskedPan" url:"maskedPan"`
	// Expiry date of the customer’s card.
	ExpiryDate string `json:"expiryDate" url:"expiryDate"`
	// Security code of the customer’s card.
	Cvv *string `json:"cvv,omitempty" url:"cvv,omitempty"`
	// Encrypted security code data.
	CvvEncrypted *string `json:"cvvEncrypted,omitempty" url:"cvvEncrypted,omitempty"`
	// Issue number of the customer’s card.
	IssueNumber *string `json:"issueNumber,omitempty" url:"issueNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PartiallyEncryptedKeyedDataFormat) GetDevice() *EncryptionCapableDevice {
	if p == nil {
		return nil
	}
	return p.Device
}

func (p *PartiallyEncryptedKeyedDataFormat) GetEncryptedPan() string {
	if p == nil {
		return ""
	}
	return p.EncryptedPan
}

func (p *PartiallyEncryptedKeyedDataFormat) GetMaskedPan() string {
	if p == nil {
		return ""
	}
	return p.MaskedPan
}

func (p *PartiallyEncryptedKeyedDataFormat) GetExpiryDate() string {
	if p == nil {
		return ""
	}
	return p.ExpiryDate
}

func (p *PartiallyEncryptedKeyedDataFormat) GetCvv() *string {
	if p == nil {
		return nil
	}
	return p.Cvv
}

func (p *PartiallyEncryptedKeyedDataFormat) GetCvvEncrypted() *string {
	if p == nil {
		return nil
	}
	return p.CvvEncrypted
}

func (p *PartiallyEncryptedKeyedDataFormat) GetIssueNumber() *string {
	if p == nil {
		return nil
	}
	return p.IssueNumber
}

func (p *PartiallyEncryptedKeyedDataFormat) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PartiallyEncryptedKeyedDataFormat) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyEncryptedKeyedDataFormat) SetDevice(device *EncryptionCapableDevice) {
	p.Device = device
	p.require(partiallyEncryptedKeyedDataFormatFieldDevice)
}

// SetEncryptedPan sets the EncryptedPan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyEncryptedKeyedDataFormat) SetEncryptedPan(encryptedPan string) {
	p.EncryptedPan = encryptedPan
	p.require(partiallyEncryptedKeyedDataFormatFieldEncryptedPan)
}

// SetMaskedPan sets the MaskedPan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyEncryptedKeyedDataFormat) SetMaskedPan(maskedPan string) {
	p.MaskedPan = maskedPan
	p.require(partiallyEncryptedKeyedDataFormatFieldMaskedPan)
}

// SetExpiryDate sets the ExpiryDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyEncryptedKeyedDataFormat) SetExpiryDate(expiryDate string) {
	p.ExpiryDate = expiryDate
	p.require(partiallyEncryptedKeyedDataFormatFieldExpiryDate)
}

// SetCvv sets the Cvv field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyEncryptedKeyedDataFormat) SetCvv(cvv *string) {
	p.Cvv = cvv
	p.require(partiallyEncryptedKeyedDataFormatFieldCvv)
}

// SetCvvEncrypted sets the CvvEncrypted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyEncryptedKeyedDataFormat) SetCvvEncrypted(cvvEncrypted *string) {
	p.CvvEncrypted = cvvEncrypted
	p.require(partiallyEncryptedKeyedDataFormatFieldCvvEncrypted)
}

// SetIssueNumber sets the IssueNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PartiallyEncryptedKeyedDataFormat) SetIssueNumber(issueNumber *string) {
	p.IssueNumber = issueNumber
	p.require(partiallyEncryptedKeyedDataFormatFieldIssueNumber)
}

func (p *PartiallyEncryptedKeyedDataFormat) UnmarshalJSON(data []byte) error {
	type unmarshaler PartiallyEncryptedKeyedDataFormat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PartiallyEncryptedKeyedDataFormat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PartiallyEncryptedKeyedDataFormat) MarshalJSON() ([]byte, error) {
	type embed PartiallyEncryptedKeyedDataFormat
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PartiallyEncryptedKeyedDataFormat) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A Patch Add Operation.
var (
	patchAddFieldPath  = big.NewInt(1 << 0)
	patchAddFieldValue = big.NewInt(1 << 1)
)

type PatchAdd struct {
	// Location where you want to add the value.
	// The format for this value is JSON Pointer.
	Path  string      `json:"path" url:"path"`
	Value interface{} `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchAdd) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

func (p *PatchAdd) GetValue() interface{} {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PatchAdd) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchAdd) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchAdd) SetPath(path string) {
	p.Path = path
	p.require(patchAddFieldPath)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchAdd) SetValue(value interface{}) {
	p.Value = value
	p.require(patchAddFieldValue)
}

func (p *PatchAdd) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchAdd
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchAdd(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchAdd) MarshalJSON() ([]byte, error) {
	type embed PatchAdd
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchAdd) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A Patch Copy Operation.
var (
	patchCopyFieldFrom = big.NewInt(1 << 0)
	patchCopyFieldPath = big.NewInt(1 << 1)
)

type PatchCopy struct {
	// Location of the value that you want to copy.
	// The format for this value is JSON Pointer.
	From string `json:"from" url:"from"`
	// Location where you want to copy the value to.
	// The format for this value is JSON Pointer.
	Path string `json:"path" url:"path"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchCopy) GetFrom() string {
	if p == nil {
		return ""
	}
	return p.From
}

func (p *PatchCopy) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

func (p *PatchCopy) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchCopy) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetFrom sets the From field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchCopy) SetFrom(from string) {
	p.From = from
	p.require(patchCopyFieldFrom)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchCopy) SetPath(path string) {
	p.Path = path
	p.require(patchCopyFieldPath)
}

func (p *PatchCopy) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchCopy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchCopy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchCopy) MarshalJSON() ([]byte, error) {
	type embed PatchCopy
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchCopy) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A JSON Patch operation as defined by RFC 6902.
type PatchDocument struct {
	Op      string
	Add     *PatchAdd
	Remove  *PatchRemove
	Replace *PatchReplace
	Move    *PatchMove
	Copy    *PatchCopy
	Test    *PatchTest
}

func (p *PatchDocument) GetOp() string {
	if p == nil {
		return ""
	}
	return p.Op
}

func (p *PatchDocument) GetAdd() *PatchAdd {
	if p == nil {
		return nil
	}
	return p.Add
}

func (p *PatchDocument) GetRemove() *PatchRemove {
	if p == nil {
		return nil
	}
	return p.Remove
}

func (p *PatchDocument) GetReplace() *PatchReplace {
	if p == nil {
		return nil
	}
	return p.Replace
}

func (p *PatchDocument) GetMove() *PatchMove {
	if p == nil {
		return nil
	}
	return p.Move
}

func (p *PatchDocument) GetCopy() *PatchCopy {
	if p == nil {
		return nil
	}
	return p.Copy
}

func (p *PatchDocument) GetTest() *PatchTest {
	if p == nil {
		return nil
	}
	return p.Test
}

func (p *PatchDocument) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Op string `json:"op"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Op = unmarshaler.Op
	if unmarshaler.Op == "" {
		return fmt.Errorf("%T did not include discriminant op", p)
	}
	switch unmarshaler.Op {
	case "add":
		value := new(PatchAdd)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Add = value
	case "remove":
		value := new(PatchRemove)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Remove = value
	case "replace":
		value := new(PatchReplace)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Replace = value
	case "move":
		value := new(PatchMove)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Move = value
	case "copy":
		value := new(PatchCopy)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Copy = value
	case "test":
		value := new(PatchTest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Test = value
	}
	return nil
}

func (p PatchDocument) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Add != nil {
		return internal.MarshalJSONWithExtraProperty(p.Add, "op", "add")
	}
	if p.Remove != nil {
		return internal.MarshalJSONWithExtraProperty(p.Remove, "op", "remove")
	}
	if p.Replace != nil {
		return internal.MarshalJSONWithExtraProperty(p.Replace, "op", "replace")
	}
	if p.Move != nil {
		return internal.MarshalJSONWithExtraProperty(p.Move, "op", "move")
	}
	if p.Copy != nil {
		return internal.MarshalJSONWithExtraProperty(p.Copy, "op", "copy")
	}
	if p.Test != nil {
		return internal.MarshalJSONWithExtraProperty(p.Test, "op", "test")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PatchDocumentVisitor interface {
	VisitAdd(*PatchAdd) error
	VisitRemove(*PatchRemove) error
	VisitReplace(*PatchReplace) error
	VisitMove(*PatchMove) error
	VisitCopy(*PatchCopy) error
	VisitTest(*PatchTest) error
}

func (p *PatchDocument) Accept(visitor PatchDocumentVisitor) error {
	if p.Add != nil {
		return visitor.VisitAdd(p.Add)
	}
	if p.Remove != nil {
		return visitor.VisitRemove(p.Remove)
	}
	if p.Replace != nil {
		return visitor.VisitReplace(p.Replace)
	}
	if p.Move != nil {
		return visitor.VisitMove(p.Move)
	}
	if p.Copy != nil {
		return visitor.VisitCopy(p.Copy)
	}
	if p.Test != nil {
		return visitor.VisitTest(p.Test)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PatchDocument) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Add != nil {
		fields = append(fields, "add")
	}
	if p.Remove != nil {
		fields = append(fields, "remove")
	}
	if p.Replace != nil {
		fields = append(fields, "replace")
	}
	if p.Move != nil {
		fields = append(fields, "move")
	}
	if p.Copy != nil {
		fields = append(fields, "copy")
	}
	if p.Test != nil {
		fields = append(fields, "test")
	}
	if len(fields) == 0 {
		if p.Op != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Op)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Op != "" {
		field := fields[0]
		if p.Op != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Op,
				p,
			)
		}
	}
	return nil
}

// A Patch Move Operation.
var (
	patchMoveFieldFrom = big.NewInt(1 << 0)
	patchMoveFieldPath = big.NewInt(1 << 1)
)

type PatchMove struct {
	// Location of the value that you want to move.
	// The format for this value is JSON Pointer.
	From string `json:"from" url:"from"`
	// Location where you want to move the value to.
	// The format for this value is JSON Pointer.
	Path string `json:"path" url:"path"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchMove) GetFrom() string {
	if p == nil {
		return ""
	}
	return p.From
}

func (p *PatchMove) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

func (p *PatchMove) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchMove) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetFrom sets the From field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchMove) SetFrom(from string) {
	p.From = from
	p.require(patchMoveFieldFrom)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchMove) SetPath(path string) {
	p.Path = path
	p.require(patchMoveFieldPath)
}

func (p *PatchMove) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchMove
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchMove(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchMove) MarshalJSON() ([]byte, error) {
	type embed PatchMove
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchMove) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A Patch Remove Operation.
var (
	patchRemoveFieldPath = big.NewInt(1 << 0)
)

type PatchRemove struct {
	// Location of the value that you want to remove.
	// The format for this value is JSON Pointer.
	Path string `json:"path" url:"path"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchRemove) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

func (p *PatchRemove) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchRemove) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchRemove) SetPath(path string) {
	p.Path = path
	p.require(patchRemoveFieldPath)
}

func (p *PatchRemove) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchRemove
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchRemove(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchRemove) MarshalJSON() ([]byte, error) {
	type embed PatchRemove
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchRemove) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A Patch Replace Operation.
var (
	patchReplaceFieldPath  = big.NewInt(1 << 0)
	patchReplaceFieldValue = big.NewInt(1 << 1)
)

type PatchReplace struct {
	// Location of the value that you want to replace.
	// The format for this value is JSON Pointer.
	Path  string      `json:"path" url:"path"`
	Value interface{} `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchReplace) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

func (p *PatchReplace) GetValue() interface{} {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PatchReplace) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchReplace) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchReplace) SetPath(path string) {
	p.Path = path
	p.require(patchReplaceFieldPath)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchReplace) SetValue(value interface{}) {
	p.Value = value
	p.require(patchReplaceFieldValue)
}

func (p *PatchReplace) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchReplace
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchReplace(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchReplace) MarshalJSON() ([]byte, error) {
	type embed PatchReplace
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchReplace) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A JSON Patch document as defined by RFC 6902.
type PatchRequest = []*PatchDocument

// A Patch Test Operation.
var (
	patchTestFieldPath  = big.NewInt(1 << 0)
	patchTestFieldValue = big.NewInt(1 << 1)
)

type PatchTest struct {
	// Location of the value that you want to test.
	// The format for this value is JSON Pointer.
	Path  string      `json:"path" url:"path"`
	Value interface{} `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PatchTest) GetPath() string {
	if p == nil {
		return ""
	}
	return p.Path
}

func (p *PatchTest) GetValue() interface{} {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PatchTest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PatchTest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPath sets the Path field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchTest) SetPath(path string) {
	p.Path = path
	p.require(patchTestFieldPath)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PatchTest) SetValue(value interface{}) {
	p.Value = value
	p.require(patchTestFieldValue)
}

func (p *PatchTest) UnmarshalJSON(data []byte) error {
	type unmarshaler PatchTest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PatchTest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PatchTest) MarshalJSON() ([]byte, error) {
	type embed PatchTest
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PatchTest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentFieldPaymentId            = big.NewInt(1 << 0)
	paymentFieldProcessingTerminalId = big.NewInt(1 << 1)
	paymentFieldOperator             = big.NewInt(1 << 2)
	paymentFieldOrder                = big.NewInt(1 << 3)
	paymentFieldCustomer             = big.NewInt(1 << 4)
	paymentFieldCard                 = big.NewInt(1 << 5)
	paymentFieldRefunds              = big.NewInt(1 << 6)
	paymentFieldSupportedOperations  = big.NewInt(1 << 7)
	paymentFieldTransactionResult    = big.NewInt(1 << 8)
	paymentFieldCustomFields         = big.NewInt(1 << 9)
)

type Payment struct {
	// Unique identifier that our gateway assigned to the transaction.
	PaymentId string `json:"paymentId" url:"paymentId"`
	// Unique identifier of the terminal that initiated the transaction.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Operator who initiated the request.
	Operator *string            `json:"operator,omitempty" url:"operator,omitempty"`
	Order    *PaymentOrder      `json:"order" url:"order"`
	Customer *RetrievedCustomer `json:"customer,omitempty" url:"customer,omitempty"`
	Card     *Card              `json:"card" url:"card"`
	// Array of refundSummary objects.
	// Each object contains information about refunds linked to the transaction.
	Refunds             []*RefundSummary     `json:"refunds,omitempty" url:"refunds,omitempty"`
	SupportedOperations *SupportedOperations `json:"supportedOperations,omitempty" url:"supportedOperations,omitempty"`
	TransactionResult   *TransactionResult   `json:"transactionResult" url:"transactionResult"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Payment) GetPaymentId() string {
	if p == nil {
		return ""
	}
	return p.PaymentId
}

func (p *Payment) GetProcessingTerminalId() string {
	if p == nil {
		return ""
	}
	return p.ProcessingTerminalId
}

func (p *Payment) GetOperator() *string {
	if p == nil {
		return nil
	}
	return p.Operator
}

func (p *Payment) GetOrder() *PaymentOrder {
	if p == nil {
		return nil
	}
	return p.Order
}

func (p *Payment) GetCustomer() *RetrievedCustomer {
	if p == nil {
		return nil
	}
	return p.Customer
}

func (p *Payment) GetCard() *Card {
	if p == nil {
		return nil
	}
	return p.Card
}

func (p *Payment) GetRefunds() []*RefundSummary {
	if p == nil {
		return nil
	}
	return p.Refunds
}

func (p *Payment) GetSupportedOperations() *SupportedOperations {
	if p == nil {
		return nil
	}
	return p.SupportedOperations
}

func (p *Payment) GetTransactionResult() *TransactionResult {
	if p == nil {
		return nil
	}
	return p.TransactionResult
}

func (p *Payment) GetCustomFields() []*CustomField {
	if p == nil {
		return nil
	}
	return p.CustomFields
}

func (p *Payment) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payment) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetPaymentId(paymentId string) {
	p.PaymentId = paymentId
	p.require(paymentFieldPaymentId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetProcessingTerminalId(processingTerminalId string) {
	p.ProcessingTerminalId = processingTerminalId
	p.require(paymentFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetOperator(operator *string) {
	p.Operator = operator
	p.require(paymentFieldOperator)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetOrder(order *PaymentOrder) {
	p.Order = order
	p.require(paymentFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetCustomer(customer *RetrievedCustomer) {
	p.Customer = customer
	p.require(paymentFieldCustomer)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetCard(card *Card) {
	p.Card = card
	p.require(paymentFieldCard)
}

// SetRefunds sets the Refunds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetRefunds(refunds []*RefundSummary) {
	p.Refunds = refunds
	p.require(paymentFieldRefunds)
}

// SetSupportedOperations sets the SupportedOperations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetSupportedOperations(supportedOperations *SupportedOperations) {
	p.SupportedOperations = supportedOperations
	p.require(paymentFieldSupportedOperations)
}

// SetTransactionResult sets the TransactionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetTransactionResult(transactionResult *TransactionResult) {
	p.TransactionResult = transactionResult
	p.require(paymentFieldTransactionResult)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Payment) SetCustomFields(customFields []*CustomField) {
	p.CustomFields = customFields
	p.require(paymentFieldCustomFields)
}

func (p *Payment) UnmarshalJSON(data []byte) error {
	type unmarshaler Payment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payment) MarshalJSON() ([]byte, error) {
	type embed Payment
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Payment) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentInstructionFieldStatus               = big.NewInt(1 << 0)
	paymentInstructionFieldErrorMessage         = big.NewInt(1 << 1)
	paymentInstructionFieldLink                 = big.NewInt(1 << 2)
	paymentInstructionFieldPaymentInstructionId = big.NewInt(1 << 3)
)

type PaymentInstruction struct {
	// Indicates the current status of the instruction.
	// - `canceled` – The instruction was canceled before it was completed.
	// - `completed` – The instruction has completed. Use the link object to check the resource.
	// - `failure` – The instruction failed. Check the errorMessage field for more information.
	// - `inProgress` – The instruction is currently in progress.
	Status *DeviceInstructionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Description of the error that caused the instruction to fail.
	//
	// **Note:** We return this field only if the status is `failure`.
	ErrorMessage *string `json:"errorMessage,omitempty" url:"errorMessage,omitempty"`
	Link         *Link   `json:"link,omitempty" url:"link,omitempty"`
	// Unique identifier that we assigned to the payment instruction.
	PaymentInstructionId *string `json:"paymentInstructionId,omitempty" url:"paymentInstructionId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentInstruction) GetStatus() *DeviceInstructionStatus {
	if p == nil {
		return nil
	}
	return p.Status
}

func (p *PaymentInstruction) GetErrorMessage() *string {
	if p == nil {
		return nil
	}
	return p.ErrorMessage
}

func (p *PaymentInstruction) GetLink() *Link {
	if p == nil {
		return nil
	}
	return p.Link
}

func (p *PaymentInstruction) GetPaymentInstructionId() *string {
	if p == nil {
		return nil
	}
	return p.PaymentInstructionId
}

func (p *PaymentInstruction) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentInstruction) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstruction) SetStatus(status *DeviceInstructionStatus) {
	p.Status = status
	p.require(paymentInstructionFieldStatus)
}

// SetErrorMessage sets the ErrorMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstruction) SetErrorMessage(errorMessage *string) {
	p.ErrorMessage = errorMessage
	p.require(paymentInstructionFieldErrorMessage)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstruction) SetLink(link *Link) {
	p.Link = link
	p.require(paymentInstructionFieldLink)
}

// SetPaymentInstructionId sets the PaymentInstructionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstruction) SetPaymentInstructionId(paymentInstructionId *string) {
	p.PaymentInstructionId = paymentInstructionId
	p.require(paymentInstructionFieldPaymentInstructionId)
}

func (p *PaymentInstruction) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentInstruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentInstruction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentInstruction) MarshalJSON() ([]byte, error) {
	type embed PaymentInstruction
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentInstruction) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the payment.
var (
	paymentInstructionOrderFieldOrderId     = big.NewInt(1 << 0)
	paymentInstructionOrderFieldDateTime    = big.NewInt(1 << 1)
	paymentInstructionOrderFieldDescription = big.NewInt(1 << 2)
	paymentInstructionOrderFieldAmount      = big.NewInt(1 << 3)
	paymentInstructionOrderFieldCurrency    = big.NewInt(1 << 4)
	paymentInstructionOrderFieldBreakdown   = big.NewInt(1 << 5)
)

type PaymentInstructionOrder struct {
	// Unique identifier that the merchant assigns to the transaction.
	OrderId string `json:"orderId" url:"orderId"`
	// Date and time that the processor processed the transaction. Our gateway returns this value in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total amount of the transaction. The value is in the currency’s lowest denomination, for example, cents.
	Amount    int64                            `json:"amount" url:"amount"`
	Currency  Currency                         `json:"currency" url:"currency"`
	Breakdown *BreakdownForPaymentInstructions `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentInstructionOrder) GetOrderId() string {
	if p == nil {
		return ""
	}
	return p.OrderId
}

func (p *PaymentInstructionOrder) GetDateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.DateTime
}

func (p *PaymentInstructionOrder) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentInstructionOrder) GetAmount() int64 {
	if p == nil {
		return 0
	}
	return p.Amount
}

func (p *PaymentInstructionOrder) GetCurrency() Currency {
	if p == nil {
		return ""
	}
	return p.Currency
}

func (p *PaymentInstructionOrder) GetBreakdown() *BreakdownForPaymentInstructions {
	if p == nil {
		return nil
	}
	return p.Breakdown
}

func (p *PaymentInstructionOrder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentInstructionOrder) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstructionOrder) SetOrderId(orderId string) {
	p.OrderId = orderId
	p.require(paymentInstructionOrderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstructionOrder) SetDateTime(dateTime *time.Time) {
	p.DateTime = dateTime
	p.require(paymentInstructionOrderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstructionOrder) SetDescription(description *string) {
	p.Description = description
	p.require(paymentInstructionOrderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstructionOrder) SetAmount(amount int64) {
	p.Amount = amount
	p.require(paymentInstructionOrderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstructionOrder) SetCurrency(currency Currency) {
	p.Currency = currency
	p.require(paymentInstructionOrderFieldCurrency)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentInstructionOrder) SetBreakdown(breakdown *BreakdownForPaymentInstructions) {
	p.Breakdown = breakdown
	p.require(paymentInstructionOrderFieldBreakdown)
}

func (p *PaymentInstructionOrder) UnmarshalJSON(data []byte) error {
	type embed PaymentInstructionOrder
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentInstructionOrder(unmarshaler.embed)
	p.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentInstructionOrder) MarshalJSON() ([]byte, error) {
	type embed PaymentInstructionOrder
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*p),
		DateTime: internal.NewOptionalDateTime(p.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentInstructionOrder) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains the contact details of the recipient.
var (
	paymentLinkEmailRecipientFieldName  = big.NewInt(1 << 0)
	paymentLinkEmailRecipientFieldEmail = big.NewInt(1 << 1)
)

type PaymentLinkEmailRecipient struct {
	// Recipient's name.
	Name string `json:"name" url:"name"`
	// Recipient's email address.
	Email string `json:"email" url:"email"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLinkEmailRecipient) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PaymentLinkEmailRecipient) GetEmail() string {
	if p == nil {
		return ""
	}
	return p.Email
}

func (p *PaymentLinkEmailRecipient) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLinkEmailRecipient) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailRecipient) SetName(name string) {
	p.Name = name
	p.require(paymentLinkEmailRecipientFieldName)
}

// SetEmail sets the Email field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailRecipient) SetEmail(email string) {
	p.Email = email
	p.require(paymentLinkEmailRecipientFieldEmail)
}

func (p *PaymentLinkEmailRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLinkEmailRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLinkEmailRecipient(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLinkEmailRecipient) MarshalJSON() ([]byte, error) {
	type embed PaymentLinkEmailRecipient
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentLinkEmailRecipient) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains the information about a sharing event that the merchant sent by email.
var (
	paymentLinkEmailShareEventFieldSharingMethod  = big.NewInt(1 << 0)
	paymentLinkEmailShareEventFieldSharingEventId = big.NewInt(1 << 1)
	paymentLinkEmailShareEventFieldDateTime       = big.NewInt(1 << 2)
	paymentLinkEmailShareEventFieldMerchantCopy   = big.NewInt(1 << 3)
	paymentLinkEmailShareEventFieldMessage        = big.NewInt(1 << 4)
	paymentLinkEmailShareEventFieldRecipients     = big.NewInt(1 << 5)
)

type PaymentLinkEmailShareEvent struct {
	// Method that the merchant uses to share the payment link.
	SharingMethod PaymentLinkEmailShareEventSharingMethod `json:"sharingMethod" url:"sharingMethod"`
	// Unique identifier that we assigned to the sharing event.
	SharingEventId *string `json:"sharingEventId,omitempty" url:"sharingEventId,omitempty"`
	// Date and time that the merchant shared the link. Our gateway returns this value in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Indicates if we send a copy of the email to the merchant. By default, we don't send a copy to the merchant.
	MerchantCopy *bool `json:"merchantCopy,omitempty" url:"merchantCopy,omitempty"`
	// Message that the merchant sends with the payment link.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Array that contains the recipients of the payment link.
	Recipients []*PaymentLinkEmailRecipient `json:"recipients" url:"recipients"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLinkEmailShareEvent) GetSharingMethod() PaymentLinkEmailShareEventSharingMethod {
	if p == nil {
		return ""
	}
	return p.SharingMethod
}

func (p *PaymentLinkEmailShareEvent) GetSharingEventId() *string {
	if p == nil {
		return nil
	}
	return p.SharingEventId
}

func (p *PaymentLinkEmailShareEvent) GetDateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.DateTime
}

func (p *PaymentLinkEmailShareEvent) GetMerchantCopy() *bool {
	if p == nil {
		return nil
	}
	return p.MerchantCopy
}

func (p *PaymentLinkEmailShareEvent) GetMessage() *string {
	if p == nil {
		return nil
	}
	return p.Message
}

func (p *PaymentLinkEmailShareEvent) GetRecipients() []*PaymentLinkEmailRecipient {
	if p == nil {
		return nil
	}
	return p.Recipients
}

func (p *PaymentLinkEmailShareEvent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLinkEmailShareEvent) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetSharingMethod sets the SharingMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailShareEvent) SetSharingMethod(sharingMethod PaymentLinkEmailShareEventSharingMethod) {
	p.SharingMethod = sharingMethod
	p.require(paymentLinkEmailShareEventFieldSharingMethod)
}

// SetSharingEventId sets the SharingEventId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailShareEvent) SetSharingEventId(sharingEventId *string) {
	p.SharingEventId = sharingEventId
	p.require(paymentLinkEmailShareEventFieldSharingEventId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailShareEvent) SetDateTime(dateTime *time.Time) {
	p.DateTime = dateTime
	p.require(paymentLinkEmailShareEventFieldDateTime)
}

// SetMerchantCopy sets the MerchantCopy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailShareEvent) SetMerchantCopy(merchantCopy *bool) {
	p.MerchantCopy = merchantCopy
	p.require(paymentLinkEmailShareEventFieldMerchantCopy)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailShareEvent) SetMessage(message *string) {
	p.Message = message
	p.require(paymentLinkEmailShareEventFieldMessage)
}

// SetRecipients sets the Recipients field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentLinkEmailShareEvent) SetRecipients(recipients []*PaymentLinkEmailRecipient) {
	p.Recipients = recipients
	p.require(paymentLinkEmailShareEventFieldRecipients)
}

func (p *PaymentLinkEmailShareEvent) UnmarshalJSON(data []byte) error {
	type embed PaymentLinkEmailShareEvent
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentLinkEmailShareEvent(unmarshaler.embed)
	p.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLinkEmailShareEvent) MarshalJSON() ([]byte, error) {
	type embed PaymentLinkEmailShareEvent
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*p),
		DateTime: internal.NewOptionalDateTime(p.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentLinkEmailShareEvent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Method that the merchant uses to share the payment link.
type PaymentLinkEmailShareEventSharingMethod string

const (
	PaymentLinkEmailShareEventSharingMethodEmail PaymentLinkEmailShareEventSharingMethod = "email"
)

func NewPaymentLinkEmailShareEventSharingMethodFromString(s string) (PaymentLinkEmailShareEventSharingMethod, error) {
	switch s {
	case "email":
		return PaymentLinkEmailShareEventSharingMethodEmail, nil
	}
	var t PaymentLinkEmailShareEventSharingMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentLinkEmailShareEventSharingMethod) Ptr() *PaymentLinkEmailShareEventSharingMethod {
	return &p
}

var (
	paymentMethodAchFieldValue = big.NewInt(1 << 0)
)

type PaymentMethodAch struct {
	// Object that contains information about the funding account.
	Value *PaymentMethodAchValue `json:"value,omitempty" url:"value,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodAch) GetValue() *PaymentMethodAchValue {
	if p == nil {
		return nil
	}
	return p.Value
}

func (p *PaymentMethodAch) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodAch) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentMethodAch) SetValue(value *PaymentMethodAchValue) {
	p.Value = value
	p.require(paymentMethodAchFieldValue)
}

func (p *PaymentMethodAch) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodAch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodAch(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodAch) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodAch
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentMethodAch) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the funding account.
var (
	paymentMethodAchValueFieldRoutingNumber = big.NewInt(1 << 0)
	paymentMethodAchValueFieldAccountNumber = big.NewInt(1 << 1)
)

type PaymentMethodAchValue struct {
	// Routing number of the funding account.
	RoutingNumber string `json:"routingNumber" url:"routingNumber"`
	// Account number of the funding account.
	AccountNumber string `json:"accountNumber" url:"accountNumber"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentMethodAchValue) GetRoutingNumber() string {
	if p == nil {
		return ""
	}
	return p.RoutingNumber
}

func (p *PaymentMethodAchValue) GetAccountNumber() string {
	if p == nil {
		return ""
	}
	return p.AccountNumber
}

func (p *PaymentMethodAchValue) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentMethodAchValue) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetRoutingNumber sets the RoutingNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentMethodAchValue) SetRoutingNumber(routingNumber string) {
	p.RoutingNumber = routingNumber
	p.require(paymentMethodAchValueFieldRoutingNumber)
}

// SetAccountNumber sets the AccountNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentMethodAchValue) SetAccountNumber(accountNumber string) {
	p.AccountNumber = accountNumber
	p.require(paymentMethodAchValueFieldAccountNumber)
}

func (p *PaymentMethodAchValue) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentMethodAchValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentMethodAchValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentMethodAchValue) MarshalJSON() ([]byte, error) {
	type embed PaymentMethodAchValue
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentMethodAchValue) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Array of PaymentMethodAch objects.
type PaymentMethods = []*PaymentMethodsItem

type PaymentMethodsItem struct {
	Type string
	Ach  *PaymentMethodAch
}

func (p *PaymentMethodsItem) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentMethodsItem) GetAch() *PaymentMethodAch {
	if p == nil {
		return nil
	}
	return p.Ach
}

func (p *PaymentMethodsItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(PaymentMethodAch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Ach = value
	}
	return nil
}

func (p PaymentMethodsItem) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(p.Ach, "type", "ach")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PaymentMethodsItemVisitor interface {
	VisitAch(*PaymentMethodAch) error
}

func (p *PaymentMethodsItem) Accept(visitor PaymentMethodsItemVisitor) error {
	if p.Ach != nil {
		return visitor.VisitAch(p.Ach)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PaymentMethodsItem) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Ach != nil {
		fields = append(fields, "ach")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

// Object that contains information about the payment.
var (
	paymentOrderFieldOrderId              = big.NewInt(1 << 0)
	paymentOrderFieldDateTime             = big.NewInt(1 << 1)
	paymentOrderFieldDescription          = big.NewInt(1 << 2)
	paymentOrderFieldAmount               = big.NewInt(1 << 3)
	paymentOrderFieldCurrency             = big.NewInt(1 << 4)
	paymentOrderFieldDccOffer             = big.NewInt(1 << 5)
	paymentOrderFieldStandingInstructions = big.NewInt(1 << 6)
	paymentOrderFieldBreakdown            = big.NewInt(1 << 7)
)

type PaymentOrder struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Date and time that the processor processed the transaction. Our gateway returns this value in the ISO 8601 format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total amount of the transaction. The value is in the currency’s lowest denomination, for example, cents.
	Amount               *int64                `json:"amount,omitempty" url:"amount,omitempty"`
	Currency             *Currency             `json:"currency,omitempty" url:"currency,omitempty"`
	DccOffer             *DccOffer             `json:"dccOffer,omitempty" url:"dccOffer,omitempty"`
	StandingInstructions *StandingInstructions `json:"standingInstructions,omitempty" url:"standingInstructions,omitempty"`
	Breakdown            *ItemizedBreakdown    `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentOrder) GetOrderId() *string {
	if p == nil {
		return nil
	}
	return p.OrderId
}

func (p *PaymentOrder) GetDateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.DateTime
}

func (p *PaymentOrder) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentOrder) GetAmount() *int64 {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PaymentOrder) GetCurrency() *Currency {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PaymentOrder) GetDccOffer() *DccOffer {
	if p == nil {
		return nil
	}
	return p.DccOffer
}

func (p *PaymentOrder) GetStandingInstructions() *StandingInstructions {
	if p == nil {
		return nil
	}
	return p.StandingInstructions
}

func (p *PaymentOrder) GetBreakdown() *ItemizedBreakdown {
	if p == nil {
		return nil
	}
	return p.Breakdown
}

func (p *PaymentOrder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentOrder) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetOrderId(orderId *string) {
	p.OrderId = orderId
	p.require(paymentOrderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetDateTime(dateTime *time.Time) {
	p.DateTime = dateTime
	p.require(paymentOrderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetDescription(description *string) {
	p.Description = description
	p.require(paymentOrderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentOrderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetCurrency(currency *Currency) {
	p.Currency = currency
	p.require(paymentOrderFieldCurrency)
}

// SetDccOffer sets the DccOffer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetDccOffer(dccOffer *DccOffer) {
	p.DccOffer = dccOffer
	p.require(paymentOrderFieldDccOffer)
}

// SetStandingInstructions sets the StandingInstructions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetStandingInstructions(standingInstructions *StandingInstructions) {
	p.StandingInstructions = standingInstructions
	p.require(paymentOrderFieldStandingInstructions)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrder) SetBreakdown(breakdown *ItemizedBreakdown) {
	p.Breakdown = breakdown
	p.require(paymentOrderFieldBreakdown)
}

func (p *PaymentOrder) UnmarshalJSON(data []byte) error {
	type embed PaymentOrder
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentOrder(unmarshaler.embed)
	p.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentOrder) MarshalJSON() ([]byte, error) {
	type embed PaymentOrder
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*p),
		DateTime: internal.NewOptionalDateTime(p.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentOrder) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the payment.
var (
	paymentOrderBaseFieldOrderId              = big.NewInt(1 << 0)
	paymentOrderBaseFieldDateTime             = big.NewInt(1 << 1)
	paymentOrderBaseFieldDescription          = big.NewInt(1 << 2)
	paymentOrderBaseFieldAmount               = big.NewInt(1 << 3)
	paymentOrderBaseFieldCurrency             = big.NewInt(1 << 4)
	paymentOrderBaseFieldDccOffer             = big.NewInt(1 << 5)
	paymentOrderBaseFieldStandingInstructions = big.NewInt(1 << 6)
)

type PaymentOrderBase struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Date and time that the processor processed the transaction. Our gateway returns this value in the ISO 8601 format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total amount of the transaction. The value is in the currency’s lowest denomination, for example, cents.
	Amount               *int64                `json:"amount,omitempty" url:"amount,omitempty"`
	Currency             *Currency             `json:"currency,omitempty" url:"currency,omitempty"`
	DccOffer             *DccOffer             `json:"dccOffer,omitempty" url:"dccOffer,omitempty"`
	StandingInstructions *StandingInstructions `json:"standingInstructions,omitempty" url:"standingInstructions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentOrderBase) GetOrderId() *string {
	if p == nil {
		return nil
	}
	return p.OrderId
}

func (p *PaymentOrderBase) GetDateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.DateTime
}

func (p *PaymentOrderBase) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentOrderBase) GetAmount() *int64 {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PaymentOrderBase) GetCurrency() *Currency {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PaymentOrderBase) GetDccOffer() *DccOffer {
	if p == nil {
		return nil
	}
	return p.DccOffer
}

func (p *PaymentOrderBase) GetStandingInstructions() *StandingInstructions {
	if p == nil {
		return nil
	}
	return p.StandingInstructions
}

func (p *PaymentOrderBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentOrderBase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderBase) SetOrderId(orderId *string) {
	p.OrderId = orderId
	p.require(paymentOrderBaseFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderBase) SetDateTime(dateTime *time.Time) {
	p.DateTime = dateTime
	p.require(paymentOrderBaseFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderBase) SetDescription(description *string) {
	p.Description = description
	p.require(paymentOrderBaseFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderBase) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentOrderBaseFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderBase) SetCurrency(currency *Currency) {
	p.Currency = currency
	p.require(paymentOrderBaseFieldCurrency)
}

// SetDccOffer sets the DccOffer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderBase) SetDccOffer(dccOffer *DccOffer) {
	p.DccOffer = dccOffer
	p.require(paymentOrderBaseFieldDccOffer)
}

// SetStandingInstructions sets the StandingInstructions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderBase) SetStandingInstructions(standingInstructions *StandingInstructions) {
	p.StandingInstructions = standingInstructions
	p.require(paymentOrderBaseFieldStandingInstructions)
}

func (p *PaymentOrderBase) UnmarshalJSON(data []byte) error {
	type embed PaymentOrderBase
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentOrderBase(unmarshaler.embed)
	p.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentOrderBase) MarshalJSON() ([]byte, error) {
	type embed PaymentOrderBase
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*p),
		DateTime: internal.NewOptionalDateTime(p.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentOrderBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the payment.
var (
	paymentOrderRequestFieldOrderId              = big.NewInt(1 << 0)
	paymentOrderRequestFieldDateTime             = big.NewInt(1 << 1)
	paymentOrderRequestFieldDescription          = big.NewInt(1 << 2)
	paymentOrderRequestFieldAmount               = big.NewInt(1 << 3)
	paymentOrderRequestFieldCurrency             = big.NewInt(1 << 4)
	paymentOrderRequestFieldDccOffer             = big.NewInt(1 << 5)
	paymentOrderRequestFieldStandingInstructions = big.NewInt(1 << 6)
	paymentOrderRequestFieldBreakdown            = big.NewInt(1 << 7)
)

type PaymentOrderRequest struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Date and time that the processor processed the transaction. Our gateway returns this value in the ISO 8601 format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total amount of the transaction. The value is in the currency’s lowest denomination, for example, cents.
	Amount               *int64                    `json:"amount,omitempty" url:"amount,omitempty"`
	Currency             *Currency                 `json:"currency,omitempty" url:"currency,omitempty"`
	DccOffer             *DccOffer                 `json:"dccOffer,omitempty" url:"dccOffer,omitempty"`
	StandingInstructions *StandingInstructions     `json:"standingInstructions,omitempty" url:"standingInstructions,omitempty"`
	Breakdown            *ItemizedBreakdownRequest `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentOrderRequest) GetOrderId() *string {
	if p == nil {
		return nil
	}
	return p.OrderId
}

func (p *PaymentOrderRequest) GetDateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.DateTime
}

func (p *PaymentOrderRequest) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentOrderRequest) GetAmount() *int64 {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PaymentOrderRequest) GetCurrency() *Currency {
	if p == nil {
		return nil
	}
	return p.Currency
}

func (p *PaymentOrderRequest) GetDccOffer() *DccOffer {
	if p == nil {
		return nil
	}
	return p.DccOffer
}

func (p *PaymentOrderRequest) GetStandingInstructions() *StandingInstructions {
	if p == nil {
		return nil
	}
	return p.StandingInstructions
}

func (p *PaymentOrderRequest) GetBreakdown() *ItemizedBreakdownRequest {
	if p == nil {
		return nil
	}
	return p.Breakdown
}

func (p *PaymentOrderRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentOrderRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetOrderId(orderId *string) {
	p.OrderId = orderId
	p.require(paymentOrderRequestFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetDateTime(dateTime *time.Time) {
	p.DateTime = dateTime
	p.require(paymentOrderRequestFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetDescription(description *string) {
	p.Description = description
	p.require(paymentOrderRequestFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentOrderRequestFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetCurrency(currency *Currency) {
	p.Currency = currency
	p.require(paymentOrderRequestFieldCurrency)
}

// SetDccOffer sets the DccOffer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetDccOffer(dccOffer *DccOffer) {
	p.DccOffer = dccOffer
	p.require(paymentOrderRequestFieldDccOffer)
}

// SetStandingInstructions sets the StandingInstructions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetStandingInstructions(standingInstructions *StandingInstructions) {
	p.StandingInstructions = standingInstructions
	p.require(paymentOrderRequestFieldStandingInstructions)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentOrderRequest) SetBreakdown(breakdown *ItemizedBreakdownRequest) {
	p.Breakdown = breakdown
	p.require(paymentOrderRequestFieldBreakdown)
}

func (p *PaymentOrderRequest) UnmarshalJSON(data []byte) error {
	type embed PaymentOrderRequest
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentOrderRequest(unmarshaler.embed)
	p.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentOrderRequest) MarshalJSON() ([]byte, error) {
	type embed PaymentOrderRequest
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*p),
		DateTime: internal.NewOptionalDateTime(p.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentOrderRequest) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentPaginatedListForReadFieldLimit   = big.NewInt(1 << 0)
	paymentPaginatedListForReadFieldCount   = big.NewInt(1 << 1)
	paymentPaginatedListForReadFieldHasMore = big.NewInt(1 << 2)
	paymentPaginatedListForReadFieldLinks   = big.NewInt(1 << 3)
	paymentPaginatedListForReadFieldData    = big.NewInt(1 << 4)
)

type PaymentPaginatedListForRead struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of transactions.
	Data []*RetrievedPayment `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPaginatedListForRead) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaymentPaginatedListForRead) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaymentPaginatedListForRead) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaymentPaginatedListForRead) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaymentPaginatedListForRead) GetData() []*RetrievedPayment {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentPaginatedListForRead) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPaginatedListForRead) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPaginatedListForRead) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paymentPaginatedListForReadFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPaginatedListForRead) SetCount(count *int) {
	p.Count = count
	p.require(paymentPaginatedListForReadFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPaginatedListForRead) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paymentPaginatedListForReadFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPaginatedListForRead) SetLinks(links []*Link) {
	p.Links = links
	p.require(paymentPaginatedListForReadFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPaginatedListForRead) SetData(data []*RetrievedPayment) {
	p.Data = data
	p.require(paymentPaginatedListForReadFieldData)
}

func (p *PaymentPaginatedListForRead) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPaginatedListForRead
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPaginatedListForRead(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPaginatedListForRead) MarshalJSON() ([]byte, error) {
	type embed PaymentPaginatedListForRead
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPaginatedListForRead) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentPlanFieldPaymentPlanId        = big.NewInt(1 << 0)
	paymentPlanFieldProcessingTerminalId = big.NewInt(1 << 1)
	paymentPlanFieldName                 = big.NewInt(1 << 2)
	paymentPlanFieldDescription          = big.NewInt(1 << 3)
	paymentPlanFieldCurrency             = big.NewInt(1 << 4)
	paymentPlanFieldLength               = big.NewInt(1 << 5)
	paymentPlanFieldType                 = big.NewInt(1 << 6)
	paymentPlanFieldFrequency            = big.NewInt(1 << 7)
	paymentPlanFieldOnUpdate             = big.NewInt(1 << 8)
	paymentPlanFieldOnDelete             = big.NewInt(1 << 9)
	paymentPlanFieldCustomFieldNames     = big.NewInt(1 << 10)
	paymentPlanFieldSetupOrder           = big.NewInt(1 << 11)
	paymentPlanFieldRecurringOrder       = big.NewInt(1 << 12)
)

type PaymentPlan struct {
	// Unique identifier that the merchant assigns to the payment plan.
	PaymentPlanId string `json:"paymentPlanId" url:"paymentPlanId"`
	// Unique identifier of the terminal that the payment plan is assigned to.
	ProcessingTerminalId *string `json:"processingTerminalId,omitempty" url:"processingTerminalId,omitempty"`
	// Name of the payment plan.
	Name string `json:"name" url:"name"`
	// Description of the payment plan.
	Description *string  `json:"description,omitempty" url:"description,omitempty"`
	Currency    Currency `json:"currency" url:"currency"`
	// Number of payments for the payment plan.
	//
	// To indicate that the payment plan should run indefinitely, send a value of `0`.
	Length *int `json:"length,omitempty" url:"length,omitempty"`
	// Indicates how the merchant takes the payment from the customer's account.
	// - `manual` - The merchant manually collects payments from the customer.
	// - `automatic` - The terminal automatically collects payments from the customer.
	Type PaymentPlanBaseType `json:"type" url:"type"`
	// Indicates how often the merchant or the terminal collects a payment from the customer.
	Frequency PaymentPlanBaseFrequency `json:"frequency" url:"frequency"`
	// Indicates whether any changes that the merchant makes to the payment plan apply to existing subscriptions.
	// - `update` - Changes apply to existing subscriptions.
	// - `continue` - Changes don't apply to existing subscriptions.
	OnUpdate PaymentPlanBaseOnUpdate `json:"onUpdate" url:"onUpdate"`
	// Indicates what happens to existing subscriptions if the merchant deletes the payment plan.
	// - `complete` - Stops existing subscriptions.
	// - `continue` - Continues existing subscriptions.
	OnDelete PaymentPlanBaseOnDelete `json:"onDelete" url:"onDelete"`
	// Array of custom fields that you can use in subscriptions linked to the payment plan.
	CustomFieldNames []string                   `json:"customFieldNames,omitempty" url:"customFieldNames,omitempty"`
	SetupOrder       *PaymentPlanSetupOrder     `json:"setupOrder,omitempty" url:"setupOrder,omitempty"`
	RecurringOrder   *PaymentPlanRecurringOrder `json:"recurringOrder,omitempty" url:"recurringOrder,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlan) GetPaymentPlanId() string {
	if p == nil {
		return ""
	}
	return p.PaymentPlanId
}

func (p *PaymentPlan) GetProcessingTerminalId() *string {
	if p == nil {
		return nil
	}
	return p.ProcessingTerminalId
}

func (p *PaymentPlan) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PaymentPlan) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentPlan) GetCurrency() Currency {
	if p == nil {
		return ""
	}
	return p.Currency
}

func (p *PaymentPlan) GetLength() *int {
	if p == nil {
		return nil
	}
	return p.Length
}

func (p *PaymentPlan) GetType() PaymentPlanBaseType {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentPlan) GetFrequency() PaymentPlanBaseFrequency {
	if p == nil {
		return ""
	}
	return p.Frequency
}

func (p *PaymentPlan) GetOnUpdate() PaymentPlanBaseOnUpdate {
	if p == nil {
		return ""
	}
	return p.OnUpdate
}

func (p *PaymentPlan) GetOnDelete() PaymentPlanBaseOnDelete {
	if p == nil {
		return ""
	}
	return p.OnDelete
}

func (p *PaymentPlan) GetCustomFieldNames() []string {
	if p == nil {
		return nil
	}
	return p.CustomFieldNames
}

func (p *PaymentPlan) GetSetupOrder() *PaymentPlanSetupOrder {
	if p == nil {
		return nil
	}
	return p.SetupOrder
}

func (p *PaymentPlan) GetRecurringOrder() *PaymentPlanRecurringOrder {
	if p == nil {
		return nil
	}
	return p.RecurringOrder
}

func (p *PaymentPlan) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlan) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPaymentPlanId sets the PaymentPlanId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetPaymentPlanId(paymentPlanId string) {
	p.PaymentPlanId = paymentPlanId
	p.require(paymentPlanFieldPaymentPlanId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetProcessingTerminalId(processingTerminalId *string) {
	p.ProcessingTerminalId = processingTerminalId
	p.require(paymentPlanFieldProcessingTerminalId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetName(name string) {
	p.Name = name
	p.require(paymentPlanFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetDescription(description *string) {
	p.Description = description
	p.require(paymentPlanFieldDescription)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetCurrency(currency Currency) {
	p.Currency = currency
	p.require(paymentPlanFieldCurrency)
}

// SetLength sets the Length field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetLength(length *int) {
	p.Length = length
	p.require(paymentPlanFieldLength)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetType(type_ PaymentPlanBaseType) {
	p.Type = type_
	p.require(paymentPlanFieldType)
}

// SetFrequency sets the Frequency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetFrequency(frequency PaymentPlanBaseFrequency) {
	p.Frequency = frequency
	p.require(paymentPlanFieldFrequency)
}

// SetOnUpdate sets the OnUpdate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetOnUpdate(onUpdate PaymentPlanBaseOnUpdate) {
	p.OnUpdate = onUpdate
	p.require(paymentPlanFieldOnUpdate)
}

// SetOnDelete sets the OnDelete field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetOnDelete(onDelete PaymentPlanBaseOnDelete) {
	p.OnDelete = onDelete
	p.require(paymentPlanFieldOnDelete)
}

// SetCustomFieldNames sets the CustomFieldNames field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetCustomFieldNames(customFieldNames []string) {
	p.CustomFieldNames = customFieldNames
	p.require(paymentPlanFieldCustomFieldNames)
}

// SetSetupOrder sets the SetupOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetSetupOrder(setupOrder *PaymentPlanSetupOrder) {
	p.SetupOrder = setupOrder
	p.require(paymentPlanFieldSetupOrder)
}

// SetRecurringOrder sets the RecurringOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlan) SetRecurringOrder(recurringOrder *PaymentPlanRecurringOrder) {
	p.RecurringOrder = recurringOrder
	p.require(paymentPlanFieldRecurringOrder)
}

func (p *PaymentPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlan) MarshalJSON() ([]byte, error) {
	type embed PaymentPlan
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlan) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentPlanBaseFieldPaymentPlanId        = big.NewInt(1 << 0)
	paymentPlanBaseFieldProcessingTerminalId = big.NewInt(1 << 1)
	paymentPlanBaseFieldName                 = big.NewInt(1 << 2)
	paymentPlanBaseFieldDescription          = big.NewInt(1 << 3)
	paymentPlanBaseFieldCurrency             = big.NewInt(1 << 4)
	paymentPlanBaseFieldLength               = big.NewInt(1 << 5)
	paymentPlanBaseFieldType                 = big.NewInt(1 << 6)
	paymentPlanBaseFieldFrequency            = big.NewInt(1 << 7)
	paymentPlanBaseFieldOnUpdate             = big.NewInt(1 << 8)
	paymentPlanBaseFieldOnDelete             = big.NewInt(1 << 9)
	paymentPlanBaseFieldCustomFieldNames     = big.NewInt(1 << 10)
)

type PaymentPlanBase struct {
	// Unique identifier that the merchant assigns to the payment plan.
	PaymentPlanId string `json:"paymentPlanId" url:"paymentPlanId"`
	// Unique identifier of the terminal that the payment plan is assigned to.
	ProcessingTerminalId *string `json:"processingTerminalId,omitempty" url:"processingTerminalId,omitempty"`
	// Name of the payment plan.
	Name string `json:"name" url:"name"`
	// Description of the payment plan.
	Description *string  `json:"description,omitempty" url:"description,omitempty"`
	Currency    Currency `json:"currency" url:"currency"`
	// Number of payments for the payment plan.
	//
	// To indicate that the payment plan should run indefinitely, send a value of `0`.
	Length *int `json:"length,omitempty" url:"length,omitempty"`
	// Indicates how the merchant takes the payment from the customer's account.
	// - `manual` - The merchant manually collects payments from the customer.
	// - `automatic` - The terminal automatically collects payments from the customer.
	Type PaymentPlanBaseType `json:"type" url:"type"`
	// Indicates how often the merchant or the terminal collects a payment from the customer.
	Frequency PaymentPlanBaseFrequency `json:"frequency" url:"frequency"`
	// Indicates whether any changes that the merchant makes to the payment plan apply to existing subscriptions.
	// - `update` - Changes apply to existing subscriptions.
	// - `continue` - Changes don't apply to existing subscriptions.
	OnUpdate PaymentPlanBaseOnUpdate `json:"onUpdate" url:"onUpdate"`
	// Indicates what happens to existing subscriptions if the merchant deletes the payment plan.
	// - `complete` - Stops existing subscriptions.
	// - `continue` - Continues existing subscriptions.
	OnDelete PaymentPlanBaseOnDelete `json:"onDelete" url:"onDelete"`
	// Array of custom fields that you can use in subscriptions linked to the payment plan.
	CustomFieldNames []string `json:"customFieldNames,omitempty" url:"customFieldNames,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanBase) GetPaymentPlanId() string {
	if p == nil {
		return ""
	}
	return p.PaymentPlanId
}

func (p *PaymentPlanBase) GetProcessingTerminalId() *string {
	if p == nil {
		return nil
	}
	return p.ProcessingTerminalId
}

func (p *PaymentPlanBase) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PaymentPlanBase) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentPlanBase) GetCurrency() Currency {
	if p == nil {
		return ""
	}
	return p.Currency
}

func (p *PaymentPlanBase) GetLength() *int {
	if p == nil {
		return nil
	}
	return p.Length
}

func (p *PaymentPlanBase) GetType() PaymentPlanBaseType {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *PaymentPlanBase) GetFrequency() PaymentPlanBaseFrequency {
	if p == nil {
		return ""
	}
	return p.Frequency
}

func (p *PaymentPlanBase) GetOnUpdate() PaymentPlanBaseOnUpdate {
	if p == nil {
		return ""
	}
	return p.OnUpdate
}

func (p *PaymentPlanBase) GetOnDelete() PaymentPlanBaseOnDelete {
	if p == nil {
		return ""
	}
	return p.OnDelete
}

func (p *PaymentPlanBase) GetCustomFieldNames() []string {
	if p == nil {
		return nil
	}
	return p.CustomFieldNames
}

func (p *PaymentPlanBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanBase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPaymentPlanId sets the PaymentPlanId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetPaymentPlanId(paymentPlanId string) {
	p.PaymentPlanId = paymentPlanId
	p.require(paymentPlanBaseFieldPaymentPlanId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetProcessingTerminalId(processingTerminalId *string) {
	p.ProcessingTerminalId = processingTerminalId
	p.require(paymentPlanBaseFieldProcessingTerminalId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetName(name string) {
	p.Name = name
	p.require(paymentPlanBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetDescription(description *string) {
	p.Description = description
	p.require(paymentPlanBaseFieldDescription)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetCurrency(currency Currency) {
	p.Currency = currency
	p.require(paymentPlanBaseFieldCurrency)
}

// SetLength sets the Length field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetLength(length *int) {
	p.Length = length
	p.require(paymentPlanBaseFieldLength)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetType(type_ PaymentPlanBaseType) {
	p.Type = type_
	p.require(paymentPlanBaseFieldType)
}

// SetFrequency sets the Frequency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetFrequency(frequency PaymentPlanBaseFrequency) {
	p.Frequency = frequency
	p.require(paymentPlanBaseFieldFrequency)
}

// SetOnUpdate sets the OnUpdate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetOnUpdate(onUpdate PaymentPlanBaseOnUpdate) {
	p.OnUpdate = onUpdate
	p.require(paymentPlanBaseFieldOnUpdate)
}

// SetOnDelete sets the OnDelete field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetOnDelete(onDelete PaymentPlanBaseOnDelete) {
	p.OnDelete = onDelete
	p.require(paymentPlanBaseFieldOnDelete)
}

// SetCustomFieldNames sets the CustomFieldNames field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanBase) SetCustomFieldNames(customFieldNames []string) {
	p.CustomFieldNames = customFieldNames
	p.require(paymentPlanBaseFieldCustomFieldNames)
}

func (p *PaymentPlanBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanBase) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates how often the merchant or the terminal collects a payment from the customer.
type PaymentPlanBaseFrequency string

const (
	PaymentPlanBaseFrequencyWeekly      PaymentPlanBaseFrequency = "weekly"
	PaymentPlanBaseFrequencyFortnightly PaymentPlanBaseFrequency = "fortnightly"
	PaymentPlanBaseFrequencyMonthly     PaymentPlanBaseFrequency = "monthly"
	PaymentPlanBaseFrequencyQuarterly   PaymentPlanBaseFrequency = "quarterly"
	PaymentPlanBaseFrequencyYearly      PaymentPlanBaseFrequency = "yearly"
)

func NewPaymentPlanBaseFrequencyFromString(s string) (PaymentPlanBaseFrequency, error) {
	switch s {
	case "weekly":
		return PaymentPlanBaseFrequencyWeekly, nil
	case "fortnightly":
		return PaymentPlanBaseFrequencyFortnightly, nil
	case "monthly":
		return PaymentPlanBaseFrequencyMonthly, nil
	case "quarterly":
		return PaymentPlanBaseFrequencyQuarterly, nil
	case "yearly":
		return PaymentPlanBaseFrequencyYearly, nil
	}
	var t PaymentPlanBaseFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentPlanBaseFrequency) Ptr() *PaymentPlanBaseFrequency {
	return &p
}

// Indicates what happens to existing subscriptions if the merchant deletes the payment plan.
// - `complete` - Stops existing subscriptions.
// - `continue` - Continues existing subscriptions.
type PaymentPlanBaseOnDelete string

const (
	PaymentPlanBaseOnDeleteComplete PaymentPlanBaseOnDelete = "complete"
	PaymentPlanBaseOnDeleteContinue PaymentPlanBaseOnDelete = "continue"
)

func NewPaymentPlanBaseOnDeleteFromString(s string) (PaymentPlanBaseOnDelete, error) {
	switch s {
	case "complete":
		return PaymentPlanBaseOnDeleteComplete, nil
	case "continue":
		return PaymentPlanBaseOnDeleteContinue, nil
	}
	var t PaymentPlanBaseOnDelete
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentPlanBaseOnDelete) Ptr() *PaymentPlanBaseOnDelete {
	return &p
}

// Indicates whether any changes that the merchant makes to the payment plan apply to existing subscriptions.
// - `update` - Changes apply to existing subscriptions.
// - `continue` - Changes don't apply to existing subscriptions.
type PaymentPlanBaseOnUpdate string

const (
	PaymentPlanBaseOnUpdateUpdate   PaymentPlanBaseOnUpdate = "update"
	PaymentPlanBaseOnUpdateContinue PaymentPlanBaseOnUpdate = "continue"
)

func NewPaymentPlanBaseOnUpdateFromString(s string) (PaymentPlanBaseOnUpdate, error) {
	switch s {
	case "update":
		return PaymentPlanBaseOnUpdateUpdate, nil
	case "continue":
		return PaymentPlanBaseOnUpdateContinue, nil
	}
	var t PaymentPlanBaseOnUpdate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentPlanBaseOnUpdate) Ptr() *PaymentPlanBaseOnUpdate {
	return &p
}

// Indicates how the merchant takes the payment from the customer's account.
// - `manual` - The merchant manually collects payments from the customer.
// - `automatic` - The terminal automatically collects payments from the customer.
type PaymentPlanBaseType string

const (
	PaymentPlanBaseTypeManual    PaymentPlanBaseType = "manual"
	PaymentPlanBaseTypeAutomatic PaymentPlanBaseType = "automatic"
)

func NewPaymentPlanBaseTypeFromString(s string) (PaymentPlanBaseType, error) {
	switch s {
	case "manual":
		return PaymentPlanBaseTypeManual, nil
	case "automatic":
		return PaymentPlanBaseTypeAutomatic, nil
	}
	var t PaymentPlanBaseType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentPlanBaseType) Ptr() *PaymentPlanBaseType {
	return &p
}

var (
	paymentPlanOrderBreakdownFieldSubtotal = big.NewInt(1 << 0)
	paymentPlanOrderBreakdownFieldTaxes    = big.NewInt(1 << 1)
)

type PaymentPlanOrderBreakdown struct {
	// Total amount for the transaction before tax. The value is in the currency's lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`
	// Array of tax objects.
	Taxes []*RetrievedTax `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanOrderBreakdown) GetSubtotal() int64 {
	if p == nil {
		return 0
	}
	return p.Subtotal
}

func (p *PaymentPlanOrderBreakdown) GetTaxes() []*RetrievedTax {
	if p == nil {
		return nil
	}
	return p.Taxes
}

func (p *PaymentPlanOrderBreakdown) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanOrderBreakdown) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanOrderBreakdown) SetSubtotal(subtotal int64) {
	p.Subtotal = subtotal
	p.require(paymentPlanOrderBreakdownFieldSubtotal)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanOrderBreakdown) SetTaxes(taxes []*RetrievedTax) {
	p.Taxes = taxes
	p.require(paymentPlanOrderBreakdownFieldTaxes)
}

func (p *PaymentPlanOrderBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanOrderBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanOrderBreakdown(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanOrderBreakdown) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanOrderBreakdown
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanOrderBreakdown) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the taxes that apply to the transaction.
var (
	paymentPlanOrderBreakdownBaseFieldSubtotal = big.NewInt(1 << 0)
)

type PaymentPlanOrderBreakdownBase struct {
	// Total amount for the transaction before tax. The value is in the currency's lowest denomination, for example, cents.
	Subtotal int64 `json:"subtotal" url:"subtotal"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanOrderBreakdownBase) GetSubtotal() int64 {
	if p == nil {
		return 0
	}
	return p.Subtotal
}

func (p *PaymentPlanOrderBreakdownBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanOrderBreakdownBase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanOrderBreakdownBase) SetSubtotal(subtotal int64) {
	p.Subtotal = subtotal
	p.require(paymentPlanOrderBreakdownBaseFieldSubtotal)
}

func (p *PaymentPlanOrderBreakdownBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanOrderBreakdownBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanOrderBreakdownBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanOrderBreakdownBase) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanOrderBreakdownBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanOrderBreakdownBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentPlanPaginatedListFieldLimit   = big.NewInt(1 << 0)
	paymentPlanPaginatedListFieldCount   = big.NewInt(1 << 1)
	paymentPlanPaginatedListFieldHasMore = big.NewInt(1 << 2)
	paymentPlanPaginatedListFieldLinks   = big.NewInt(1 << 3)
	paymentPlanPaginatedListFieldData    = big.NewInt(1 << 4)
)

type PaymentPlanPaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of paymentPlan objects.
	Data []*PaymentPlan `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanPaginatedList) GetLimit() *int {
	if p == nil {
		return nil
	}
	return p.Limit
}

func (p *PaymentPlanPaginatedList) GetCount() *int {
	if p == nil {
		return nil
	}
	return p.Count
}

func (p *PaymentPlanPaginatedList) GetHasMore() *bool {
	if p == nil {
		return nil
	}
	return p.HasMore
}

func (p *PaymentPlanPaginatedList) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *PaymentPlanPaginatedList) GetData() []*PaymentPlan {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentPlanPaginatedList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanPaginatedList) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanPaginatedList) SetLimit(limit *int) {
	p.Limit = limit
	p.require(paymentPlanPaginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanPaginatedList) SetCount(count *int) {
	p.Count = count
	p.require(paymentPlanPaginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanPaginatedList) SetHasMore(hasMore *bool) {
	p.HasMore = hasMore
	p.require(paymentPlanPaginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanPaginatedList) SetLinks(links []*Link) {
	p.Links = links
	p.require(paymentPlanPaginatedListFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanPaginatedList) SetData(data []*PaymentPlan) {
	p.Data = data
	p.require(paymentPlanPaginatedListFieldData)
}

func (p *PaymentPlanPaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanPaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanPaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanPaginatedList) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanPaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanPaginatedList) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentPlanRecurringOrderFieldAmount      = big.NewInt(1 << 0)
	paymentPlanRecurringOrderFieldDescription = big.NewInt(1 << 1)
	paymentPlanRecurringOrderFieldBreakdown   = big.NewInt(1 << 2)
)

type PaymentPlanRecurringOrder struct {
	// Total amount before surcharges. The value is in the currency's lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string                    `json:"description,omitempty" url:"description,omitempty"`
	Breakdown   *PaymentPlanOrderBreakdown `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanRecurringOrder) GetAmount() *int64 {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PaymentPlanRecurringOrder) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentPlanRecurringOrder) GetBreakdown() *PaymentPlanOrderBreakdown {
	if p == nil {
		return nil
	}
	return p.Breakdown
}

func (p *PaymentPlanRecurringOrder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanRecurringOrder) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanRecurringOrder) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentPlanRecurringOrderFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanRecurringOrder) SetDescription(description *string) {
	p.Description = description
	p.require(paymentPlanRecurringOrderFieldDescription)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanRecurringOrder) SetBreakdown(breakdown *PaymentPlanOrderBreakdown) {
	p.Breakdown = breakdown
	p.require(paymentPlanRecurringOrderFieldBreakdown)
}

func (p *PaymentPlanRecurringOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanRecurringOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanRecurringOrder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanRecurringOrder) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanRecurringOrder
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanRecurringOrder) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the cost of each payment.
// **Note:** Send this object only if the value for **type** is `automatic`.
var (
	paymentPlanRecurringOrderBaseFieldAmount      = big.NewInt(1 << 0)
	paymentPlanRecurringOrderBaseFieldDescription = big.NewInt(1 << 1)
)

type PaymentPlanRecurringOrderBase struct {
	// Total amount before surcharges. The value is in the currency's lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanRecurringOrderBase) GetAmount() *int64 {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PaymentPlanRecurringOrderBase) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentPlanRecurringOrderBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanRecurringOrderBase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanRecurringOrderBase) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentPlanRecurringOrderBaseFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanRecurringOrderBase) SetDescription(description *string) {
	p.Description = description
	p.require(paymentPlanRecurringOrderBaseFieldDescription)
}

func (p *PaymentPlanRecurringOrderBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanRecurringOrderBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanRecurringOrderBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanRecurringOrderBase) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanRecurringOrderBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanRecurringOrderBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentPlanSetupOrderFieldAmount      = big.NewInt(1 << 0)
	paymentPlanSetupOrderFieldDescription = big.NewInt(1 << 1)
	paymentPlanSetupOrderFieldBreakdown   = big.NewInt(1 << 2)
)

type PaymentPlanSetupOrder struct {
	// Total amount before surcharges. The value is in the currency's lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string                    `json:"description,omitempty" url:"description,omitempty"`
	Breakdown   *PaymentPlanOrderBreakdown `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanSetupOrder) GetAmount() *int64 {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PaymentPlanSetupOrder) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentPlanSetupOrder) GetBreakdown() *PaymentPlanOrderBreakdown {
	if p == nil {
		return nil
	}
	return p.Breakdown
}

func (p *PaymentPlanSetupOrder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanSetupOrder) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSetupOrder) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentPlanSetupOrderFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSetupOrder) SetDescription(description *string) {
	p.Description = description
	p.require(paymentPlanSetupOrderFieldDescription)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSetupOrder) SetBreakdown(breakdown *PaymentPlanOrderBreakdown) {
	p.Breakdown = breakdown
	p.require(paymentPlanSetupOrderFieldBreakdown)
}

func (p *PaymentPlanSetupOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanSetupOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanSetupOrder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanSetupOrder) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanSetupOrder
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanSetupOrder) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the initial cost that a customer pays to set up the subscription.
var (
	paymentPlanSetupOrderBaseFieldAmount      = big.NewInt(1 << 0)
	paymentPlanSetupOrderBaseFieldDescription = big.NewInt(1 << 1)
)

type PaymentPlanSetupOrderBase struct {
	// Total amount before surcharges. The value is in the currency's lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanSetupOrderBase) GetAmount() *int64 {
	if p == nil {
		return nil
	}
	return p.Amount
}

func (p *PaymentPlanSetupOrderBase) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentPlanSetupOrderBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanSetupOrderBase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSetupOrderBase) SetAmount(amount *int64) {
	p.Amount = amount
	p.require(paymentPlanSetupOrderBaseFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSetupOrderBase) SetDescription(description *string) {
	p.Description = description
	p.require(paymentPlanSetupOrderBaseFieldDescription)
}

func (p *PaymentPlanSetupOrderBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanSetupOrderBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanSetupOrderBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanSetupOrderBase) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanSetupOrderBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanSetupOrderBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	paymentPlanSummaryFieldPaymentPlanId = big.NewInt(1 << 0)
	paymentPlanSummaryFieldName          = big.NewInt(1 << 1)
	paymentPlanSummaryFieldLink          = big.NewInt(1 << 2)
)

type PaymentPlanSummary struct {
	// Unique identifier that the merchant assigns to the payment plan.
	PaymentPlanId string `json:"paymentPlanId" url:"paymentPlanId"`
	// Name of the payment plan.
	Name string `json:"name" url:"name"`
	Link *Link  `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentPlanSummary) GetPaymentPlanId() string {
	if p == nil {
		return ""
	}
	return p.PaymentPlanId
}

func (p *PaymentPlanSummary) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PaymentPlanSummary) GetLink() *Link {
	if p == nil {
		return nil
	}
	return p.Link
}

func (p *PaymentPlanSummary) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentPlanSummary) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPaymentPlanId sets the PaymentPlanId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSummary) SetPaymentPlanId(paymentPlanId string) {
	p.PaymentPlanId = paymentPlanId
	p.require(paymentPlanSummaryFieldPaymentPlanId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSummary) SetName(name string) {
	p.Name = name
	p.require(paymentPlanSummaryFieldName)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentPlanSummary) SetLink(link *Link) {
	p.Link = link
	p.require(paymentPlanSummaryFieldLink)
}

func (p *PaymentPlanSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentPlanSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentPlanSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentPlanSummary) MarshalJSON() ([]byte, error) {
	type embed PaymentPlanSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentPlanSummary) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about a payment.
var (
	paymentSummaryFieldPaymentId       = big.NewInt(1 << 0)
	paymentSummaryFieldDateTime        = big.NewInt(1 << 1)
	paymentSummaryFieldCurrency        = big.NewInt(1 << 2)
	paymentSummaryFieldAmount          = big.NewInt(1 << 3)
	paymentSummaryFieldStatus          = big.NewInt(1 << 4)
	paymentSummaryFieldResponseCode    = big.NewInt(1 << 5)
	paymentSummaryFieldResponseMessage = big.NewInt(1 << 6)
	paymentSummaryFieldLink            = big.NewInt(1 << 7)
)

type PaymentSummary struct {
	// Unique identifier of the payment.
	PaymentId string `json:"paymentId" url:"paymentId"`
	// Date and time that the payment was processed.
	DateTime time.Time `json:"dateTime" url:"dateTime"`
	Currency Currency  `json:"currency" url:"currency"`
	// Amount of the payment. This value is in the currency’s lowest denomination, for example, cents.
	Amount int64 `json:"amount" url:"amount"`
	// Current status of the payment.
	Status PaymentSummaryStatus `json:"status" url:"status"`
	// Response from the processor.
	// - `A` - The processor approved the transaction.
	// - `D` - The processor declined the transaction.
	// - `E` - The processor received the transaction but will process the transaction later.
	// - `P` - The processor authorized a portion of the original amount of the transaction.
	// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
	// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
	ResponseCode PaymentSummaryResponseCode `json:"responseCode" url:"responseCode"`
	// Response description from the processor.
	ResponseMessage *string `json:"responseMessage,omitempty" url:"responseMessage,omitempty"`
	Link            *Link   `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentSummary) GetPaymentId() string {
	if p == nil {
		return ""
	}
	return p.PaymentId
}

func (p *PaymentSummary) GetDateTime() time.Time {
	if p == nil {
		return time.Time{}
	}
	return p.DateTime
}

func (p *PaymentSummary) GetCurrency() Currency {
	if p == nil {
		return ""
	}
	return p.Currency
}

func (p *PaymentSummary) GetAmount() int64 {
	if p == nil {
		return 0
	}
	return p.Amount
}

func (p *PaymentSummary) GetStatus() PaymentSummaryStatus {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *PaymentSummary) GetResponseCode() PaymentSummaryResponseCode {
	if p == nil {
		return ""
	}
	return p.ResponseCode
}

func (p *PaymentSummary) GetResponseMessage() *string {
	if p == nil {
		return nil
	}
	return p.ResponseMessage
}

func (p *PaymentSummary) GetLink() *Link {
	if p == nil {
		return nil
	}
	return p.Link
}

func (p *PaymentSummary) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentSummary) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetPaymentId(paymentId string) {
	p.PaymentId = paymentId
	p.require(paymentSummaryFieldPaymentId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetDateTime(dateTime time.Time) {
	p.DateTime = dateTime
	p.require(paymentSummaryFieldDateTime)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetCurrency(currency Currency) {
	p.Currency = currency
	p.require(paymentSummaryFieldCurrency)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetAmount(amount int64) {
	p.Amount = amount
	p.require(paymentSummaryFieldAmount)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetStatus(status PaymentSummaryStatus) {
	p.Status = status
	p.require(paymentSummaryFieldStatus)
}

// SetResponseCode sets the ResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetResponseCode(responseCode PaymentSummaryResponseCode) {
	p.ResponseCode = responseCode
	p.require(paymentSummaryFieldResponseCode)
}

// SetResponseMessage sets the ResponseMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetResponseMessage(responseMessage *string) {
	p.ResponseMessage = responseMessage
	p.require(paymentSummaryFieldResponseMessage)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaymentSummary) SetLink(link *Link) {
	p.Link = link
	p.require(paymentSummaryFieldLink)
}

func (p *PaymentSummary) UnmarshalJSON(data []byte) error {
	type embed PaymentSummary
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PaymentSummary(unmarshaler.embed)
	p.DateTime = unmarshaler.DateTime.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentSummary) MarshalJSON() ([]byte, error) {
	type embed PaymentSummary
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime"`
	}{
		embed:    embed(*p),
		DateTime: internal.NewDateTime(p.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaymentSummary) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Response from the processor.
// - `A` - The processor approved the transaction.
// - `D` - The processor declined the transaction.
// - `E` - The processor received the transaction but will process the transaction later.
// - `P` - The processor authorized a portion of the original amount of the transaction.
// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
type PaymentSummaryResponseCode string

const (
	PaymentSummaryResponseCodeA PaymentSummaryResponseCode = "A"
	PaymentSummaryResponseCodeD PaymentSummaryResponseCode = "D"
	PaymentSummaryResponseCodeE PaymentSummaryResponseCode = "E"
	PaymentSummaryResponseCodeP PaymentSummaryResponseCode = "P"
	PaymentSummaryResponseCodeR PaymentSummaryResponseCode = "R"
	PaymentSummaryResponseCodeC PaymentSummaryResponseCode = "C"
)

func NewPaymentSummaryResponseCodeFromString(s string) (PaymentSummaryResponseCode, error) {
	switch s {
	case "A":
		return PaymentSummaryResponseCodeA, nil
	case "D":
		return PaymentSummaryResponseCodeD, nil
	case "E":
		return PaymentSummaryResponseCodeE, nil
	case "P":
		return PaymentSummaryResponseCodeP, nil
	case "R":
		return PaymentSummaryResponseCodeR, nil
	case "C":
		return PaymentSummaryResponseCodeC, nil
	}
	var t PaymentSummaryResponseCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentSummaryResponseCode) Ptr() *PaymentSummaryResponseCode {
	return &p
}

// Current status of the payment.
type PaymentSummaryStatus string

const (
	PaymentSummaryStatusReady    PaymentSummaryStatus = "ready"
	PaymentSummaryStatusPending  PaymentSummaryStatus = "pending"
	PaymentSummaryStatusDeclined PaymentSummaryStatus = "declined"
	PaymentSummaryStatusComplete PaymentSummaryStatus = "complete"
	PaymentSummaryStatusReferral PaymentSummaryStatus = "referral"
	PaymentSummaryStatusPickup   PaymentSummaryStatus = "pickup"
	PaymentSummaryStatusReversal PaymentSummaryStatus = "reversal"
	PaymentSummaryStatusReturned PaymentSummaryStatus = "returned"
	PaymentSummaryStatusAdmin    PaymentSummaryStatus = "admin"
	PaymentSummaryStatusExpired  PaymentSummaryStatus = "expired"
	PaymentSummaryStatusAccepted PaymentSummaryStatus = "accepted"
)

func NewPaymentSummaryStatusFromString(s string) (PaymentSummaryStatus, error) {
	switch s {
	case "ready":
		return PaymentSummaryStatusReady, nil
	case "pending":
		return PaymentSummaryStatusPending, nil
	case "declined":
		return PaymentSummaryStatusDeclined, nil
	case "complete":
		return PaymentSummaryStatusComplete, nil
	case "referral":
		return PaymentSummaryStatusReferral, nil
	case "pickup":
		return PaymentSummaryStatusPickup, nil
	case "reversal":
		return PaymentSummaryStatusReversal, nil
	case "returned":
		return PaymentSummaryStatusReturned, nil
	case "admin":
		return PaymentSummaryStatusAdmin, nil
	case "expired":
		return PaymentSummaryStatusExpired, nil
	case "accepted":
		return PaymentSummaryStatusAccepted, nil
	}
	var t PaymentSummaryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentSummaryStatus) Ptr() *PaymentSummaryStatus {
	return &p
}

// Object that contains the gateway settings for the solution.
var (
	payrocGatewayFieldGateway            = big.NewInt(1 << 0)
	payrocGatewayFieldTerminalTemplateId = big.NewInt(1 << 1)
)

type PayrocGateway struct {
	// Name of the gateway that processes the transactions.
	Gateway PayrocGatewayGateway `json:"gateway" url:"gateway"`
	// Unique identifier of the gateway terminal template.
	TerminalTemplateId string `json:"terminalTemplateId" url:"terminalTemplateId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayrocGateway) GetGateway() PayrocGatewayGateway {
	if p == nil {
		return ""
	}
	return p.Gateway
}

func (p *PayrocGateway) GetTerminalTemplateId() string {
	if p == nil {
		return ""
	}
	return p.TerminalTemplateId
}

func (p *PayrocGateway) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayrocGateway) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetGateway sets the Gateway field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PayrocGateway) SetGateway(gateway PayrocGatewayGateway) {
	p.Gateway = gateway
	p.require(payrocGatewayFieldGateway)
}

// SetTerminalTemplateId sets the TerminalTemplateId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PayrocGateway) SetTerminalTemplateId(terminalTemplateId string) {
	p.TerminalTemplateId = terminalTemplateId
	p.require(payrocGatewayFieldTerminalTemplateId)
}

func (p *PayrocGateway) UnmarshalJSON(data []byte) error {
	type unmarshaler PayrocGateway
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayrocGateway(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayrocGateway) MarshalJSON() ([]byte, error) {
	type embed PayrocGateway
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PayrocGateway) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Name of the gateway that processes the transactions.
type PayrocGatewayGateway string

const (
	PayrocGatewayGatewayPayroc PayrocGatewayGateway = "payroc"
)

func NewPayrocGatewayGatewayFromString(s string) (PayrocGatewayGateway, error) {
	switch s {
	case "payroc":
		return PayrocGatewayGatewayPayroc, nil
	}
	var t PayrocGatewayGateway
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayrocGatewayGateway) Ptr() *PayrocGatewayGateway {
	return &p
}

// Percentage value up to 2 decimal places.
type Percentage = float64

// Object that contains the fees for PIN-debit transactions.
var (
	pinDebitFieldAdditionalDiscount = big.NewInt(1 << 0)
	pinDebitFieldTransaction        = big.NewInt(1 << 1)
	pinDebitFieldMonthlyAccess      = big.NewInt(1 << 2)
)

type PinDebit struct {
	// Percentage of additional discount.
	AdditionalDiscount Percentage `json:"additionalDiscount" url:"additionalDiscount"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`
	// Monthly access fee for using PIN-debit services. The value is in the currency's lowest denomination, for example, cents.
	MonthlyAccess Amount `json:"monthlyAccess" url:"monthlyAccess"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PinDebit) GetAdditionalDiscount() Percentage {
	if p == nil {
		return 0
	}
	return p.AdditionalDiscount
}

func (p *PinDebit) GetTransaction() Amount {
	if p == nil {
		return 0
	}
	return p.Transaction
}

func (p *PinDebit) GetMonthlyAccess() Amount {
	if p == nil {
		return 0
	}
	return p.MonthlyAccess
}

func (p *PinDebit) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PinDebit) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAdditionalDiscount sets the AdditionalDiscount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PinDebit) SetAdditionalDiscount(additionalDiscount Percentage) {
	p.AdditionalDiscount = additionalDiscount
	p.require(pinDebitFieldAdditionalDiscount)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PinDebit) SetTransaction(transaction Amount) {
	p.Transaction = transaction
	p.require(pinDebitFieldTransaction)
}

// SetMonthlyAccess sets the MonthlyAccess field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PinDebit) SetMonthlyAccess(monthlyAccess Amount) {
	p.MonthlyAccess = monthlyAccess
	p.require(pinDebitFieldMonthlyAccess)
}

func (p *PinDebit) UnmarshalJSON(data []byte) error {
	type unmarshaler PinDebit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PinDebit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PinDebit) MarshalJSON() ([]byte, error) {
	type embed PinDebit
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PinDebit) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the plain-text card data for keyed transactions.
var (
	plainTextKeyedDataFormatFieldDevice      = big.NewInt(1 << 0)
	plainTextKeyedDataFormatFieldCardNumber  = big.NewInt(1 << 1)
	plainTextKeyedDataFormatFieldExpiryDate  = big.NewInt(1 << 2)
	plainTextKeyedDataFormatFieldCvv         = big.NewInt(1 << 3)
	plainTextKeyedDataFormatFieldIssueNumber = big.NewInt(1 << 4)
)

type PlainTextKeyedDataFormat struct {
	Device *Device `json:"device,omitempty" url:"device,omitempty"`
	// Customer’s card number.
	CardNumber string `json:"cardNumber" url:"cardNumber"`
	// Expiry date of the customer’s card.
	// **Note:** We require you to send an expiry date for most BIN lookups and electronic voucher transactions.
	ExpiryDate *string `json:"expiryDate,omitempty" url:"expiryDate,omitempty"`
	// Security code of the customer’s card.
	Cvv *string `json:"cvv,omitempty" url:"cvv,omitempty"`
	// Issue number of the customer’s card.
	IssueNumber *string `json:"issueNumber,omitempty" url:"issueNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlainTextKeyedDataFormat) GetDevice() *Device {
	if p == nil {
		return nil
	}
	return p.Device
}

func (p *PlainTextKeyedDataFormat) GetCardNumber() string {
	if p == nil {
		return ""
	}
	return p.CardNumber
}

func (p *PlainTextKeyedDataFormat) GetExpiryDate() *string {
	if p == nil {
		return nil
	}
	return p.ExpiryDate
}

func (p *PlainTextKeyedDataFormat) GetCvv() *string {
	if p == nil {
		return nil
	}
	return p.Cvv
}

func (p *PlainTextKeyedDataFormat) GetIssueNumber() *string {
	if p == nil {
		return nil
	}
	return p.IssueNumber
}

func (p *PlainTextKeyedDataFormat) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlainTextKeyedDataFormat) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextKeyedDataFormat) SetDevice(device *Device) {
	p.Device = device
	p.require(plainTextKeyedDataFormatFieldDevice)
}

// SetCardNumber sets the CardNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextKeyedDataFormat) SetCardNumber(cardNumber string) {
	p.CardNumber = cardNumber
	p.require(plainTextKeyedDataFormatFieldCardNumber)
}

// SetExpiryDate sets the ExpiryDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextKeyedDataFormat) SetExpiryDate(expiryDate *string) {
	p.ExpiryDate = expiryDate
	p.require(plainTextKeyedDataFormatFieldExpiryDate)
}

// SetCvv sets the Cvv field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextKeyedDataFormat) SetCvv(cvv *string) {
	p.Cvv = cvv
	p.require(plainTextKeyedDataFormatFieldCvv)
}

// SetIssueNumber sets the IssueNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextKeyedDataFormat) SetIssueNumber(issueNumber *string) {
	p.IssueNumber = issueNumber
	p.require(plainTextKeyedDataFormatFieldIssueNumber)
}

func (p *PlainTextKeyedDataFormat) UnmarshalJSON(data []byte) error {
	type unmarshaler PlainTextKeyedDataFormat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlainTextKeyedDataFormat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlainTextKeyedDataFormat) MarshalJSON() ([]byte, error) {
	type embed PlainTextKeyedDataFormat
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PlainTextKeyedDataFormat) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about plain-text swiped card data.
var (
	plainTextSwipedDataFormatFieldDevice         = big.NewInt(1 << 0)
	plainTextSwipedDataFormatFieldTrackData      = big.NewInt(1 << 1)
	plainTextSwipedDataFormatFieldFallback       = big.NewInt(1 << 2)
	plainTextSwipedDataFormatFieldFallbackReason = big.NewInt(1 << 3)
)

type PlainTextSwipedDataFormat struct {
	Device *Device `json:"device" url:"device"`
	// Customer’s card data from the swiped transaction.
	TrackData string `json:"trackData" url:"trackData"`
	// Indicates that this is a fallback transaction. For example, if there was a technical issue with the chip on the customer's card and the merchant then swiped the card.
	Fallback *bool `json:"fallback,omitempty" url:"fallback,omitempty"`
	// Reason for the fallback.
	FallbackReason *PlainTextSwipedDataFormatFallbackReason `json:"fallbackReason,omitempty" url:"fallbackReason,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlainTextSwipedDataFormat) GetDevice() *Device {
	if p == nil {
		return nil
	}
	return p.Device
}

func (p *PlainTextSwipedDataFormat) GetTrackData() string {
	if p == nil {
		return ""
	}
	return p.TrackData
}

func (p *PlainTextSwipedDataFormat) GetFallback() *bool {
	if p == nil {
		return nil
	}
	return p.Fallback
}

func (p *PlainTextSwipedDataFormat) GetFallbackReason() *PlainTextSwipedDataFormatFallbackReason {
	if p == nil {
		return nil
	}
	return p.FallbackReason
}

func (p *PlainTextSwipedDataFormat) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlainTextSwipedDataFormat) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextSwipedDataFormat) SetDevice(device *Device) {
	p.Device = device
	p.require(plainTextSwipedDataFormatFieldDevice)
}

// SetTrackData sets the TrackData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextSwipedDataFormat) SetTrackData(trackData string) {
	p.TrackData = trackData
	p.require(plainTextSwipedDataFormatFieldTrackData)
}

// SetFallback sets the Fallback field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextSwipedDataFormat) SetFallback(fallback *bool) {
	p.Fallback = fallback
	p.require(plainTextSwipedDataFormatFieldFallback)
}

// SetFallbackReason sets the FallbackReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlainTextSwipedDataFormat) SetFallbackReason(fallbackReason *PlainTextSwipedDataFormatFallbackReason) {
	p.FallbackReason = fallbackReason
	p.require(plainTextSwipedDataFormatFieldFallbackReason)
}

func (p *PlainTextSwipedDataFormat) UnmarshalJSON(data []byte) error {
	type unmarshaler PlainTextSwipedDataFormat
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PlainTextSwipedDataFormat(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlainTextSwipedDataFormat) MarshalJSON() ([]byte, error) {
	type embed PlainTextSwipedDataFormat
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PlainTextSwipedDataFormat) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Reason for the fallback.
type PlainTextSwipedDataFormatFallbackReason string

const (
	PlainTextSwipedDataFormatFallbackReasonTechnical          PlainTextSwipedDataFormatFallbackReason = "technical"
	PlainTextSwipedDataFormatFallbackReasonRepeatFallback     PlainTextSwipedDataFormatFallbackReason = "repeatFallback"
	PlainTextSwipedDataFormatFallbackReasonEmptyCandidateList PlainTextSwipedDataFormatFallbackReason = "emptyCandidateList"
)

func NewPlainTextSwipedDataFormatFallbackReasonFromString(s string) (PlainTextSwipedDataFormatFallbackReason, error) {
	switch s {
	case "technical":
		return PlainTextSwipedDataFormatFallbackReasonTechnical, nil
	case "repeatFallback":
		return PlainTextSwipedDataFormatFallbackReasonRepeatFallback, nil
	case "emptyCandidateList":
		return PlainTextSwipedDataFormatFallbackReasonEmptyCandidateList, nil
	}
	var t PlainTextSwipedDataFormatFallbackReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlainTextSwipedDataFormatFallbackReason) Ptr() *PlainTextSwipedDataFormatFallbackReason {
	return &p
}

// Polymorphic object that contains pricing information for the processing account.
//
// The value of the type parameter determines which variant you should use:
// -	`intent` - Use a pricing agreement template.
// -	`agreement` - Create a new pricing agreement.
type Pricing struct {
	Type      string
	Intent    *PricingTemplate
	Agreement *PricingAgreement
}

func (p *Pricing) GetType() string {
	if p == nil {
		return ""
	}
	return p.Type
}

func (p *Pricing) GetIntent() *PricingTemplate {
	if p == nil {
		return nil
	}
	return p.Intent
}

func (p *Pricing) GetAgreement() *PricingAgreement {
	if p == nil {
		return nil
	}
	return p.Agreement
}

func (p *Pricing) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", p)
	}
	switch unmarshaler.Type {
	case "intent":
		value := new(PricingTemplate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Intent = value
	case "agreement":
		value := new(PricingAgreement)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Agreement = value
	}
	return nil
}

func (p Pricing) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Intent != nil {
		return internal.MarshalJSONWithExtraProperty(p.Intent, "type", "intent")
	}
	if p.Agreement != nil {
		return internal.MarshalJSONWithExtraProperty(p.Agreement, "type", "agreement")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PricingVisitor interface {
	VisitIntent(*PricingTemplate) error
	VisitAgreement(*PricingAgreement) error
}

func (p *Pricing) Accept(visitor PricingVisitor) error {
	if p.Intent != nil {
		return visitor.VisitIntent(p.Intent)
	}
	if p.Agreement != nil {
		return visitor.VisitAgreement(p.Agreement)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *Pricing) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Intent != nil {
		fields = append(fields, "intent")
	}
	if p.Agreement != nil {
		fields = append(fields, "agreement")
	}
	if len(fields) == 0 {
		if p.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.Type)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.Type != "" {
		field := fields[0]
		if p.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.Type,
				p,
			)
		}
	}
	return nil
}

type PricingAgreement struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingAgreement) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingAgreement) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

func (p *PricingAgreement) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingAgreement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingAgreement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingAgreement) MarshalJSON() ([]byte, error) {
	type embed PricingAgreement
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingAgreement) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the pricing agreement reminder.
var (
	pricingAgreementReminderFieldReminderId = big.NewInt(1 << 0)
)

type PricingAgreementReminder struct {
	// Unique ID of the reminder.
	ReminderId *string `json:"reminderId,omitempty" url:"reminderId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingAgreementReminder) GetReminderId() *string {
	if p == nil {
		return nil
	}
	return p.ReminderId
}

func (p *PricingAgreementReminder) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingAgreementReminder) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetReminderId sets the ReminderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementReminder) SetReminderId(reminderId *string) {
	p.ReminderId = reminderId
	p.require(pricingAgreementReminderFieldReminderId)
}

func (p *PricingAgreementReminder) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingAgreementReminder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingAgreementReminder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingAgreementReminder) MarshalJSON() ([]byte, error) {
	type embed PricingAgreementReminder
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingAgreementReminder) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about U.S. pricing intents for Merchant Processing Agreement (MPA) 4.0.
var (
	pricingAgreementUs40FieldCountry   = big.NewInt(1 << 0)
	pricingAgreementUs40FieldVersion   = big.NewInt(1 << 1)
	pricingAgreementUs40FieldBase      = big.NewInt(1 << 2)
	pricingAgreementUs40FieldProcessor = big.NewInt(1 << 3)
	pricingAgreementUs40FieldGateway   = big.NewInt(1 << 4)
)

type PricingAgreementUs40 struct {
	// Two-digit code for the country that the pricing intent applies to. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
	Country PricingAgreementUs40Country `json:"country" url:"country"`
	// Version of the MPA.
	Version PricingAgreementUs40Version `json:"version" url:"version"`
	Base    *BaseUs                     `json:"base" url:"base"`
	// Object that contains information about U.S. processor fees.
	Processor *PricingAgreementUs40Processor `json:"processor,omitempty" url:"processor,omitempty"`
	Gateway   *GatewayUs                     `json:"gateway,omitempty" url:"gateway,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingAgreementUs40) GetCountry() PricingAgreementUs40Country {
	if p == nil {
		return ""
	}
	return p.Country
}

func (p *PricingAgreementUs40) GetVersion() PricingAgreementUs40Version {
	if p == nil {
		return ""
	}
	return p.Version
}

func (p *PricingAgreementUs40) GetBase() *BaseUs {
	if p == nil {
		return nil
	}
	return p.Base
}

func (p *PricingAgreementUs40) GetProcessor() *PricingAgreementUs40Processor {
	if p == nil {
		return nil
	}
	return p.Processor
}

func (p *PricingAgreementUs40) GetGateway() *GatewayUs {
	if p == nil {
		return nil
	}
	return p.Gateway
}

func (p *PricingAgreementUs40) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingAgreementUs40) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs40) SetCountry(country PricingAgreementUs40Country) {
	p.Country = country
	p.require(pricingAgreementUs40FieldCountry)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs40) SetVersion(version PricingAgreementUs40Version) {
	p.Version = version
	p.require(pricingAgreementUs40FieldVersion)
}

// SetBase sets the Base field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs40) SetBase(base *BaseUs) {
	p.Base = base
	p.require(pricingAgreementUs40FieldBase)
}

// SetProcessor sets the Processor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs40) SetProcessor(processor *PricingAgreementUs40Processor) {
	p.Processor = processor
	p.require(pricingAgreementUs40FieldProcessor)
}

// SetGateway sets the Gateway field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs40) SetGateway(gateway *GatewayUs) {
	p.Gateway = gateway
	p.require(pricingAgreementUs40FieldGateway)
}

func (p *PricingAgreementUs40) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingAgreementUs40
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingAgreementUs40(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingAgreementUs40) MarshalJSON() ([]byte, error) {
	type embed PricingAgreementUs40
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingAgreementUs40) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Two-digit code for the country that the pricing intent applies to. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
type PricingAgreementUs40Country string

const (
	PricingAgreementUs40CountryUs PricingAgreementUs40Country = "US"
)

func NewPricingAgreementUs40CountryFromString(s string) (PricingAgreementUs40Country, error) {
	switch s {
	case "US":
		return PricingAgreementUs40CountryUs, nil
	}
	var t PricingAgreementUs40Country
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PricingAgreementUs40Country) Ptr() *PricingAgreementUs40Country {
	return &p
}

// Object that contains information about U.S. processor fees.
var (
	pricingAgreementUs40ProcessorFieldCard = big.NewInt(1 << 0)
	pricingAgreementUs40ProcessorFieldAch  = big.NewInt(1 << 1)
)

type PricingAgreementUs40Processor struct {
	// Polymorphic object that contains fees for card transactions.
	//
	// The value of the planType field determines which variant you should use:
	// -	`interchangePlus` - Interchange + pricing
	// -	`interchangePlusTiered3` - Interchange pricing with three tiers
	// -	`tiered3` - Three-tiered pricing
	// -	`tiered4` - Four-tiered pricing
	// -	`tiered6` - Six-tiered pricing
	// -	`flatRate` - Flat rate pricing
	// -	`consumerChoice` - ConsumerChoice
	// -	`rewardPay` - RewardPay
	// -	`rewardPayChoice` - RewardPayChoice
	Card *PricingAgreementUs40ProcessorCard `json:"card,omitempty" url:"card,omitempty"`
	Ach  *Ach                               `json:"ach,omitempty" url:"ach,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingAgreementUs40Processor) GetCard() *PricingAgreementUs40ProcessorCard {
	if p == nil {
		return nil
	}
	return p.Card
}

func (p *PricingAgreementUs40Processor) GetAch() *Ach {
	if p == nil {
		return nil
	}
	return p.Ach
}

func (p *PricingAgreementUs40Processor) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingAgreementUs40Processor) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs40Processor) SetCard(card *PricingAgreementUs40ProcessorCard) {
	p.Card = card
	p.require(pricingAgreementUs40ProcessorFieldCard)
}

// SetAch sets the Ach field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs40Processor) SetAch(ach *Ach) {
	p.Ach = ach
	p.require(pricingAgreementUs40ProcessorFieldAch)
}

func (p *PricingAgreementUs40Processor) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingAgreementUs40Processor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingAgreementUs40Processor(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingAgreementUs40Processor) MarshalJSON() ([]byte, error) {
	type embed PricingAgreementUs40Processor
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingAgreementUs40Processor) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Polymorphic object that contains fees for card transactions.
//
// The value of the planType field determines which variant you should use:
// -	`interchangePlus` - Interchange + pricing
// -	`interchangePlusTiered3` - Interchange pricing with three tiers
// -	`tiered3` - Three-tiered pricing
// -	`tiered4` - Four-tiered pricing
// -	`tiered6` - Six-tiered pricing
// -	`flatRate` - Flat rate pricing
// -	`consumerChoice` - ConsumerChoice
// -	`rewardPay` - RewardPay
// -	`rewardPayChoice` - RewardPayChoice
type PricingAgreementUs40ProcessorCard struct {
	PlanType               string
	InterchangePlus        *InterchangePlus
	InterchangePlusTiered3 *InterchangePlusTiered3
	Tiered3                *Tiered3
	Tiered4                *Tiered4
	Tiered6                *Tiered6
	FlatRate               *FlatRate
	ConsumerChoice         *ConsumerChoice
	RewardPay              *RewardPay
	RewardPayChoice        *RewardPayChoice
}

func (p *PricingAgreementUs40ProcessorCard) GetPlanType() string {
	if p == nil {
		return ""
	}
	return p.PlanType
}

func (p *PricingAgreementUs40ProcessorCard) GetInterchangePlus() *InterchangePlus {
	if p == nil {
		return nil
	}
	return p.InterchangePlus
}

func (p *PricingAgreementUs40ProcessorCard) GetInterchangePlusTiered3() *InterchangePlusTiered3 {
	if p == nil {
		return nil
	}
	return p.InterchangePlusTiered3
}

func (p *PricingAgreementUs40ProcessorCard) GetTiered3() *Tiered3 {
	if p == nil {
		return nil
	}
	return p.Tiered3
}

func (p *PricingAgreementUs40ProcessorCard) GetTiered4() *Tiered4 {
	if p == nil {
		return nil
	}
	return p.Tiered4
}

func (p *PricingAgreementUs40ProcessorCard) GetTiered6() *Tiered6 {
	if p == nil {
		return nil
	}
	return p.Tiered6
}

func (p *PricingAgreementUs40ProcessorCard) GetFlatRate() *FlatRate {
	if p == nil {
		return nil
	}
	return p.FlatRate
}

func (p *PricingAgreementUs40ProcessorCard) GetConsumerChoice() *ConsumerChoice {
	if p == nil {
		return nil
	}
	return p.ConsumerChoice
}

func (p *PricingAgreementUs40ProcessorCard) GetRewardPay() *RewardPay {
	if p == nil {
		return nil
	}
	return p.RewardPay
}

func (p *PricingAgreementUs40ProcessorCard) GetRewardPayChoice() *RewardPayChoice {
	if p == nil {
		return nil
	}
	return p.RewardPayChoice
}

func (p *PricingAgreementUs40ProcessorCard) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PlanType string `json:"planType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.PlanType = unmarshaler.PlanType
	if unmarshaler.PlanType == "" {
		return fmt.Errorf("%T did not include discriminant planType", p)
	}
	switch unmarshaler.PlanType {
	case "interchangePlus":
		value := new(InterchangePlus)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.InterchangePlus = value
	case "interchangePlusTiered3":
		value := new(InterchangePlusTiered3)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.InterchangePlusTiered3 = value
	case "tiered3":
		value := new(Tiered3)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Tiered3 = value
	case "tiered4":
		value := new(Tiered4)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Tiered4 = value
	case "tiered6":
		value := new(Tiered6)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Tiered6 = value
	case "flatRate":
		value := new(FlatRate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.FlatRate = value
	case "consumerChoice":
		value := new(ConsumerChoice)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ConsumerChoice = value
	case "rewardPay":
		value := new(RewardPay)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.RewardPay = value
	case "rewardPayChoice":
		value := new(RewardPayChoice)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.RewardPayChoice = value
	}
	return nil
}

func (p PricingAgreementUs40ProcessorCard) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.InterchangePlus != nil {
		return internal.MarshalJSONWithExtraProperty(p.InterchangePlus, "planType", "interchangePlus")
	}
	if p.InterchangePlusTiered3 != nil {
		return internal.MarshalJSONWithExtraProperty(p.InterchangePlusTiered3, "planType", "interchangePlusTiered3")
	}
	if p.Tiered3 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Tiered3, "planType", "tiered3")
	}
	if p.Tiered4 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Tiered4, "planType", "tiered4")
	}
	if p.Tiered6 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Tiered6, "planType", "tiered6")
	}
	if p.FlatRate != nil {
		return internal.MarshalJSONWithExtraProperty(p.FlatRate, "planType", "flatRate")
	}
	if p.ConsumerChoice != nil {
		return internal.MarshalJSONWithExtraProperty(p.ConsumerChoice, "planType", "consumerChoice")
	}
	if p.RewardPay != nil {
		return internal.MarshalJSONWithExtraProperty(p.RewardPay, "planType", "rewardPay")
	}
	if p.RewardPayChoice != nil {
		return internal.MarshalJSONWithExtraProperty(p.RewardPayChoice, "planType", "rewardPayChoice")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PricingAgreementUs40ProcessorCardVisitor interface {
	VisitInterchangePlus(*InterchangePlus) error
	VisitInterchangePlusTiered3(*InterchangePlusTiered3) error
	VisitTiered3(*Tiered3) error
	VisitTiered4(*Tiered4) error
	VisitTiered6(*Tiered6) error
	VisitFlatRate(*FlatRate) error
	VisitConsumerChoice(*ConsumerChoice) error
	VisitRewardPay(*RewardPay) error
	VisitRewardPayChoice(*RewardPayChoice) error
}

func (p *PricingAgreementUs40ProcessorCard) Accept(visitor PricingAgreementUs40ProcessorCardVisitor) error {
	if p.InterchangePlus != nil {
		return visitor.VisitInterchangePlus(p.InterchangePlus)
	}
	if p.InterchangePlusTiered3 != nil {
		return visitor.VisitInterchangePlusTiered3(p.InterchangePlusTiered3)
	}
	if p.Tiered3 != nil {
		return visitor.VisitTiered3(p.Tiered3)
	}
	if p.Tiered4 != nil {
		return visitor.VisitTiered4(p.Tiered4)
	}
	if p.Tiered6 != nil {
		return visitor.VisitTiered6(p.Tiered6)
	}
	if p.FlatRate != nil {
		return visitor.VisitFlatRate(p.FlatRate)
	}
	if p.ConsumerChoice != nil {
		return visitor.VisitConsumerChoice(p.ConsumerChoice)
	}
	if p.RewardPay != nil {
		return visitor.VisitRewardPay(p.RewardPay)
	}
	if p.RewardPayChoice != nil {
		return visitor.VisitRewardPayChoice(p.RewardPayChoice)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PricingAgreementUs40ProcessorCard) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.InterchangePlus != nil {
		fields = append(fields, "interchangePlus")
	}
	if p.InterchangePlusTiered3 != nil {
		fields = append(fields, "interchangePlusTiered3")
	}
	if p.Tiered3 != nil {
		fields = append(fields, "tiered3")
	}
	if p.Tiered4 != nil {
		fields = append(fields, "tiered4")
	}
	if p.Tiered6 != nil {
		fields = append(fields, "tiered6")
	}
	if p.FlatRate != nil {
		fields = append(fields, "flatRate")
	}
	if p.ConsumerChoice != nil {
		fields = append(fields, "consumerChoice")
	}
	if p.RewardPay != nil {
		fields = append(fields, "rewardPay")
	}
	if p.RewardPayChoice != nil {
		fields = append(fields, "rewardPayChoice")
	}
	if len(fields) == 0 {
		if p.PlanType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.PlanType)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.PlanType != "" {
		field := fields[0]
		if p.PlanType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.PlanType,
				p,
			)
		}
	}
	return nil
}

// Version of the MPA.
type PricingAgreementUs40Version string

const (
	PricingAgreementUs40VersionFour0 PricingAgreementUs40Version = "4.0"
)

func NewPricingAgreementUs40VersionFromString(s string) (PricingAgreementUs40Version, error) {
	switch s {
	case "4.0":
		return PricingAgreementUs40VersionFour0, nil
	}
	var t PricingAgreementUs40Version
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PricingAgreementUs40Version) Ptr() *PricingAgreementUs40Version {
	return &p
}

// Object that contains information about U.S. pricing intents for Merchant Processing Agreement (MPA) 5.0.
var (
	pricingAgreementUs50FieldCountry   = big.NewInt(1 << 0)
	pricingAgreementUs50FieldVersion   = big.NewInt(1 << 1)
	pricingAgreementUs50FieldBase      = big.NewInt(1 << 2)
	pricingAgreementUs50FieldProcessor = big.NewInt(1 << 3)
	pricingAgreementUs50FieldGateway   = big.NewInt(1 << 4)
	pricingAgreementUs50FieldServices  = big.NewInt(1 << 5)
)

type PricingAgreementUs50 struct {
	// Two-digit code for the country that the pricing intent applies to. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
	Country PricingAgreementUs50Country `json:"country" url:"country"`
	// Version of the MPA.
	Version PricingAgreementUs50Version `json:"version" url:"version"`
	Base    *BaseUs                     `json:"base" url:"base"`
	// Object that contains information about U.S. processor fees.
	Processor *PricingAgreementUs50Processor `json:"processor,omitempty" url:"processor,omitempty"`
	Gateway   *GatewayUs50                   `json:"gateway,omitempty" url:"gateway,omitempty"`
	Services  *ServicesUs50                  `json:"services,omitempty" url:"services,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingAgreementUs50) GetCountry() PricingAgreementUs50Country {
	if p == nil {
		return ""
	}
	return p.Country
}

func (p *PricingAgreementUs50) GetVersion() PricingAgreementUs50Version {
	if p == nil {
		return ""
	}
	return p.Version
}

func (p *PricingAgreementUs50) GetBase() *BaseUs {
	if p == nil {
		return nil
	}
	return p.Base
}

func (p *PricingAgreementUs50) GetProcessor() *PricingAgreementUs50Processor {
	if p == nil {
		return nil
	}
	return p.Processor
}

func (p *PricingAgreementUs50) GetGateway() *GatewayUs50 {
	if p == nil {
		return nil
	}
	return p.Gateway
}

func (p *PricingAgreementUs50) GetServices() *ServicesUs50 {
	if p == nil {
		return nil
	}
	return p.Services
}

func (p *PricingAgreementUs50) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingAgreementUs50) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50) SetCountry(country PricingAgreementUs50Country) {
	p.Country = country
	p.require(pricingAgreementUs50FieldCountry)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50) SetVersion(version PricingAgreementUs50Version) {
	p.Version = version
	p.require(pricingAgreementUs50FieldVersion)
}

// SetBase sets the Base field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50) SetBase(base *BaseUs) {
	p.Base = base
	p.require(pricingAgreementUs50FieldBase)
}

// SetProcessor sets the Processor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50) SetProcessor(processor *PricingAgreementUs50Processor) {
	p.Processor = processor
	p.require(pricingAgreementUs50FieldProcessor)
}

// SetGateway sets the Gateway field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50) SetGateway(gateway *GatewayUs50) {
	p.Gateway = gateway
	p.require(pricingAgreementUs50FieldGateway)
}

// SetServices sets the Services field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50) SetServices(services *ServicesUs50) {
	p.Services = services
	p.require(pricingAgreementUs50FieldServices)
}

func (p *PricingAgreementUs50) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingAgreementUs50
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingAgreementUs50(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingAgreementUs50) MarshalJSON() ([]byte, error) {
	type embed PricingAgreementUs50
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingAgreementUs50) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Two-digit code for the country that the pricing intent applies to. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
type PricingAgreementUs50Country string

const (
	PricingAgreementUs50CountryUs PricingAgreementUs50Country = "US"
)

func NewPricingAgreementUs50CountryFromString(s string) (PricingAgreementUs50Country, error) {
	switch s {
	case "US":
		return PricingAgreementUs50CountryUs, nil
	}
	var t PricingAgreementUs50Country
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PricingAgreementUs50Country) Ptr() *PricingAgreementUs50Country {
	return &p
}

// Object that contains information about U.S. processor fees.
var (
	pricingAgreementUs50ProcessorFieldCard = big.NewInt(1 << 0)
	pricingAgreementUs50ProcessorFieldAch  = big.NewInt(1 << 1)
)

type PricingAgreementUs50Processor struct {
	// Polymorphic object that contains fees for card transactions.
	//
	// The value of the planType field determines which variant you should use:
	// -	`interchangePlus` - Interchange + pricing
	// -	`interchangePlusPlus` - Interchange pricing with three tiers
	// -	`tiered3` - Three-tiered pricing
	// -	`tiered4` - Four-tiered pricing
	// -	`tiered6` - Six-tiered pricing
	// -	`flatRate` - Flat rate pricing
	// -	`consumerChoice` - ConsumerChoice
	// -	`rewardPayChoice` - RewardPayChoice
	Card *PricingAgreementUs50ProcessorCard `json:"card,omitempty" url:"card,omitempty"`
	Ach  *Ach                               `json:"ach,omitempty" url:"ach,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingAgreementUs50Processor) GetCard() *PricingAgreementUs50ProcessorCard {
	if p == nil {
		return nil
	}
	return p.Card
}

func (p *PricingAgreementUs50Processor) GetAch() *Ach {
	if p == nil {
		return nil
	}
	return p.Ach
}

func (p *PricingAgreementUs50Processor) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingAgreementUs50Processor) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50Processor) SetCard(card *PricingAgreementUs50ProcessorCard) {
	p.Card = card
	p.require(pricingAgreementUs50ProcessorFieldCard)
}

// SetAch sets the Ach field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingAgreementUs50Processor) SetAch(ach *Ach) {
	p.Ach = ach
	p.require(pricingAgreementUs50ProcessorFieldAch)
}

func (p *PricingAgreementUs50Processor) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingAgreementUs50Processor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingAgreementUs50Processor(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingAgreementUs50Processor) MarshalJSON() ([]byte, error) {
	type embed PricingAgreementUs50Processor
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingAgreementUs50Processor) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Polymorphic object that contains fees for card transactions.
//
// The value of the planType field determines which variant you should use:
// -	`interchangePlus` - Interchange + pricing
// -	`interchangePlusPlus` - Interchange pricing with three tiers
// -	`tiered3` - Three-tiered pricing
// -	`tiered4` - Four-tiered pricing
// -	`tiered6` - Six-tiered pricing
// -	`flatRate` - Flat rate pricing
// -	`consumerChoice` - ConsumerChoice
// -	`rewardPayChoice` - RewardPayChoice
type PricingAgreementUs50ProcessorCard struct {
	PlanType            string
	InterchangePlus     *InterchangePlus
	InterchangePlusPlus *InterchangePlusPlus
	Tiered3             *Tiered3
	Tiered4             *Tiered4
	Tiered6             *Tiered6
	FlatRate            *FlatRate
	ConsumerChoice      *ConsumerChoice
	RewardPayChoice     *RewardPayChoice
}

func (p *PricingAgreementUs50ProcessorCard) GetPlanType() string {
	if p == nil {
		return ""
	}
	return p.PlanType
}

func (p *PricingAgreementUs50ProcessorCard) GetInterchangePlus() *InterchangePlus {
	if p == nil {
		return nil
	}
	return p.InterchangePlus
}

func (p *PricingAgreementUs50ProcessorCard) GetInterchangePlusPlus() *InterchangePlusPlus {
	if p == nil {
		return nil
	}
	return p.InterchangePlusPlus
}

func (p *PricingAgreementUs50ProcessorCard) GetTiered3() *Tiered3 {
	if p == nil {
		return nil
	}
	return p.Tiered3
}

func (p *PricingAgreementUs50ProcessorCard) GetTiered4() *Tiered4 {
	if p == nil {
		return nil
	}
	return p.Tiered4
}

func (p *PricingAgreementUs50ProcessorCard) GetTiered6() *Tiered6 {
	if p == nil {
		return nil
	}
	return p.Tiered6
}

func (p *PricingAgreementUs50ProcessorCard) GetFlatRate() *FlatRate {
	if p == nil {
		return nil
	}
	return p.FlatRate
}

func (p *PricingAgreementUs50ProcessorCard) GetConsumerChoice() *ConsumerChoice {
	if p == nil {
		return nil
	}
	return p.ConsumerChoice
}

func (p *PricingAgreementUs50ProcessorCard) GetRewardPayChoice() *RewardPayChoice {
	if p == nil {
		return nil
	}
	return p.RewardPayChoice
}

func (p *PricingAgreementUs50ProcessorCard) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PlanType string `json:"planType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.PlanType = unmarshaler.PlanType
	if unmarshaler.PlanType == "" {
		return fmt.Errorf("%T did not include discriminant planType", p)
	}
	switch unmarshaler.PlanType {
	case "interchangePlus":
		value := new(InterchangePlus)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.InterchangePlus = value
	case "interchangePlusPlus":
		value := new(InterchangePlusPlus)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.InterchangePlusPlus = value
	case "tiered3":
		value := new(Tiered3)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Tiered3 = value
	case "tiered4":
		value := new(Tiered4)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Tiered4 = value
	case "tiered6":
		value := new(Tiered6)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Tiered6 = value
	case "flatRate":
		value := new(FlatRate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.FlatRate = value
	case "consumerChoice":
		value := new(ConsumerChoice)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.ConsumerChoice = value
	case "rewardPayChoice":
		value := new(RewardPayChoice)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.RewardPayChoice = value
	}
	return nil
}

func (p PricingAgreementUs50ProcessorCard) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.InterchangePlus != nil {
		return internal.MarshalJSONWithExtraProperty(p.InterchangePlus, "planType", "interchangePlus")
	}
	if p.InterchangePlusPlus != nil {
		return internal.MarshalJSONWithExtraProperty(p.InterchangePlusPlus, "planType", "interchangePlusPlus")
	}
	if p.Tiered3 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Tiered3, "planType", "tiered3")
	}
	if p.Tiered4 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Tiered4, "planType", "tiered4")
	}
	if p.Tiered6 != nil {
		return internal.MarshalJSONWithExtraProperty(p.Tiered6, "planType", "tiered6")
	}
	if p.FlatRate != nil {
		return internal.MarshalJSONWithExtraProperty(p.FlatRate, "planType", "flatRate")
	}
	if p.ConsumerChoice != nil {
		return internal.MarshalJSONWithExtraProperty(p.ConsumerChoice, "planType", "consumerChoice")
	}
	if p.RewardPayChoice != nil {
		return internal.MarshalJSONWithExtraProperty(p.RewardPayChoice, "planType", "rewardPayChoice")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PricingAgreementUs50ProcessorCardVisitor interface {
	VisitInterchangePlus(*InterchangePlus) error
	VisitInterchangePlusPlus(*InterchangePlusPlus) error
	VisitTiered3(*Tiered3) error
	VisitTiered4(*Tiered4) error
	VisitTiered6(*Tiered6) error
	VisitFlatRate(*FlatRate) error
	VisitConsumerChoice(*ConsumerChoice) error
	VisitRewardPayChoice(*RewardPayChoice) error
}

func (p *PricingAgreementUs50ProcessorCard) Accept(visitor PricingAgreementUs50ProcessorCardVisitor) error {
	if p.InterchangePlus != nil {
		return visitor.VisitInterchangePlus(p.InterchangePlus)
	}
	if p.InterchangePlusPlus != nil {
		return visitor.VisitInterchangePlusPlus(p.InterchangePlusPlus)
	}
	if p.Tiered3 != nil {
		return visitor.VisitTiered3(p.Tiered3)
	}
	if p.Tiered4 != nil {
		return visitor.VisitTiered4(p.Tiered4)
	}
	if p.Tiered6 != nil {
		return visitor.VisitTiered6(p.Tiered6)
	}
	if p.FlatRate != nil {
		return visitor.VisitFlatRate(p.FlatRate)
	}
	if p.ConsumerChoice != nil {
		return visitor.VisitConsumerChoice(p.ConsumerChoice)
	}
	if p.RewardPayChoice != nil {
		return visitor.VisitRewardPayChoice(p.RewardPayChoice)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *PricingAgreementUs50ProcessorCard) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.InterchangePlus != nil {
		fields = append(fields, "interchangePlus")
	}
	if p.InterchangePlusPlus != nil {
		fields = append(fields, "interchangePlusPlus")
	}
	if p.Tiered3 != nil {
		fields = append(fields, "tiered3")
	}
	if p.Tiered4 != nil {
		fields = append(fields, "tiered4")
	}
	if p.Tiered6 != nil {
		fields = append(fields, "tiered6")
	}
	if p.FlatRate != nil {
		fields = append(fields, "flatRate")
	}
	if p.ConsumerChoice != nil {
		fields = append(fields, "consumerChoice")
	}
	if p.RewardPayChoice != nil {
		fields = append(fields, "rewardPayChoice")
	}
	if len(fields) == 0 {
		if p.PlanType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.PlanType)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.PlanType != "" {
		field := fields[0]
		if p.PlanType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.PlanType,
				p,
			)
		}
	}
	return nil
}

// Version of the MPA.
type PricingAgreementUs50Version string

const (
	PricingAgreementUs50VersionFive0 PricingAgreementUs50Version = "5.0"
)

func NewPricingAgreementUs50VersionFromString(s string) (PricingAgreementUs50Version, error) {
	switch s {
	case "5.0":
		return PricingAgreementUs50VersionFive0, nil
	}
	var t PricingAgreementUs50Version
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PricingAgreementUs50Version) Ptr() *PricingAgreementUs50Version {
	return &p
}

// Polymorphic object that contains pricing intent information.
type PricingIntent = *PricingIntent50

// Object that contains information about a pricing intent for Merchant Processing Agreement (MPA) 5.0.
var (
	pricingIntent50FieldId              = big.NewInt(1 << 0)
	pricingIntent50FieldCreatedDate     = big.NewInt(1 << 1)
	pricingIntent50FieldLastUpdatedDate = big.NewInt(1 << 2)
	pricingIntent50FieldStatus          = big.NewInt(1 << 3)
	pricingIntent50FieldKey             = big.NewInt(1 << 4)
	pricingIntent50FieldMetadata        = big.NewInt(1 << 5)
	pricingIntent50FieldCountry         = big.NewInt(1 << 6)
	pricingIntent50FieldVersion         = big.NewInt(1 << 7)
	pricingIntent50FieldBase            = big.NewInt(1 << 8)
	pricingIntent50FieldProcessor       = big.NewInt(1 << 9)
	pricingIntent50FieldGateway         = big.NewInt(1 << 10)
	pricingIntent50FieldServices        = big.NewInt(1 << 11)
)

type PricingIntent50 struct {
	// Unique identifier of the pricing intent.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Date and time that we received your request to create the pricing intent. We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date and time that the pricing intent was last modified. We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	LastUpdatedDate *time.Time `json:"lastUpdatedDate,omitempty" url:"lastUpdatedDate,omitempty"`
	// Status of the pricing intent. The value can be one of the following:
	// - `active` - We have approved the pricing intent.
	// - `pendingReview` - We have not yet reviewed the pricing intent.
	// - `rejected` - We have rejected the pricing intent.
	Status *BaseIntentStatus `json:"status,omitempty" url:"status,omitempty"`
	// Unique identifier that you can assign to the pricing intent for your own records.
	Key string `json:"key" url:"key"`
	// [Metadata](https://docs.payroc.com/api/metadata) object that contains your custom data.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Two-digit code for the country that the pricing intent applies to. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
	Country PricingAgreementUs50Country `json:"country" url:"country"`
	// Version of the MPA.
	Version PricingAgreementUs50Version `json:"version" url:"version"`
	Base    *BaseUs                     `json:"base" url:"base"`
	// Object that contains information about U.S. processor fees.
	Processor *PricingAgreementUs50Processor `json:"processor,omitempty" url:"processor,omitempty"`
	Gateway   *GatewayUs50                   `json:"gateway,omitempty" url:"gateway,omitempty"`
	Services  *ServicesUs50                  `json:"services,omitempty" url:"services,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingIntent50) GetId() *string {
	if p == nil {
		return nil
	}
	return p.Id
}

func (p *PricingIntent50) GetCreatedDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedDate
}

func (p *PricingIntent50) GetLastUpdatedDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.LastUpdatedDate
}

func (p *PricingIntent50) GetStatus() *BaseIntentStatus {
	if p == nil {
		return nil
	}
	return p.Status
}

func (p *PricingIntent50) GetKey() string {
	if p == nil {
		return ""
	}
	return p.Key
}

func (p *PricingIntent50) GetMetadata() map[string]string {
	if p == nil {
		return nil
	}
	return p.Metadata
}

func (p *PricingIntent50) GetCountry() PricingAgreementUs50Country {
	if p == nil {
		return ""
	}
	return p.Country
}

func (p *PricingIntent50) GetVersion() PricingAgreementUs50Version {
	if p == nil {
		return ""
	}
	return p.Version
}

func (p *PricingIntent50) GetBase() *BaseUs {
	if p == nil {
		return nil
	}
	return p.Base
}

func (p *PricingIntent50) GetProcessor() *PricingAgreementUs50Processor {
	if p == nil {
		return nil
	}
	return p.Processor
}

func (p *PricingIntent50) GetGateway() *GatewayUs50 {
	if p == nil {
		return nil
	}
	return p.Gateway
}

func (p *PricingIntent50) GetServices() *ServicesUs50 {
	if p == nil {
		return nil
	}
	return p.Services
}

func (p *PricingIntent50) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingIntent50) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetId(id *string) {
	p.Id = id
	p.require(pricingIntent50FieldId)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetCreatedDate(createdDate *time.Time) {
	p.CreatedDate = createdDate
	p.require(pricingIntent50FieldCreatedDate)
}

// SetLastUpdatedDate sets the LastUpdatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetLastUpdatedDate(lastUpdatedDate *time.Time) {
	p.LastUpdatedDate = lastUpdatedDate
	p.require(pricingIntent50FieldLastUpdatedDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetStatus(status *BaseIntentStatus) {
	p.Status = status
	p.require(pricingIntent50FieldStatus)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetKey(key string) {
	p.Key = key
	p.require(pricingIntent50FieldKey)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetMetadata(metadata map[string]string) {
	p.Metadata = metadata
	p.require(pricingIntent50FieldMetadata)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetCountry(country PricingAgreementUs50Country) {
	p.Country = country
	p.require(pricingIntent50FieldCountry)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetVersion(version PricingAgreementUs50Version) {
	p.Version = version
	p.require(pricingIntent50FieldVersion)
}

// SetBase sets the Base field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetBase(base *BaseUs) {
	p.Base = base
	p.require(pricingIntent50FieldBase)
}

// SetProcessor sets the Processor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetProcessor(processor *PricingAgreementUs50Processor) {
	p.Processor = processor
	p.require(pricingIntent50FieldProcessor)
}

// SetGateway sets the Gateway field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetGateway(gateway *GatewayUs50) {
	p.Gateway = gateway
	p.require(pricingIntent50FieldGateway)
}

// SetServices sets the Services field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingIntent50) SetServices(services *ServicesUs50) {
	p.Services = services
	p.require(pricingIntent50FieldServices)
}

func (p *PricingIntent50) UnmarshalJSON(data []byte) error {
	type embed PricingIntent50
	var unmarshaler = struct {
		embed
		CreatedDate     *internal.DateTime `json:"createdDate,omitempty"`
		LastUpdatedDate *internal.DateTime `json:"lastUpdatedDate,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PricingIntent50(unmarshaler.embed)
	p.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	p.LastUpdatedDate = unmarshaler.LastUpdatedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingIntent50) MarshalJSON() ([]byte, error) {
	type embed PricingIntent50
	var marshaler = struct {
		embed
		CreatedDate     *internal.DateTime `json:"createdDate,omitempty"`
		LastUpdatedDate *internal.DateTime `json:"lastUpdatedDate,omitempty"`
	}{
		embed:           embed(*p),
		CreatedDate:     internal.NewOptionalDateTime(p.CreatedDate),
		LastUpdatedDate: internal.NewOptionalDateTime(p.LastUpdatedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingIntent50) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	pricingTemplateFieldPricingIntentId = big.NewInt(1 << 0)
)

type PricingTemplate struct {
	// Unique identifier of the pricing intent.
	PricingIntentId string `json:"pricingIntentId" url:"pricingIntentId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingTemplate) GetPricingIntentId() string {
	if p == nil {
		return ""
	}
	return p.PricingIntentId
}

func (p *PricingTemplate) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingTemplate) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPricingIntentId sets the PricingIntentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTemplate) SetPricingIntentId(pricingIntentId string) {
	p.PricingIntentId = pricingIntentId
	p.require(pricingTemplateFieldPricingIntentId)
}

func (p *PricingTemplate) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingTemplate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingTemplate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingTemplate) MarshalJSON() ([]byte, error) {
	type embed PricingTemplate
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingTemplate) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about how we process transactions for the account.
var (
	processingFieldMerchantId         = big.NewInt(1 << 0)
	processingFieldTransactionAmounts = big.NewInt(1 << 1)
	processingFieldMonthlyAmounts     = big.NewInt(1 << 2)
	processingFieldVolumeBreakdown    = big.NewInt(1 << 3)
	processingFieldIsSeasonal         = big.NewInt(1 << 4)
	processingFieldMonthsOfOperation  = big.NewInt(1 << 5)
	processingFieldAch                = big.NewInt(1 << 6)
	processingFieldCardAcceptance     = big.NewInt(1 << 7)
)

type Processing struct {
	// Unique identifier that the acquiring platform assigns to the merchant.
	MerchantId *string `json:"merchantId,omitempty" url:"merchantId,omitempty"`
	// Object that contains information about transaction amounts for the processing account.
	TransactionAmounts *ProcessingTransactionAmounts `json:"transactionAmounts" url:"transactionAmounts"`
	// Object that contains information about the monthly processing amounts for the processing account.
	MonthlyAmounts *ProcessingMonthlyAmounts `json:"monthlyAmounts" url:"monthlyAmounts"`
	// Object that contains information about the types of transactions ran by the processing account. The percentages for transaction types must total 100%.
	VolumeBreakdown *ProcessingVolumeBreakdown `json:"volumeBreakdown" url:"volumeBreakdown"`
	// Indicates if the processing account runs transactions on a seasonal basis. For example, if the processing account runs transactions during only the winter months, send a value of `true`.
	IsSeasonal *bool `json:"isSeasonal,omitempty" url:"isSeasonal,omitempty"`
	// Months of the year that the processing account runs transactions.
	MonthsOfOperation []ProcessingMonthsOfOperationItem `json:"monthsOfOperation,omitempty" url:"monthsOfOperation,omitempty"`
	// Object that contains information about Automated Clearing House (ACH) transactions.
	Ach *ProcessingAch `json:"ach,omitempty" url:"ach,omitempty"`
	// Object that contains information about the types of cards that the processing account accepts.
	CardAcceptance *ProcessingCardAcceptance `json:"cardAcceptance,omitempty" url:"cardAcceptance,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Processing) GetMerchantId() *string {
	if p == nil {
		return nil
	}
	return p.MerchantId
}

func (p *Processing) GetTransactionAmounts() *ProcessingTransactionAmounts {
	if p == nil {
		return nil
	}
	return p.TransactionAmounts
}

func (p *Processing) GetMonthlyAmounts() *ProcessingMonthlyAmounts {
	if p == nil {
		return nil
	}
	return p.MonthlyAmounts
}

func (p *Processing) GetVolumeBreakdown() *ProcessingVolumeBreakdown {
	if p == nil {
		return nil
	}
	return p.VolumeBreakdown
}

func (p *Processing) GetIsSeasonal() *bool {
	if p == nil {
		return nil
	}
	return p.IsSeasonal
}

func (p *Processing) GetMonthsOfOperation() []ProcessingMonthsOfOperationItem {
	if p == nil {
		return nil
	}
	return p.MonthsOfOperation
}

func (p *Processing) GetAch() *ProcessingAch {
	if p == nil {
		return nil
	}
	return p.Ach
}

func (p *Processing) GetCardAcceptance() *ProcessingCardAcceptance {
	if p == nil {
		return nil
	}
	return p.CardAcceptance
}

func (p *Processing) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Processing) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetMerchantId sets the MerchantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetMerchantId(merchantId *string) {
	p.MerchantId = merchantId
	p.require(processingFieldMerchantId)
}

// SetTransactionAmounts sets the TransactionAmounts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetTransactionAmounts(transactionAmounts *ProcessingTransactionAmounts) {
	p.TransactionAmounts = transactionAmounts
	p.require(processingFieldTransactionAmounts)
}

// SetMonthlyAmounts sets the MonthlyAmounts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetMonthlyAmounts(monthlyAmounts *ProcessingMonthlyAmounts) {
	p.MonthlyAmounts = monthlyAmounts
	p.require(processingFieldMonthlyAmounts)
}

// SetVolumeBreakdown sets the VolumeBreakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetVolumeBreakdown(volumeBreakdown *ProcessingVolumeBreakdown) {
	p.VolumeBreakdown = volumeBreakdown
	p.require(processingFieldVolumeBreakdown)
}

// SetIsSeasonal sets the IsSeasonal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetIsSeasonal(isSeasonal *bool) {
	p.IsSeasonal = isSeasonal
	p.require(processingFieldIsSeasonal)
}

// SetMonthsOfOperation sets the MonthsOfOperation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetMonthsOfOperation(monthsOfOperation []ProcessingMonthsOfOperationItem) {
	p.MonthsOfOperation = monthsOfOperation
	p.require(processingFieldMonthsOfOperation)
}

// SetAch sets the Ach field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetAch(ach *ProcessingAch) {
	p.Ach = ach
	p.require(processingFieldAch)
}

// SetCardAcceptance sets the CardAcceptance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Processing) SetCardAcceptance(cardAcceptance *ProcessingCardAcceptance) {
	p.CardAcceptance = cardAcceptance
	p.require(processingFieldCardAcceptance)
}

func (p *Processing) UnmarshalJSON(data []byte) error {
	type unmarshaler Processing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Processing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Processing) MarshalJSON() ([]byte, error) {
	type embed Processing
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Processing) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	processingAccountFieldProcessingAccountId      = big.NewInt(1 << 0)
	processingAccountFieldCreatedDate              = big.NewInt(1 << 1)
	processingAccountFieldLastModifiedDate         = big.NewInt(1 << 2)
	processingAccountFieldStatus                   = big.NewInt(1 << 3)
	processingAccountFieldDoingBusinessAs          = big.NewInt(1 << 4)
	processingAccountFieldOwners                   = big.NewInt(1 << 5)
	processingAccountFieldWebsite                  = big.NewInt(1 << 6)
	processingAccountFieldBusinessType             = big.NewInt(1 << 7)
	processingAccountFieldCategoryCode             = big.NewInt(1 << 8)
	processingAccountFieldMerchandiseOrServiceSold = big.NewInt(1 << 9)
	processingAccountFieldBusinessStartDate        = big.NewInt(1 << 10)
	processingAccountFieldTimezone                 = big.NewInt(1 << 11)
	processingAccountFieldAddress                  = big.NewInt(1 << 12)
	processingAccountFieldContactMethods           = big.NewInt(1 << 13)
	processingAccountFieldProcessing               = big.NewInt(1 << 14)
	processingAccountFieldFunding                  = big.NewInt(1 << 15)
	processingAccountFieldPricing                  = big.NewInt(1 << 16)
	processingAccountFieldContacts                 = big.NewInt(1 << 17)
	processingAccountFieldSignature                = big.NewInt(1 << 18)
	processingAccountFieldMetadata                 = big.NewInt(1 << 19)
	processingAccountFieldLinks                    = big.NewInt(1 << 20)
)

type ProcessingAccount struct {
	// Unique identifier of the processing account.
	ProcessingAccountId *string `json:"processingAccountId,omitempty" url:"processingAccountId,omitempty"`
	// Date and time that we received your request to create the processing account in our system.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date and time that the processing account was last modified.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	// Status of the processing account.
	// - `entered` - We have received information about the account, but we have not yet reviewed it.
	// - `pending` - We have reviewed the information about the account, but we have not yet approved it.
	// - `approved` - We have approved the account for processing transactions and funding.
	// - `subjectTo` - We have approved the account, but we are waiting on further information.
	// - `dormant` - Account is closed for a period.
	// - `nonProcessing` - We have approved the account, but the merchant has not yet run a transaction.
	// - `rejected` - We rejected the application for the processing account.
	// - `terminated` - Processing account is closed.
	// - `cancelled` - Merchant withdrew the application for the processing account.
	// **Note**: You can subscribe to our processingAccount.status.changed event to get notifications when we change the status of a processing account. For more information about how to subscribe to events, go to [Event Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).
	Status *ProcessingAccountStatus `json:"status,omitempty" url:"status,omitempty"`
	// Trading name of the business.
	DoingBusinessAs string `json:"doingBusinessAs" url:"doingBusinessAs"`
	// Object that contains information about the owners of the business.
	Owners []*ProcessingAccountOwnersItem `json:"owners,omitempty" url:"owners,omitempty"`
	// Website address of the business.
	Website *string `json:"website,omitempty" url:"website,omitempty"`
	// Type of business.
	BusinessType ProcessingAccountBusinessType `json:"businessType" url:"businessType"`
	// Merchant Category Code (MCC) for the type of business.
	CategoryCode int `json:"categoryCode" url:"categoryCode"`
	// Description of the services or merchandise sold by the business.
	MerchandiseOrServiceSold string `json:"merchandiseOrServiceSold" url:"merchandiseOrServiceSold"`
	// Date that the business was established. The format of the value is **YYYY-MM-DD**.
	BusinessStartDate *time.Time `json:"businessStartDate,omitempty" url:"businessStartDate,omitempty" format:"date"`
	Timezone          Timezone   `json:"timezone" url:"timezone"`
	// Polymorphic object that contains address information for the processing account.
	Address *Address `json:"address" url:"address"`
	// Array of polymorphic objects, which contain contact information.
	//
	// **Note:** You must provide an email address.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods" url:"contactMethods"`
	Processing     *Processing      `json:"processing" url:"processing"`
	Funding        *Funding         `json:"funding" url:"funding"`
	// Object that HATEOAS links to the pricing information that we apply to the processing account.
	Pricing *ProcessingAccountPricing `json:"pricing" url:"pricing"`
	// Array of contact objects.
	Contacts  []*ProcessingAccountContactsItem `json:"contacts,omitempty" url:"contacts,omitempty"`
	Signature *Signature                       `json:"signature" url:"signature"`
	// Object that you can send to include custom data in the request. For more information about how to use metadata, go to [Metadata](https://docs.payroc.com/api/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Array of useful links related to your request.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAccount) GetProcessingAccountId() *string {
	if p == nil {
		return nil
	}
	return p.ProcessingAccountId
}

func (p *ProcessingAccount) GetCreatedDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreatedDate
}

func (p *ProcessingAccount) GetLastModifiedDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.LastModifiedDate
}

func (p *ProcessingAccount) GetStatus() *ProcessingAccountStatus {
	if p == nil {
		return nil
	}
	return p.Status
}

func (p *ProcessingAccount) GetDoingBusinessAs() string {
	if p == nil {
		return ""
	}
	return p.DoingBusinessAs
}

func (p *ProcessingAccount) GetOwners() []*ProcessingAccountOwnersItem {
	if p == nil {
		return nil
	}
	return p.Owners
}

func (p *ProcessingAccount) GetWebsite() *string {
	if p == nil {
		return nil
	}
	return p.Website
}

func (p *ProcessingAccount) GetBusinessType() ProcessingAccountBusinessType {
	if p == nil {
		return ""
	}
	return p.BusinessType
}

func (p *ProcessingAccount) GetCategoryCode() int {
	if p == nil {
		return 0
	}
	return p.CategoryCode
}

func (p *ProcessingAccount) GetMerchandiseOrServiceSold() string {
	if p == nil {
		return ""
	}
	return p.MerchandiseOrServiceSold
}

func (p *ProcessingAccount) GetBusinessStartDate() *time.Time {
	if p == nil {
		return nil
	}
	return p.BusinessStartDate
}

func (p *ProcessingAccount) GetTimezone() Timezone {
	if p == nil {
		return ""
	}
	return p.Timezone
}

func (p *ProcessingAccount) GetAddress() *Address {
	if p == nil {
		return nil
	}
	return p.Address
}

func (p *ProcessingAccount) GetContactMethods() []*ContactMethod {
	if p == nil {
		return nil
	}
	return p.ContactMethods
}

func (p *ProcessingAccount) GetProcessing() *Processing {
	if p == nil {
		return nil
	}
	return p.Processing
}

func (p *ProcessingAccount) GetFunding() *Funding {
	if p == nil {
		return nil
	}
	return p.Funding
}

func (p *ProcessingAccount) GetPricing() *ProcessingAccountPricing {
	if p == nil {
		return nil
	}
	return p.Pricing
}

func (p *ProcessingAccount) GetContacts() []*ProcessingAccountContactsItem {
	if p == nil {
		return nil
	}
	return p.Contacts
}

func (p *ProcessingAccount) GetSignature() *Signature {
	if p == nil {
		return nil
	}
	return p.Signature
}

func (p *ProcessingAccount) GetMetadata() map[string]string {
	if p == nil {
		return nil
	}
	return p.Metadata
}

func (p *ProcessingAccount) GetLinks() []*Link {
	if p == nil {
		return nil
	}
	return p.Links
}

func (p *ProcessingAccount) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAccount) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetProcessingAccountId sets the ProcessingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetProcessingAccountId(processingAccountId *string) {
	p.ProcessingAccountId = processingAccountId
	p.require(processingAccountFieldProcessingAccountId)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetCreatedDate(createdDate *time.Time) {
	p.CreatedDate = createdDate
	p.require(processingAccountFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetLastModifiedDate(lastModifiedDate *time.Time) {
	p.LastModifiedDate = lastModifiedDate
	p.require(processingAccountFieldLastModifiedDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetStatus(status *ProcessingAccountStatus) {
	p.Status = status
	p.require(processingAccountFieldStatus)
}

// SetDoingBusinessAs sets the DoingBusinessAs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetDoingBusinessAs(doingBusinessAs string) {
	p.DoingBusinessAs = doingBusinessAs
	p.require(processingAccountFieldDoingBusinessAs)
}

// SetOwners sets the Owners field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetOwners(owners []*ProcessingAccountOwnersItem) {
	p.Owners = owners
	p.require(processingAccountFieldOwners)
}

// SetWebsite sets the Website field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetWebsite(website *string) {
	p.Website = website
	p.require(processingAccountFieldWebsite)
}

// SetBusinessType sets the BusinessType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetBusinessType(businessType ProcessingAccountBusinessType) {
	p.BusinessType = businessType
	p.require(processingAccountFieldBusinessType)
}

// SetCategoryCode sets the CategoryCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetCategoryCode(categoryCode int) {
	p.CategoryCode = categoryCode
	p.require(processingAccountFieldCategoryCode)
}

// SetMerchandiseOrServiceSold sets the MerchandiseOrServiceSold field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetMerchandiseOrServiceSold(merchandiseOrServiceSold string) {
	p.MerchandiseOrServiceSold = merchandiseOrServiceSold
	p.require(processingAccountFieldMerchandiseOrServiceSold)
}

// SetBusinessStartDate sets the BusinessStartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetBusinessStartDate(businessStartDate *time.Time) {
	p.BusinessStartDate = businessStartDate
	p.require(processingAccountFieldBusinessStartDate)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetTimezone(timezone Timezone) {
	p.Timezone = timezone
	p.require(processingAccountFieldTimezone)
}

// SetAddress sets the Address field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetAddress(address *Address) {
	p.Address = address
	p.require(processingAccountFieldAddress)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetContactMethods(contactMethods []*ContactMethod) {
	p.ContactMethods = contactMethods
	p.require(processingAccountFieldContactMethods)
}

// SetProcessing sets the Processing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetProcessing(processing *Processing) {
	p.Processing = processing
	p.require(processingAccountFieldProcessing)
}

// SetFunding sets the Funding field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetFunding(funding *Funding) {
	p.Funding = funding
	p.require(processingAccountFieldFunding)
}

// SetPricing sets the Pricing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetPricing(pricing *ProcessingAccountPricing) {
	p.Pricing = pricing
	p.require(processingAccountFieldPricing)
}

// SetContacts sets the Contacts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetContacts(contacts []*ProcessingAccountContactsItem) {
	p.Contacts = contacts
	p.require(processingAccountFieldContacts)
}

// SetSignature sets the Signature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetSignature(signature *Signature) {
	p.Signature = signature
	p.require(processingAccountFieldSignature)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetMetadata(metadata map[string]string) {
	p.Metadata = metadata
	p.require(processingAccountFieldMetadata)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccount) SetLinks(links []*Link) {
	p.Links = links
	p.require(processingAccountFieldLinks)
}

func (p *ProcessingAccount) UnmarshalJSON(data []byte) error {
	type embed ProcessingAccount
	var unmarshaler = struct {
		embed
		CreatedDate       *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate  *internal.DateTime `json:"lastModifiedDate,omitempty"`
		BusinessStartDate *internal.Date     `json:"businessStartDate,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = ProcessingAccount(unmarshaler.embed)
	p.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	p.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	p.BusinessStartDate = unmarshaler.BusinessStartDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAccount) MarshalJSON() ([]byte, error) {
	type embed ProcessingAccount
	var marshaler = struct {
		embed
		CreatedDate       *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate  *internal.DateTime `json:"lastModifiedDate,omitempty"`
		BusinessStartDate *internal.Date     `json:"businessStartDate,omitempty"`
	}{
		embed:             embed(*p),
		CreatedDate:       internal.NewOptionalDateTime(p.CreatedDate),
		LastModifiedDate:  internal.NewOptionalDateTime(p.LastModifiedDate),
		BusinessStartDate: internal.NewOptionalDate(p.BusinessStartDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAccount) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Type of business.
type ProcessingAccountBusinessType string

const (
	ProcessingAccountBusinessTypeRetail       ProcessingAccountBusinessType = "retail"
	ProcessingAccountBusinessTypeRestaurant   ProcessingAccountBusinessType = "restaurant"
	ProcessingAccountBusinessTypeInternet     ProcessingAccountBusinessType = "internet"
	ProcessingAccountBusinessTypeMoto         ProcessingAccountBusinessType = "moto"
	ProcessingAccountBusinessTypeLodging      ProcessingAccountBusinessType = "lodging"
	ProcessingAccountBusinessTypeNotForProfit ProcessingAccountBusinessType = "notForProfit"
)

func NewProcessingAccountBusinessTypeFromString(s string) (ProcessingAccountBusinessType, error) {
	switch s {
	case "retail":
		return ProcessingAccountBusinessTypeRetail, nil
	case "restaurant":
		return ProcessingAccountBusinessTypeRestaurant, nil
	case "internet":
		return ProcessingAccountBusinessTypeInternet, nil
	case "moto":
		return ProcessingAccountBusinessTypeMoto, nil
	case "lodging":
		return ProcessingAccountBusinessTypeLodging, nil
	case "notForProfit":
		return ProcessingAccountBusinessTypeNotForProfit, nil
	}
	var t ProcessingAccountBusinessType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingAccountBusinessType) Ptr() *ProcessingAccountBusinessType {
	return &p
}

var (
	processingAccountContactsItemFieldContactId = big.NewInt(1 << 0)
	processingAccountContactsItemFieldFirstName = big.NewInt(1 << 1)
	processingAccountContactsItemFieldLastName  = big.NewInt(1 << 2)
	processingAccountContactsItemFieldLink      = big.NewInt(1 << 3)
)

type ProcessingAccountContactsItem struct {
	// Unique identifier of the contact.
	ContactId *int `json:"contactId,omitempty" url:"contactId,omitempty"`
	// Contact's first name.
	FirstName *string `json:"firstName,omitempty" url:"firstName,omitempty"`
	// Contact's last name.
	LastName *string `json:"lastName,omitempty" url:"lastName,omitempty"`
	// Object that contains HATEOAS links for the contact.
	Link *ProcessingAccountContactsItemLink `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAccountContactsItem) GetContactId() *int {
	if p == nil {
		return nil
	}
	return p.ContactId
}

func (p *ProcessingAccountContactsItem) GetFirstName() *string {
	if p == nil {
		return nil
	}
	return p.FirstName
}

func (p *ProcessingAccountContactsItem) GetLastName() *string {
	if p == nil {
		return nil
	}
	return p.LastName
}

func (p *ProcessingAccountContactsItem) GetLink() *ProcessingAccountContactsItemLink {
	if p == nil {
		return nil
	}
	return p.Link
}

func (p *ProcessingAccountContactsItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAccountContactsItem) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetContactId sets the ContactId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountContactsItem) SetContactId(contactId *int) {
	p.ContactId = contactId
	p.require(processingAccountContactsItemFieldContactId)
}

// SetFirstName sets the FirstName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountContactsItem) SetFirstName(firstName *string) {
	p.FirstName = firstName
	p.require(processingAccountContactsItemFieldFirstName)
}

// SetLastName sets the LastName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountContactsItem) SetLastName(lastName *string) {
	p.LastName = lastName
	p.require(processingAccountContactsItemFieldLastName)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountContactsItem) SetLink(link *ProcessingAccountContactsItemLink) {
	p.Link = link
	p.require(processingAccountContactsItemFieldLink)
}

func (p *ProcessingAccountContactsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAccountContactsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAccountContactsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAccountContactsItem) MarshalJSON() ([]byte, error) {
	type embed ProcessingAccountContactsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAccountContactsItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains HATEOAS links for the contact.
var (
	processingAccountContactsItemLinkFieldRel    = big.NewInt(1 << 0)
	processingAccountContactsItemLinkFieldHref   = big.NewInt(1 << 1)
	processingAccountContactsItemLinkFieldMethod = big.NewInt(1 << 2)
)

type ProcessingAccountContactsItemLink struct {
	// Relationship to the parent resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// Link to the resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`
	// HTTP method you can use to retrieve the resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAccountContactsItemLink) GetRel() *string {
	if p == nil {
		return nil
	}
	return p.Rel
}

func (p *ProcessingAccountContactsItemLink) GetHref() *string {
	if p == nil {
		return nil
	}
	return p.Href
}

func (p *ProcessingAccountContactsItemLink) GetMethod() *string {
	if p == nil {
		return nil
	}
	return p.Method
}

func (p *ProcessingAccountContactsItemLink) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAccountContactsItemLink) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountContactsItemLink) SetRel(rel *string) {
	p.Rel = rel
	p.require(processingAccountContactsItemLinkFieldRel)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountContactsItemLink) SetHref(href *string) {
	p.Href = href
	p.require(processingAccountContactsItemLinkFieldHref)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountContactsItemLink) SetMethod(method *string) {
	p.Method = method
	p.require(processingAccountContactsItemLinkFieldMethod)
}

func (p *ProcessingAccountContactsItemLink) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAccountContactsItemLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAccountContactsItemLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAccountContactsItemLink) MarshalJSON() ([]byte, error) {
	type embed ProcessingAccountContactsItemLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAccountContactsItemLink) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	processingAccountOwnersItemFieldOwnerId   = big.NewInt(1 << 0)
	processingAccountOwnersItemFieldFirstName = big.NewInt(1 << 1)
	processingAccountOwnersItemFieldLastName  = big.NewInt(1 << 2)
	processingAccountOwnersItemFieldLink      = big.NewInt(1 << 3)
)

type ProcessingAccountOwnersItem struct {
	// Unique identifier of the owner.
	OwnerId *int `json:"ownerId,omitempty" url:"ownerId,omitempty"`
	// Owner's first name.
	FirstName *string `json:"firstName,omitempty" url:"firstName,omitempty"`
	// Owner's last name.
	LastName *string `json:"lastName,omitempty" url:"lastName,omitempty"`
	// HATEOAS links to the owners of the processing account.
	Link *ProcessingAccountOwnersItemLink `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAccountOwnersItem) GetOwnerId() *int {
	if p == nil {
		return nil
	}
	return p.OwnerId
}

func (p *ProcessingAccountOwnersItem) GetFirstName() *string {
	if p == nil {
		return nil
	}
	return p.FirstName
}

func (p *ProcessingAccountOwnersItem) GetLastName() *string {
	if p == nil {
		return nil
	}
	return p.LastName
}

func (p *ProcessingAccountOwnersItem) GetLink() *ProcessingAccountOwnersItemLink {
	if p == nil {
		return nil
	}
	return p.Link
}

func (p *ProcessingAccountOwnersItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAccountOwnersItem) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOwnerId sets the OwnerId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountOwnersItem) SetOwnerId(ownerId *int) {
	p.OwnerId = ownerId
	p.require(processingAccountOwnersItemFieldOwnerId)
}

// SetFirstName sets the FirstName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountOwnersItem) SetFirstName(firstName *string) {
	p.FirstName = firstName
	p.require(processingAccountOwnersItemFieldFirstName)
}

// SetLastName sets the LastName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountOwnersItem) SetLastName(lastName *string) {
	p.LastName = lastName
	p.require(processingAccountOwnersItemFieldLastName)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountOwnersItem) SetLink(link *ProcessingAccountOwnersItemLink) {
	p.Link = link
	p.require(processingAccountOwnersItemFieldLink)
}

func (p *ProcessingAccountOwnersItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAccountOwnersItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAccountOwnersItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAccountOwnersItem) MarshalJSON() ([]byte, error) {
	type embed ProcessingAccountOwnersItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAccountOwnersItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// HATEOAS links to the owners of the processing account.
var (
	processingAccountOwnersItemLinkFieldRel    = big.NewInt(1 << 0)
	processingAccountOwnersItemLinkFieldHref   = big.NewInt(1 << 1)
	processingAccountOwnersItemLinkFieldMethod = big.NewInt(1 << 2)
)

type ProcessingAccountOwnersItemLink struct {
	// Indicates the relationship between the current resource and the target resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// URL of the target resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`
	// HTTP method that you need to use with the target resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAccountOwnersItemLink) GetRel() *string {
	if p == nil {
		return nil
	}
	return p.Rel
}

func (p *ProcessingAccountOwnersItemLink) GetHref() *string {
	if p == nil {
		return nil
	}
	return p.Href
}

func (p *ProcessingAccountOwnersItemLink) GetMethod() *string {
	if p == nil {
		return nil
	}
	return p.Method
}

func (p *ProcessingAccountOwnersItemLink) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAccountOwnersItemLink) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountOwnersItemLink) SetRel(rel *string) {
	p.Rel = rel
	p.require(processingAccountOwnersItemLinkFieldRel)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountOwnersItemLink) SetHref(href *string) {
	p.Href = href
	p.require(processingAccountOwnersItemLinkFieldHref)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountOwnersItemLink) SetMethod(method *string) {
	p.Method = method
	p.require(processingAccountOwnersItemLinkFieldMethod)
}

func (p *ProcessingAccountOwnersItemLink) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAccountOwnersItemLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAccountOwnersItemLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAccountOwnersItemLink) MarshalJSON() ([]byte, error) {
	type embed ProcessingAccountOwnersItemLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAccountOwnersItemLink) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that HATEOAS links to the pricing information that we apply to the processing account.
var (
	processingAccountPricingFieldLink = big.NewInt(1 << 0)
)

type ProcessingAccountPricing struct {
	// Object that contains HATEOAS links to the pricing information for the processing account.
	Link *ProcessingAccountPricingLink `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAccountPricing) GetLink() *ProcessingAccountPricingLink {
	if p == nil {
		return nil
	}
	return p.Link
}

func (p *ProcessingAccountPricing) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAccountPricing) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountPricing) SetLink(link *ProcessingAccountPricingLink) {
	p.Link = link
	p.require(processingAccountPricingFieldLink)
}

func (p *ProcessingAccountPricing) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAccountPricing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAccountPricing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAccountPricing) MarshalJSON() ([]byte, error) {
	type embed ProcessingAccountPricing
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAccountPricing) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains HATEOAS links to the pricing information for the processing account.
var (
	processingAccountPricingLinkFieldRel    = big.NewInt(1 << 0)
	processingAccountPricingLinkFieldHref   = big.NewInt(1 << 1)
	processingAccountPricingLinkFieldMethod = big.NewInt(1 << 2)
)

type ProcessingAccountPricingLink struct {
	// Indicates the relationship between the current resource and the target resource.
	Rel *string `json:"rel,omitempty" url:"rel,omitempty"`
	// URL of the target resource.
	Href *string `json:"href,omitempty" url:"href,omitempty"`
	// HTTP method that you need to use with the target resource.
	Method *string `json:"method,omitempty" url:"method,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAccountPricingLink) GetRel() *string {
	if p == nil {
		return nil
	}
	return p.Rel
}

func (p *ProcessingAccountPricingLink) GetHref() *string {
	if p == nil {
		return nil
	}
	return p.Href
}

func (p *ProcessingAccountPricingLink) GetMethod() *string {
	if p == nil {
		return nil
	}
	return p.Method
}

func (p *ProcessingAccountPricingLink) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAccountPricingLink) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountPricingLink) SetRel(rel *string) {
	p.Rel = rel
	p.require(processingAccountPricingLinkFieldRel)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountPricingLink) SetHref(href *string) {
	p.Href = href
	p.require(processingAccountPricingLinkFieldHref)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAccountPricingLink) SetMethod(method *string) {
	p.Method = method
	p.require(processingAccountPricingLinkFieldMethod)
}

func (p *ProcessingAccountPricingLink) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAccountPricingLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAccountPricingLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAccountPricingLink) MarshalJSON() ([]byte, error) {
	type embed ProcessingAccountPricingLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAccountPricingLink) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Status of the processing account.
// - `entered` - We have received information about the account, but we have not yet reviewed it.
// - `pending` - We have reviewed the information about the account, but we have not yet approved it.
// - `approved` - We have approved the account for processing transactions and funding.
// - `subjectTo` - We have approved the account, but we are waiting on further information.
// - `dormant` - Account is closed for a period.
// - `nonProcessing` - We have approved the account, but the merchant has not yet run a transaction.
// - `rejected` - We rejected the application for the processing account.
// - `terminated` - Processing account is closed.
// - `cancelled` - Merchant withdrew the application for the processing account.
// **Note**: You can subscribe to our processingAccount.status.changed event to get notifications when we change the status of a processing account. For more information about how to subscribe to events, go to [Event Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).
type ProcessingAccountStatus string

const (
	ProcessingAccountStatusEntered       ProcessingAccountStatus = "entered"
	ProcessingAccountStatusPending       ProcessingAccountStatus = "pending"
	ProcessingAccountStatusApproved      ProcessingAccountStatus = "approved"
	ProcessingAccountStatusSubjectTo     ProcessingAccountStatus = "subjectTo"
	ProcessingAccountStatusDormant       ProcessingAccountStatus = "dormant"
	ProcessingAccountStatusNonProcessing ProcessingAccountStatus = "nonProcessing"
	ProcessingAccountStatusRejected      ProcessingAccountStatus = "rejected"
	ProcessingAccountStatusTerminated    ProcessingAccountStatus = "terminated"
	ProcessingAccountStatusCancelled     ProcessingAccountStatus = "cancelled"
)

func NewProcessingAccountStatusFromString(s string) (ProcessingAccountStatus, error) {
	switch s {
	case "entered":
		return ProcessingAccountStatusEntered, nil
	case "pending":
		return ProcessingAccountStatusPending, nil
	case "approved":
		return ProcessingAccountStatusApproved, nil
	case "subjectTo":
		return ProcessingAccountStatusSubjectTo, nil
	case "dormant":
		return ProcessingAccountStatusDormant, nil
	case "nonProcessing":
		return ProcessingAccountStatusNonProcessing, nil
	case "rejected":
		return ProcessingAccountStatusRejected, nil
	case "terminated":
		return ProcessingAccountStatusTerminated, nil
	case "cancelled":
		return ProcessingAccountStatusCancelled, nil
	}
	var t ProcessingAccountStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingAccountStatus) Ptr() *ProcessingAccountStatus {
	return &p
}

// Object that contains information about Automated Clearing House (ACH) transactions.
var (
	processingAchFieldNaics                        = big.NewInt(1 << 0)
	processingAchFieldPreviouslyTerminatedForAch   = big.NewInt(1 << 1)
	processingAchFieldRefunds                      = big.NewInt(1 << 2)
	processingAchFieldEstimatedMonthlyTransactions = big.NewInt(1 << 3)
	processingAchFieldLimits                       = big.NewInt(1 << 4)
	processingAchFieldTransactionTypes             = big.NewInt(1 << 5)
	processingAchFieldTransactionTypesOther        = big.NewInt(1 << 6)
)

type ProcessingAch struct {
	// North American Industry Classification System (NAICS) code.
	Naics *string `json:"naics,omitempty" url:"naics,omitempty"`
	// Indicates if the business or its principals were previously turned down for ACH processing.
	PreviouslyTerminatedForAch *bool `json:"previouslyTerminatedForAch,omitempty" url:"previouslyTerminatedForAch,omitempty"`
	// Object that contains information about the ACH refund policy for the processing account.
	Refunds *ProcessingAchRefunds `json:"refunds" url:"refunds"`
	// Estimated maximum number of transactions that the merchant will process in a month.
	EstimatedMonthlyTransactions int `json:"estimatedMonthlyTransactions" url:"estimatedMonthlyTransactions"`
	// Object that contains information about transaction limits for the processing account.
	Limits *ProcessingAchLimits `json:"limits" url:"limits"`
	// List of transaction types that the processing account supports.
	TransactionTypes []ProcessingAchTransactionTypesItem `json:"transactionTypes,omitempty" url:"transactionTypes,omitempty"`
	// If you send a value of `other` for transactionTypes, provide a list of the supported transaction types.
	TransactionTypesOther *string `json:"transactionTypesOther,omitempty" url:"transactionTypesOther,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAch) GetNaics() *string {
	if p == nil {
		return nil
	}
	return p.Naics
}

func (p *ProcessingAch) GetPreviouslyTerminatedForAch() *bool {
	if p == nil {
		return nil
	}
	return p.PreviouslyTerminatedForAch
}

func (p *ProcessingAch) GetRefunds() *ProcessingAchRefunds {
	if p == nil {
		return nil
	}
	return p.Refunds
}

func (p *ProcessingAch) GetEstimatedMonthlyTransactions() int {
	if p == nil {
		return 0
	}
	return p.EstimatedMonthlyTransactions
}

func (p *ProcessingAch) GetLimits() *ProcessingAchLimits {
	if p == nil {
		return nil
	}
	return p.Limits
}

func (p *ProcessingAch) GetTransactionTypes() []ProcessingAchTransactionTypesItem {
	if p == nil {
		return nil
	}
	return p.TransactionTypes
}

func (p *ProcessingAch) GetTransactionTypesOther() *string {
	if p == nil {
		return nil
	}
	return p.TransactionTypesOther
}

func (p *ProcessingAch) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAch) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNaics sets the Naics field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAch) SetNaics(naics *string) {
	p.Naics = naics
	p.require(processingAchFieldNaics)
}

// SetPreviouslyTerminatedForAch sets the PreviouslyTerminatedForAch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAch) SetPreviouslyTerminatedForAch(previouslyTerminatedForAch *bool) {
	p.PreviouslyTerminatedForAch = previouslyTerminatedForAch
	p.require(processingAchFieldPreviouslyTerminatedForAch)
}

// SetRefunds sets the Refunds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAch) SetRefunds(refunds *ProcessingAchRefunds) {
	p.Refunds = refunds
	p.require(processingAchFieldRefunds)
}

// SetEstimatedMonthlyTransactions sets the EstimatedMonthlyTransactions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAch) SetEstimatedMonthlyTransactions(estimatedMonthlyTransactions int) {
	p.EstimatedMonthlyTransactions = estimatedMonthlyTransactions
	p.require(processingAchFieldEstimatedMonthlyTransactions)
}

// SetLimits sets the Limits field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAch) SetLimits(limits *ProcessingAchLimits) {
	p.Limits = limits
	p.require(processingAchFieldLimits)
}

// SetTransactionTypes sets the TransactionTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAch) SetTransactionTypes(transactionTypes []ProcessingAchTransactionTypesItem) {
	p.TransactionTypes = transactionTypes
	p.require(processingAchFieldTransactionTypes)
}

// SetTransactionTypesOther sets the TransactionTypesOther field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAch) SetTransactionTypesOther(transactionTypesOther *string) {
	p.TransactionTypesOther = transactionTypesOther
	p.require(processingAchFieldTransactionTypesOther)
}

func (p *ProcessingAch) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAch(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAch) MarshalJSON() ([]byte, error) {
	type embed ProcessingAch
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAch) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about transaction limits for the processing account.
var (
	processingAchLimitsFieldSingleTransaction = big.NewInt(1 << 0)
	processingAchLimitsFieldDailyDeposit      = big.NewInt(1 << 1)
	processingAchLimitsFieldMonthlyDeposit    = big.NewInt(1 << 2)
)

type ProcessingAchLimits struct {
	// Maximum amount allowed for a single debit or credit transaction. The value is in the currency's lowest denomination, for example, cents.
	SingleTransaction int `json:"singleTransaction" url:"singleTransaction"`
	// Maximum amount of total transactions allowed per day. The value is in the currency's lowest denomination, for example, cents.
	DailyDeposit int `json:"dailyDeposit" url:"dailyDeposit"`
	// Maximum amount of total transactions allowed per month. The value is in the currency's lowest denomination, for example, cents.
	MonthlyDeposit int `json:"monthlyDeposit" url:"monthlyDeposit"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAchLimits) GetSingleTransaction() int {
	if p == nil {
		return 0
	}
	return p.SingleTransaction
}

func (p *ProcessingAchLimits) GetDailyDeposit() int {
	if p == nil {
		return 0
	}
	return p.DailyDeposit
}

func (p *ProcessingAchLimits) GetMonthlyDeposit() int {
	if p == nil {
		return 0
	}
	return p.MonthlyDeposit
}

func (p *ProcessingAchLimits) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAchLimits) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetSingleTransaction sets the SingleTransaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAchLimits) SetSingleTransaction(singleTransaction int) {
	p.SingleTransaction = singleTransaction
	p.require(processingAchLimitsFieldSingleTransaction)
}

// SetDailyDeposit sets the DailyDeposit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAchLimits) SetDailyDeposit(dailyDeposit int) {
	p.DailyDeposit = dailyDeposit
	p.require(processingAchLimitsFieldDailyDeposit)
}

// SetMonthlyDeposit sets the MonthlyDeposit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAchLimits) SetMonthlyDeposit(monthlyDeposit int) {
	p.MonthlyDeposit = monthlyDeposit
	p.require(processingAchLimitsFieldMonthlyDeposit)
}

func (p *ProcessingAchLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAchLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAchLimits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAchLimits) MarshalJSON() ([]byte, error) {
	type embed ProcessingAchLimits
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAchLimits) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the ACH refund policy for the processing account.
var (
	processingAchRefundsFieldWrittenRefundPolicy = big.NewInt(1 << 0)
	processingAchRefundsFieldRefundPolicyUrl     = big.NewInt(1 << 1)
)

type ProcessingAchRefunds struct {
	// Indicates if the business has a written refund policy.
	WrittenRefundPolicy bool `json:"writtenRefundPolicy" url:"writtenRefundPolicy"`
	// URL of the written refund policy.
	RefundPolicyUrl *string `json:"refundPolicyUrl,omitempty" url:"refundPolicyUrl,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingAchRefunds) GetWrittenRefundPolicy() bool {
	if p == nil {
		return false
	}
	return p.WrittenRefundPolicy
}

func (p *ProcessingAchRefunds) GetRefundPolicyUrl() *string {
	if p == nil {
		return nil
	}
	return p.RefundPolicyUrl
}

func (p *ProcessingAchRefunds) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingAchRefunds) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetWrittenRefundPolicy sets the WrittenRefundPolicy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAchRefunds) SetWrittenRefundPolicy(writtenRefundPolicy bool) {
	p.WrittenRefundPolicy = writtenRefundPolicy
	p.require(processingAchRefundsFieldWrittenRefundPolicy)
}

// SetRefundPolicyUrl sets the RefundPolicyUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingAchRefunds) SetRefundPolicyUrl(refundPolicyUrl *string) {
	p.RefundPolicyUrl = refundPolicyUrl
	p.require(processingAchRefundsFieldRefundPolicyUrl)
}

func (p *ProcessingAchRefunds) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingAchRefunds
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingAchRefunds(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingAchRefunds) MarshalJSON() ([]byte, error) {
	type embed ProcessingAchRefunds
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingAchRefunds) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProcessingAchTransactionTypesItem string

const (
	ProcessingAchTransactionTypesItemPrearrangedPayment        ProcessingAchTransactionTypesItem = "prearrangedPayment"
	ProcessingAchTransactionTypesItemCorpCashDisbursement      ProcessingAchTransactionTypesItem = "corpCashDisbursement"
	ProcessingAchTransactionTypesItemTelephoneInitiatedPayment ProcessingAchTransactionTypesItem = "telephoneInitiatedPayment"
	ProcessingAchTransactionTypesItemWebInitiatedPayment       ProcessingAchTransactionTypesItem = "webInitiatedPayment"
	ProcessingAchTransactionTypesItemOther                     ProcessingAchTransactionTypesItem = "other"
)

func NewProcessingAchTransactionTypesItemFromString(s string) (ProcessingAchTransactionTypesItem, error) {
	switch s {
	case "prearrangedPayment":
		return ProcessingAchTransactionTypesItemPrearrangedPayment, nil
	case "corpCashDisbursement":
		return ProcessingAchTransactionTypesItemCorpCashDisbursement, nil
	case "telephoneInitiatedPayment":
		return ProcessingAchTransactionTypesItemTelephoneInitiatedPayment, nil
	case "webInitiatedPayment":
		return ProcessingAchTransactionTypesItemWebInitiatedPayment, nil
	case "other":
		return ProcessingAchTransactionTypesItemOther, nil
	}
	var t ProcessingAchTransactionTypesItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingAchTransactionTypesItem) Ptr() *ProcessingAchTransactionTypesItem {
	return &p
}

// Object that contains information about the types of cards that the processing account accepts.
var (
	processingCardAcceptanceFieldDebitOnly       = big.NewInt(1 << 0)
	processingCardAcceptanceFieldHsaFsa          = big.NewInt(1 << 1)
	processingCardAcceptanceFieldCardsAccepted   = big.NewInt(1 << 2)
	processingCardAcceptanceFieldSpecialityCards = big.NewInt(1 << 3)
)

type ProcessingCardAcceptance struct {
	// Indicates if the merchant accepts only debit cards.
	DebitOnly *bool `json:"debitOnly,omitempty" url:"debitOnly,omitempty"`
	// Indicates if the merchant accepts health savings account (HSA) and flexible spending account (FSA) cards.
	HsaFsa *bool `json:"hsaFsa,omitempty" url:"hsaFsa,omitempty"`
	// List of card types the merchant accepts.
	CardsAccepted []ProcessingCardAcceptanceCardsAcceptedItem `json:"cardsAccepted,omitempty" url:"cardsAccepted,omitempty"`
	// Information about the speciality cards that the merchant accepts.
	SpecialityCards *ProcessingCardAcceptanceSpecialityCards `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingCardAcceptance) GetDebitOnly() *bool {
	if p == nil {
		return nil
	}
	return p.DebitOnly
}

func (p *ProcessingCardAcceptance) GetHsaFsa() *bool {
	if p == nil {
		return nil
	}
	return p.HsaFsa
}

func (p *ProcessingCardAcceptance) GetCardsAccepted() []ProcessingCardAcceptanceCardsAcceptedItem {
	if p == nil {
		return nil
	}
	return p.CardsAccepted
}

func (p *ProcessingCardAcceptance) GetSpecialityCards() *ProcessingCardAcceptanceSpecialityCards {
	if p == nil {
		return nil
	}
	return p.SpecialityCards
}

func (p *ProcessingCardAcceptance) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingCardAcceptance) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetDebitOnly sets the DebitOnly field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptance) SetDebitOnly(debitOnly *bool) {
	p.DebitOnly = debitOnly
	p.require(processingCardAcceptanceFieldDebitOnly)
}

// SetHsaFsa sets the HsaFsa field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptance) SetHsaFsa(hsaFsa *bool) {
	p.HsaFsa = hsaFsa
	p.require(processingCardAcceptanceFieldHsaFsa)
}

// SetCardsAccepted sets the CardsAccepted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptance) SetCardsAccepted(cardsAccepted []ProcessingCardAcceptanceCardsAcceptedItem) {
	p.CardsAccepted = cardsAccepted
	p.require(processingCardAcceptanceFieldCardsAccepted)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptance) SetSpecialityCards(specialityCards *ProcessingCardAcceptanceSpecialityCards) {
	p.SpecialityCards = specialityCards
	p.require(processingCardAcceptanceFieldSpecialityCards)
}

func (p *ProcessingCardAcceptance) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingCardAcceptance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingCardAcceptance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingCardAcceptance) MarshalJSON() ([]byte, error) {
	type embed ProcessingCardAcceptance
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingCardAcceptance) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProcessingCardAcceptanceCardsAcceptedItem string

const (
	ProcessingCardAcceptanceCardsAcceptedItemVisa        ProcessingCardAcceptanceCardsAcceptedItem = "visa"
	ProcessingCardAcceptanceCardsAcceptedItemMastercard  ProcessingCardAcceptanceCardsAcceptedItem = "mastercard"
	ProcessingCardAcceptanceCardsAcceptedItemDiscover    ProcessingCardAcceptanceCardsAcceptedItem = "discover"
	ProcessingCardAcceptanceCardsAcceptedItemAmexOptBlue ProcessingCardAcceptanceCardsAcceptedItem = "amexOptBlue"
)

func NewProcessingCardAcceptanceCardsAcceptedItemFromString(s string) (ProcessingCardAcceptanceCardsAcceptedItem, error) {
	switch s {
	case "visa":
		return ProcessingCardAcceptanceCardsAcceptedItemVisa, nil
	case "mastercard":
		return ProcessingCardAcceptanceCardsAcceptedItemMastercard, nil
	case "discover":
		return ProcessingCardAcceptanceCardsAcceptedItemDiscover, nil
	case "amexOptBlue":
		return ProcessingCardAcceptanceCardsAcceptedItemAmexOptBlue, nil
	}
	var t ProcessingCardAcceptanceCardsAcceptedItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingCardAcceptanceCardsAcceptedItem) Ptr() *ProcessingCardAcceptanceCardsAcceptedItem {
	return &p
}

// Information about the speciality cards that the merchant accepts.
var (
	processingCardAcceptanceSpecialityCardsFieldAmericanExpressDirect      = big.NewInt(1 << 0)
	processingCardAcceptanceSpecialityCardsFieldElectronicBenefitsTransfer = big.NewInt(1 << 1)
	processingCardAcceptanceSpecialityCardsFieldOther                      = big.NewInt(1 << 2)
)

type ProcessingCardAcceptanceSpecialityCards struct {
	// Object that indicates if the merchant accepts American Express Direct cards and contains the merchant’s American Express merchant number.
	AmericanExpressDirect *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect `json:"americanExpressDirect,omitempty" url:"americanExpressDirect,omitempty"`
	// Object that indicates if the merchant accepts Electronic Benefits Transfer (EBT) cards and contains the merchant’s Food and Nutrition Services (FNS) number.
	ElectronicBenefitsTransfer *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	// Object that contains information about other speciality cards that the merchant accepts.
	Other *ProcessingCardAcceptanceSpecialityCardsOther `json:"other,omitempty" url:"other,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingCardAcceptanceSpecialityCards) GetAmericanExpressDirect() *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect {
	if p == nil {
		return nil
	}
	return p.AmericanExpressDirect
}

func (p *ProcessingCardAcceptanceSpecialityCards) GetElectronicBenefitsTransfer() *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer {
	if p == nil {
		return nil
	}
	return p.ElectronicBenefitsTransfer
}

func (p *ProcessingCardAcceptanceSpecialityCards) GetOther() *ProcessingCardAcceptanceSpecialityCardsOther {
	if p == nil {
		return nil
	}
	return p.Other
}

func (p *ProcessingCardAcceptanceSpecialityCards) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingCardAcceptanceSpecialityCards) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAmericanExpressDirect sets the AmericanExpressDirect field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCards) SetAmericanExpressDirect(americanExpressDirect *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) {
	p.AmericanExpressDirect = americanExpressDirect
	p.require(processingCardAcceptanceSpecialityCardsFieldAmericanExpressDirect)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCards) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) {
	p.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	p.require(processingCardAcceptanceSpecialityCardsFieldElectronicBenefitsTransfer)
}

// SetOther sets the Other field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCards) SetOther(other *ProcessingCardAcceptanceSpecialityCardsOther) {
	p.Other = other
	p.require(processingCardAcceptanceSpecialityCardsFieldOther)
}

func (p *ProcessingCardAcceptanceSpecialityCards) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingCardAcceptanceSpecialityCards
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingCardAcceptanceSpecialityCards(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingCardAcceptanceSpecialityCards) MarshalJSON() ([]byte, error) {
	type embed ProcessingCardAcceptanceSpecialityCards
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingCardAcceptanceSpecialityCards) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that indicates if the merchant accepts American Express Direct cards and contains the merchant’s American Express merchant number.
var (
	processingCardAcceptanceSpecialityCardsAmericanExpressDirectFieldEnabled        = big.NewInt(1 << 0)
	processingCardAcceptanceSpecialityCardsAmericanExpressDirectFieldMerchantNumber = big.NewInt(1 << 1)
)

type ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect struct {
	// Indicates if the merchant accepts American Express Direct.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// If the merchant accepts American Express Direct, provide their American Express merchant number.
	MerchantNumber *string `json:"merchantNumber,omitempty" url:"merchantNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) GetEnabled() *bool {
	if p == nil {
		return nil
	}
	return p.Enabled
}

func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) GetMerchantNumber() *string {
	if p == nil {
		return nil
	}
	return p.MerchantNumber
}

func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) SetEnabled(enabled *bool) {
	p.Enabled = enabled
	p.require(processingCardAcceptanceSpecialityCardsAmericanExpressDirectFieldEnabled)
}

// SetMerchantNumber sets the MerchantNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) SetMerchantNumber(merchantNumber *string) {
	p.MerchantNumber = merchantNumber
	p.require(processingCardAcceptanceSpecialityCardsAmericanExpressDirectFieldMerchantNumber)
}

func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) MarshalJSON() ([]byte, error) {
	type embed ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingCardAcceptanceSpecialityCardsAmericanExpressDirect) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that indicates if the merchant accepts Electronic Benefits Transfer (EBT) cards and contains the merchant’s Food and Nutrition Services (FNS) number.
var (
	processingCardAcceptanceSpecialityCardsElectronicBenefitsTransferFieldEnabled   = big.NewInt(1 << 0)
	processingCardAcceptanceSpecialityCardsElectronicBenefitsTransferFieldFnsNumber = big.NewInt(1 << 1)
)

type ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer struct {
	// Indicates if the merchant accepts EBT.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// If the merchant accepts EBT, provide their FNS number.
	FnsNumber *string `json:"fnsNumber,omitempty" url:"fnsNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) GetEnabled() *bool {
	if p == nil {
		return nil
	}
	return p.Enabled
}

func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) GetFnsNumber() *string {
	if p == nil {
		return nil
	}
	return p.FnsNumber
}

func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) SetEnabled(enabled *bool) {
	p.Enabled = enabled
	p.require(processingCardAcceptanceSpecialityCardsElectronicBenefitsTransferFieldEnabled)
}

// SetFnsNumber sets the FnsNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) SetFnsNumber(fnsNumber *string) {
	p.FnsNumber = fnsNumber
	p.require(processingCardAcceptanceSpecialityCardsElectronicBenefitsTransferFieldFnsNumber)
}

func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) MarshalJSON() ([]byte, error) {
	type embed ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingCardAcceptanceSpecialityCardsElectronicBenefitsTransfer) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about other speciality cards that the merchant accepts.
var (
	processingCardAcceptanceSpecialityCardsOtherFieldWexMerchantNumber = big.NewInt(1 << 0)
	processingCardAcceptanceSpecialityCardsOtherFieldVoyagerMerchantId = big.NewInt(1 << 1)
	processingCardAcceptanceSpecialityCardsOtherFieldFleetMerchantId   = big.NewInt(1 << 2)
)

type ProcessingCardAcceptanceSpecialityCardsOther struct {
	// If the merchant accepts WEX, provide their WEX merchant number.
	WexMerchantNumber *string `json:"wexMerchantNumber,omitempty" url:"wexMerchantNumber,omitempty"`
	// If the merchant accepts Voyager, provide their Voyager merchant ID.
	VoyagerMerchantId *string `json:"voyagerMerchantId,omitempty" url:"voyagerMerchantId,omitempty"`
	// If the merchant accepts Fleet, provide their Fleet merchant ID.
	FleetMerchantId *string `json:"fleetMerchantId,omitempty" url:"fleetMerchantId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) GetWexMerchantNumber() *string {
	if p == nil {
		return nil
	}
	return p.WexMerchantNumber
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) GetVoyagerMerchantId() *string {
	if p == nil {
		return nil
	}
	return p.VoyagerMerchantId
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) GetFleetMerchantId() *string {
	if p == nil {
		return nil
	}
	return p.FleetMerchantId
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetWexMerchantNumber sets the WexMerchantNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCardsOther) SetWexMerchantNumber(wexMerchantNumber *string) {
	p.WexMerchantNumber = wexMerchantNumber
	p.require(processingCardAcceptanceSpecialityCardsOtherFieldWexMerchantNumber)
}

// SetVoyagerMerchantId sets the VoyagerMerchantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCardsOther) SetVoyagerMerchantId(voyagerMerchantId *string) {
	p.VoyagerMerchantId = voyagerMerchantId
	p.require(processingCardAcceptanceSpecialityCardsOtherFieldVoyagerMerchantId)
}

// SetFleetMerchantId sets the FleetMerchantId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingCardAcceptanceSpecialityCardsOther) SetFleetMerchantId(fleetMerchantId *string) {
	p.FleetMerchantId = fleetMerchantId
	p.require(processingCardAcceptanceSpecialityCardsOtherFieldFleetMerchantId)
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingCardAcceptanceSpecialityCardsOther
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingCardAcceptanceSpecialityCardsOther(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) MarshalJSON() ([]byte, error) {
	type embed ProcessingCardAcceptanceSpecialityCardsOther
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingCardAcceptanceSpecialityCardsOther) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the monthly processing amounts for the processing account.
var (
	processingMonthlyAmountsFieldAverage = big.NewInt(1 << 0)
	processingMonthlyAmountsFieldHighest = big.NewInt(1 << 1)
)

type ProcessingMonthlyAmounts struct {
	// Estimated average transaction amount each month. The value is in the currency's lowest denomination, for example, cents. You must provide an amount that is greater than zero.
	Average int `json:"average" url:"average"`
	// Estimated maximum transaction amount each month. The value is in the currency's lowest denomination, for example, cents. You must provide an amount that is greater than zero.
	Highest int `json:"highest" url:"highest"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingMonthlyAmounts) GetAverage() int {
	if p == nil {
		return 0
	}
	return p.Average
}

func (p *ProcessingMonthlyAmounts) GetHighest() int {
	if p == nil {
		return 0
	}
	return p.Highest
}

func (p *ProcessingMonthlyAmounts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingMonthlyAmounts) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAverage sets the Average field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingMonthlyAmounts) SetAverage(average int) {
	p.Average = average
	p.require(processingMonthlyAmountsFieldAverage)
}

// SetHighest sets the Highest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingMonthlyAmounts) SetHighest(highest int) {
	p.Highest = highest
	p.require(processingMonthlyAmountsFieldHighest)
}

func (p *ProcessingMonthlyAmounts) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingMonthlyAmounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingMonthlyAmounts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingMonthlyAmounts) MarshalJSON() ([]byte, error) {
	type embed ProcessingMonthlyAmounts
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingMonthlyAmounts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type ProcessingMonthsOfOperationItem string

const (
	ProcessingMonthsOfOperationItemJan ProcessingMonthsOfOperationItem = "jan"
	ProcessingMonthsOfOperationItemFeb ProcessingMonthsOfOperationItem = "feb"
	ProcessingMonthsOfOperationItemMar ProcessingMonthsOfOperationItem = "mar"
	ProcessingMonthsOfOperationItemApr ProcessingMonthsOfOperationItem = "apr"
	ProcessingMonthsOfOperationItemMay ProcessingMonthsOfOperationItem = "may"
	ProcessingMonthsOfOperationItemJun ProcessingMonthsOfOperationItem = "jun"
	ProcessingMonthsOfOperationItemJul ProcessingMonthsOfOperationItem = "jul"
	ProcessingMonthsOfOperationItemAug ProcessingMonthsOfOperationItem = "aug"
	ProcessingMonthsOfOperationItemSep ProcessingMonthsOfOperationItem = "sep"
	ProcessingMonthsOfOperationItemOct ProcessingMonthsOfOperationItem = "oct"
	ProcessingMonthsOfOperationItemNov ProcessingMonthsOfOperationItem = "nov"
	ProcessingMonthsOfOperationItemDec ProcessingMonthsOfOperationItem = "dec"
)

func NewProcessingMonthsOfOperationItemFromString(s string) (ProcessingMonthsOfOperationItem, error) {
	switch s {
	case "jan":
		return ProcessingMonthsOfOperationItemJan, nil
	case "feb":
		return ProcessingMonthsOfOperationItemFeb, nil
	case "mar":
		return ProcessingMonthsOfOperationItemMar, nil
	case "apr":
		return ProcessingMonthsOfOperationItemApr, nil
	case "may":
		return ProcessingMonthsOfOperationItemMay, nil
	case "jun":
		return ProcessingMonthsOfOperationItemJun, nil
	case "jul":
		return ProcessingMonthsOfOperationItemJul, nil
	case "aug":
		return ProcessingMonthsOfOperationItemAug, nil
	case "sep":
		return ProcessingMonthsOfOperationItemSep, nil
	case "oct":
		return ProcessingMonthsOfOperationItemOct, nil
	case "nov":
		return ProcessingMonthsOfOperationItemNov, nil
	case "dec":
		return ProcessingMonthsOfOperationItemDec, nil
	}
	var t ProcessingMonthsOfOperationItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingMonthsOfOperationItem) Ptr() *ProcessingMonthsOfOperationItem {
	return &p
}

var (
	processingTerminalFieldProcessingTerminalId = big.NewInt(1 << 0)
	processingTerminalFieldStatus               = big.NewInt(1 << 1)
	processingTerminalFieldTimezone             = big.NewInt(1 << 2)
	processingTerminalFieldProgram              = big.NewInt(1 << 3)
	processingTerminalFieldGateway              = big.NewInt(1 << 4)
	processingTerminalFieldBatchClosure         = big.NewInt(1 << 5)
	processingTerminalFieldApplicationSettings  = big.NewInt(1 << 6)
	processingTerminalFieldFeatures             = big.NewInt(1 << 7)
	processingTerminalFieldTaxes                = big.NewInt(1 << 8)
	processingTerminalFieldSecurity             = big.NewInt(1 << 9)
	processingTerminalFieldReceiptNotifications = big.NewInt(1 << 10)
	processingTerminalFieldDevices              = big.NewInt(1 << 11)
)

type ProcessingTerminal struct {
	// Unique identifier that we assigned to the processing terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Indicates if the processing terminal is active.
	Status ProcessingTerminalStatus `json:"status" url:"status"`
	// Time zone of the processing terminal.
	Timezone ProcessingTerminalTimezone `json:"timezone" url:"timezone"`
	// Name of the product and its setup.
	Program *string `json:"program,omitempty" url:"program,omitempty"`
	// Polymorphic object that contains the gateway settings for the solution.
	Gateway *PayrocGateway `json:"gateway,omitempty" url:"gateway,omitempty"`
	// Polymorphic object that contains information about when and how the terminal closes the batch.
	//
	// The value of the batchCloseType field determines which variant you should use:
	// -	`automatic` - Terminal automatically closes the batch at a specific time each day.
	// - `manual` - Merchant uses the terminal to manually close the batch.
	BatchClosure *ProcessingTerminalBatchClosure `json:"batchClosure" url:"batchClosure"`
	// Object that contains the application settings for the solution.
	ApplicationSettings *ProcessingTerminalApplicationSettings `json:"applicationSettings" url:"applicationSettings"`
	// Object that contains the feature settings for the terminal.
	Features *ProcessingTerminalFeatures `json:"features" url:"features"`
	// Array of tax objects that contains the taxes that apply to the merchant's transactions.
	Taxes []*ProcessingTerminalTaxesItem `json:"taxes,omitempty" url:"taxes,omitempty"`
	// Object that contains the tokenization settings and AVS settings for the terminal.
	Security *ProcessingTerminalSecurity `json:"security,omitempty" url:"security,omitempty"`
	// Object that indicates if the terminal can send email receipts or text receipts.
	ReceiptNotifications *ProcessingTerminalReceiptNotifications `json:"receiptNotifications,omitempty" url:"receiptNotifications,omitempty"`
	// Array of device objects. Each object contains information about a device using the processing terminal's configuration.
	Devices []*ProcessingTerminalDevicesItem `json:"devices,omitempty" url:"devices,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminal) GetProcessingTerminalId() string {
	if p == nil {
		return ""
	}
	return p.ProcessingTerminalId
}

func (p *ProcessingTerminal) GetStatus() ProcessingTerminalStatus {
	if p == nil {
		return ""
	}
	return p.Status
}

func (p *ProcessingTerminal) GetTimezone() ProcessingTerminalTimezone {
	if p == nil {
		return ""
	}
	return p.Timezone
}

func (p *ProcessingTerminal) GetProgram() *string {
	if p == nil {
		return nil
	}
	return p.Program
}

func (p *ProcessingTerminal) GetGateway() *PayrocGateway {
	if p == nil {
		return nil
	}
	return p.Gateway
}

func (p *ProcessingTerminal) GetBatchClosure() *ProcessingTerminalBatchClosure {
	if p == nil {
		return nil
	}
	return p.BatchClosure
}

func (p *ProcessingTerminal) GetApplicationSettings() *ProcessingTerminalApplicationSettings {
	if p == nil {
		return nil
	}
	return p.ApplicationSettings
}

func (p *ProcessingTerminal) GetFeatures() *ProcessingTerminalFeatures {
	if p == nil {
		return nil
	}
	return p.Features
}

func (p *ProcessingTerminal) GetTaxes() []*ProcessingTerminalTaxesItem {
	if p == nil {
		return nil
	}
	return p.Taxes
}

func (p *ProcessingTerminal) GetSecurity() *ProcessingTerminalSecurity {
	if p == nil {
		return nil
	}
	return p.Security
}

func (p *ProcessingTerminal) GetReceiptNotifications() *ProcessingTerminalReceiptNotifications {
	if p == nil {
		return nil
	}
	return p.ReceiptNotifications
}

func (p *ProcessingTerminal) GetDevices() []*ProcessingTerminalDevicesItem {
	if p == nil {
		return nil
	}
	return p.Devices
}

func (p *ProcessingTerminal) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminal) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetProcessingTerminalId(processingTerminalId string) {
	p.ProcessingTerminalId = processingTerminalId
	p.require(processingTerminalFieldProcessingTerminalId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetStatus(status ProcessingTerminalStatus) {
	p.Status = status
	p.require(processingTerminalFieldStatus)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetTimezone(timezone ProcessingTerminalTimezone) {
	p.Timezone = timezone
	p.require(processingTerminalFieldTimezone)
}

// SetProgram sets the Program field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetProgram(program *string) {
	p.Program = program
	p.require(processingTerminalFieldProgram)
}

// SetGateway sets the Gateway field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetGateway(gateway *PayrocGateway) {
	p.Gateway = gateway
	p.require(processingTerminalFieldGateway)
}

// SetBatchClosure sets the BatchClosure field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetBatchClosure(batchClosure *ProcessingTerminalBatchClosure) {
	p.BatchClosure = batchClosure
	p.require(processingTerminalFieldBatchClosure)
}

// SetApplicationSettings sets the ApplicationSettings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetApplicationSettings(applicationSettings *ProcessingTerminalApplicationSettings) {
	p.ApplicationSettings = applicationSettings
	p.require(processingTerminalFieldApplicationSettings)
}

// SetFeatures sets the Features field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetFeatures(features *ProcessingTerminalFeatures) {
	p.Features = features
	p.require(processingTerminalFieldFeatures)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetTaxes(taxes []*ProcessingTerminalTaxesItem) {
	p.Taxes = taxes
	p.require(processingTerminalFieldTaxes)
}

// SetSecurity sets the Security field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetSecurity(security *ProcessingTerminalSecurity) {
	p.Security = security
	p.require(processingTerminalFieldSecurity)
}

// SetReceiptNotifications sets the ReceiptNotifications field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetReceiptNotifications(receiptNotifications *ProcessingTerminalReceiptNotifications) {
	p.ReceiptNotifications = receiptNotifications
	p.require(processingTerminalFieldReceiptNotifications)
}

// SetDevices sets the Devices field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminal) SetDevices(devices []*ProcessingTerminalDevicesItem) {
	p.Devices = devices
	p.require(processingTerminalFieldDevices)
}

func (p *ProcessingTerminal) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminal) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminal
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminal) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains the application settings for the solution.
var (
	processingTerminalApplicationSettingsFieldInvoiceNumberPrompt = big.NewInt(1 << 0)
	processingTerminalApplicationSettingsFieldClerkPrompt         = big.NewInt(1 << 1)
)

type ProcessingTerminalApplicationSettings struct {
	// Indicates if the terminal should prompt the clerk to provide an invoice number with a sale.
	InvoiceNumberPrompt *bool `json:"invoiceNumberPrompt,omitempty" url:"invoiceNumberPrompt,omitempty"`
	// Indicates if the terminal should prompt the clerk, for example, if the terminal should prompt when the clerk needs to enter an amount on the terminal.
	ClerkPrompt *bool `json:"clerkPrompt,omitempty" url:"clerkPrompt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalApplicationSettings) GetInvoiceNumberPrompt() *bool {
	if p == nil {
		return nil
	}
	return p.InvoiceNumberPrompt
}

func (p *ProcessingTerminalApplicationSettings) GetClerkPrompt() *bool {
	if p == nil {
		return nil
	}
	return p.ClerkPrompt
}

func (p *ProcessingTerminalApplicationSettings) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalApplicationSettings) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetInvoiceNumberPrompt sets the InvoiceNumberPrompt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalApplicationSettings) SetInvoiceNumberPrompt(invoiceNumberPrompt *bool) {
	p.InvoiceNumberPrompt = invoiceNumberPrompt
	p.require(processingTerminalApplicationSettingsFieldInvoiceNumberPrompt)
}

// SetClerkPrompt sets the ClerkPrompt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalApplicationSettings) SetClerkPrompt(clerkPrompt *bool) {
	p.ClerkPrompt = clerkPrompt
	p.require(processingTerminalApplicationSettingsFieldClerkPrompt)
}

func (p *ProcessingTerminalApplicationSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalApplicationSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalApplicationSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalApplicationSettings) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalApplicationSettings
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalApplicationSettings) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Polymorphic object that contains information about when and how the terminal closes the batch.
//
// The value of the batchCloseType field determines which variant you should use:
// -	`automatic` - Terminal automatically closes the batch at a specific time each day.
// - `manual` - Merchant uses the terminal to manually close the batch.
type ProcessingTerminalBatchClosure struct {
	BatchCloseType string
	Automatic      *SchemasAutomaticBatchClose
	Manual         *SchemasManualBatchClose
}

func (p *ProcessingTerminalBatchClosure) GetBatchCloseType() string {
	if p == nil {
		return ""
	}
	return p.BatchCloseType
}

func (p *ProcessingTerminalBatchClosure) GetAutomatic() *SchemasAutomaticBatchClose {
	if p == nil {
		return nil
	}
	return p.Automatic
}

func (p *ProcessingTerminalBatchClosure) GetManual() *SchemasManualBatchClose {
	if p == nil {
		return nil
	}
	return p.Manual
}

func (p *ProcessingTerminalBatchClosure) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		BatchCloseType string `json:"batchCloseType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.BatchCloseType = unmarshaler.BatchCloseType
	if unmarshaler.BatchCloseType == "" {
		return fmt.Errorf("%T did not include discriminant batchCloseType", p)
	}
	switch unmarshaler.BatchCloseType {
	case "automatic":
		value := new(SchemasAutomaticBatchClose)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Automatic = value
	case "manual":
		value := new(SchemasManualBatchClose)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Manual = value
	}
	return nil
}

func (p ProcessingTerminalBatchClosure) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.Automatic != nil {
		return internal.MarshalJSONWithExtraProperty(p.Automatic, "batchCloseType", "automatic")
	}
	if p.Manual != nil {
		return internal.MarshalJSONWithExtraProperty(p.Manual, "batchCloseType", "manual")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type ProcessingTerminalBatchClosureVisitor interface {
	VisitAutomatic(*SchemasAutomaticBatchClose) error
	VisitManual(*SchemasManualBatchClose) error
}

func (p *ProcessingTerminalBatchClosure) Accept(visitor ProcessingTerminalBatchClosureVisitor) error {
	if p.Automatic != nil {
		return visitor.VisitAutomatic(p.Automatic)
	}
	if p.Manual != nil {
		return visitor.VisitManual(p.Manual)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *ProcessingTerminalBatchClosure) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.Automatic != nil {
		fields = append(fields, "automatic")
	}
	if p.Manual != nil {
		fields = append(fields, "manual")
	}
	if len(fields) == 0 {
		if p.BatchCloseType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.BatchCloseType)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.BatchCloseType != "" {
		field := fields[0]
		if p.BatchCloseType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.BatchCloseType,
				p,
			)
		}
	}
	return nil
}

// Object that contains the details of the device.
var (
	processingTerminalDevicesItemFieldManufacturer      = big.NewInt(1 << 0)
	processingTerminalDevicesItemFieldModel             = big.NewInt(1 << 1)
	processingTerminalDevicesItemFieldSerialNumber      = big.NewInt(1 << 2)
	processingTerminalDevicesItemFieldCommunicationType = big.NewInt(1 << 3)
)

type ProcessingTerminalDevicesItem struct {
	// Manufacturer of the terminal.
	Manufacturer string `json:"manufacturer" url:"manufacturer"`
	// Model of the terminal.
	Model string `json:"model" url:"model"`
	// Serial number of the terminal.
	SerialNumber      string             `json:"serialNumber" url:"serialNumber"`
	CommunicationType *CommunicationType `json:"communicationType,omitempty" url:"communicationType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalDevicesItem) GetManufacturer() string {
	if p == nil {
		return ""
	}
	return p.Manufacturer
}

func (p *ProcessingTerminalDevicesItem) GetModel() string {
	if p == nil {
		return ""
	}
	return p.Model
}

func (p *ProcessingTerminalDevicesItem) GetSerialNumber() string {
	if p == nil {
		return ""
	}
	return p.SerialNumber
}

func (p *ProcessingTerminalDevicesItem) GetCommunicationType() *CommunicationType {
	if p == nil {
		return nil
	}
	return p.CommunicationType
}

func (p *ProcessingTerminalDevicesItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalDevicesItem) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetManufacturer sets the Manufacturer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalDevicesItem) SetManufacturer(manufacturer string) {
	p.Manufacturer = manufacturer
	p.require(processingTerminalDevicesItemFieldManufacturer)
}

// SetModel sets the Model field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalDevicesItem) SetModel(model string) {
	p.Model = model
	p.require(processingTerminalDevicesItemFieldModel)
}

// SetSerialNumber sets the SerialNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalDevicesItem) SetSerialNumber(serialNumber string) {
	p.SerialNumber = serialNumber
	p.require(processingTerminalDevicesItemFieldSerialNumber)
}

// SetCommunicationType sets the CommunicationType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalDevicesItem) SetCommunicationType(communicationType *CommunicationType) {
	p.CommunicationType = communicationType
	p.require(processingTerminalDevicesItemFieldCommunicationType)
}

func (p *ProcessingTerminalDevicesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalDevicesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalDevicesItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalDevicesItem) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalDevicesItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalDevicesItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains the feature settings for the terminal.
var (
	processingTerminalFeaturesFieldTips               = big.NewInt(1 << 0)
	processingTerminalFeaturesFieldEnhancedProcessing = big.NewInt(1 << 1)
	processingTerminalFeaturesFieldEbt                = big.NewInt(1 << 2)
	processingTerminalFeaturesFieldPinDebitCashback   = big.NewInt(1 << 3)
	processingTerminalFeaturesFieldRecurringPayments  = big.NewInt(1 << 4)
	processingTerminalFeaturesFieldPaymentLinks       = big.NewInt(1 << 5)
	processingTerminalFeaturesFieldPreAuthorizations  = big.NewInt(1 << 6)
	processingTerminalFeaturesFieldOfflinePayments    = big.NewInt(1 << 7)
)

type ProcessingTerminalFeatures struct {
	// Polymorphic object that indicates if the terminal accepts tips.
	//
	// The value of the enabled field determines which variant you should use:
	// -	`true` - Terminal allows tips.
	// -	`false` - Terminal doesn't allow tips.
	Tips *ProcessingTerminalFeaturesTips `json:"tips,omitempty" url:"tips,omitempty"`
	// Object that contains details about level two and level three transactions.
	EnhancedProcessing *ProcessingTerminalFeaturesEnhancedProcessing `json:"enhancedProcessing" url:"enhancedProcessing"`
	// Polymorphic object that indicates if the terminal accepts EBT transactions.
	//
	// The value of the enabled field determines which variant you should use:
	// -	`true` - Terminal allows EBT transactions.
	// -	`false` - Terminal doesn't allow EBT transactions.
	Ebt *ProcessingTerminalFeaturesEbt `json:"ebt" url:"ebt"`
	// Indicates if the terminal prompts for cashback on PIN debit transactions.
	PinDebitCashback bool `json:"pinDebitCashback" url:"pinDebitCashback"`
	// Indicates if the terminal can run repeat payments. For more information about repeat payments, go to [Payment Plans](https://docs.payroc.com/guides/take-payments/repeat-payments).
	RecurringPayments *bool `json:"recurringPayments,omitempty" url:"recurringPayments,omitempty"`
	// Object that contains details about payment links.
	PaymentLinks *ProcessingTerminalFeaturesPaymentLinks `json:"paymentLinks,omitempty" url:"paymentLinks,omitempty"`
	// Indicates if the terminal can run pre-authorizations.
	PreAuthorizations *bool `json:"preAuthorizations,omitempty" url:"preAuthorizations,omitempty"`
	// Indicates if the terminal can accept payments when it can't connect to the gateway. For more information about offline processing, go to [Offline Processing](https://docs.payroc.com/knowledge/card-payments/offline-processing).
	OfflinePayments *bool `json:"offlinePayments,omitempty" url:"offlinePayments,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalFeatures) GetTips() *ProcessingTerminalFeaturesTips {
	if p == nil {
		return nil
	}
	return p.Tips
}

func (p *ProcessingTerminalFeatures) GetEnhancedProcessing() *ProcessingTerminalFeaturesEnhancedProcessing {
	if p == nil {
		return nil
	}
	return p.EnhancedProcessing
}

func (p *ProcessingTerminalFeatures) GetEbt() *ProcessingTerminalFeaturesEbt {
	if p == nil {
		return nil
	}
	return p.Ebt
}

func (p *ProcessingTerminalFeatures) GetPinDebitCashback() bool {
	if p == nil {
		return false
	}
	return p.PinDebitCashback
}

func (p *ProcessingTerminalFeatures) GetRecurringPayments() *bool {
	if p == nil {
		return nil
	}
	return p.RecurringPayments
}

func (p *ProcessingTerminalFeatures) GetPaymentLinks() *ProcessingTerminalFeaturesPaymentLinks {
	if p == nil {
		return nil
	}
	return p.PaymentLinks
}

func (p *ProcessingTerminalFeatures) GetPreAuthorizations() *bool {
	if p == nil {
		return nil
	}
	return p.PreAuthorizations
}

func (p *ProcessingTerminalFeatures) GetOfflinePayments() *bool {
	if p == nil {
		return nil
	}
	return p.OfflinePayments
}

func (p *ProcessingTerminalFeatures) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalFeatures) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetTips sets the Tips field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetTips(tips *ProcessingTerminalFeaturesTips) {
	p.Tips = tips
	p.require(processingTerminalFeaturesFieldTips)
}

// SetEnhancedProcessing sets the EnhancedProcessing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetEnhancedProcessing(enhancedProcessing *ProcessingTerminalFeaturesEnhancedProcessing) {
	p.EnhancedProcessing = enhancedProcessing
	p.require(processingTerminalFeaturesFieldEnhancedProcessing)
}

// SetEbt sets the Ebt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetEbt(ebt *ProcessingTerminalFeaturesEbt) {
	p.Ebt = ebt
	p.require(processingTerminalFeaturesFieldEbt)
}

// SetPinDebitCashback sets the PinDebitCashback field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetPinDebitCashback(pinDebitCashback bool) {
	p.PinDebitCashback = pinDebitCashback
	p.require(processingTerminalFeaturesFieldPinDebitCashback)
}

// SetRecurringPayments sets the RecurringPayments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetRecurringPayments(recurringPayments *bool) {
	p.RecurringPayments = recurringPayments
	p.require(processingTerminalFeaturesFieldRecurringPayments)
}

// SetPaymentLinks sets the PaymentLinks field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetPaymentLinks(paymentLinks *ProcessingTerminalFeaturesPaymentLinks) {
	p.PaymentLinks = paymentLinks
	p.require(processingTerminalFeaturesFieldPaymentLinks)
}

// SetPreAuthorizations sets the PreAuthorizations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetPreAuthorizations(preAuthorizations *bool) {
	p.PreAuthorizations = preAuthorizations
	p.require(processingTerminalFeaturesFieldPreAuthorizations)
}

// SetOfflinePayments sets the OfflinePayments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeatures) SetOfflinePayments(offlinePayments *bool) {
	p.OfflinePayments = offlinePayments
	p.require(processingTerminalFeaturesFieldOfflinePayments)
}

func (p *ProcessingTerminalFeatures) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalFeatures
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalFeatures(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalFeatures) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalFeatures
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalFeatures) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Polymorphic object that indicates if the terminal accepts EBT transactions.
//
// The value of the enabled field determines which variant you should use:
// -	`true` - Terminal allows EBT transactions.
// -	`false` - Terminal doesn't allow EBT transactions.
type ProcessingTerminalFeaturesEbt struct {
	EbtEnabled  *EbtEnabled
	EbtDisabled *EbtDisabled

	typ string
}

func (p *ProcessingTerminalFeaturesEbt) GetEbtEnabled() *EbtEnabled {
	if p == nil {
		return nil
	}
	return p.EbtEnabled
}

func (p *ProcessingTerminalFeaturesEbt) GetEbtDisabled() *EbtDisabled {
	if p == nil {
		return nil
	}
	return p.EbtDisabled
}

func (p *ProcessingTerminalFeaturesEbt) UnmarshalJSON(data []byte) error {
	valueEbtEnabled := new(EbtEnabled)
	if err := json.Unmarshal(data, &valueEbtEnabled); err == nil {
		p.typ = "EbtEnabled"
		p.EbtEnabled = valueEbtEnabled
		return nil
	}
	valueEbtDisabled := new(EbtDisabled)
	if err := json.Unmarshal(data, &valueEbtDisabled); err == nil {
		p.typ = "EbtDisabled"
		p.EbtDisabled = valueEbtDisabled
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p ProcessingTerminalFeaturesEbt) MarshalJSON() ([]byte, error) {
	if p.typ == "EbtEnabled" || p.EbtEnabled != nil {
		return json.Marshal(p.EbtEnabled)
	}
	if p.typ == "EbtDisabled" || p.EbtDisabled != nil {
		return json.Marshal(p.EbtDisabled)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type ProcessingTerminalFeaturesEbtVisitor interface {
	VisitEbtEnabled(*EbtEnabled) error
	VisitEbtDisabled(*EbtDisabled) error
}

func (p *ProcessingTerminalFeaturesEbt) Accept(visitor ProcessingTerminalFeaturesEbtVisitor) error {
	if p.typ == "EbtEnabled" || p.EbtEnabled != nil {
		return visitor.VisitEbtEnabled(p.EbtEnabled)
	}
	if p.typ == "EbtDisabled" || p.EbtDisabled != nil {
		return visitor.VisitEbtDisabled(p.EbtDisabled)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// Object that contains details about level two and level three transactions.
var (
	processingTerminalFeaturesEnhancedProcessingFieldEnabled              = big.NewInt(1 << 0)
	processingTerminalFeaturesEnhancedProcessingFieldTransactionDataLevel = big.NewInt(1 << 1)
	processingTerminalFeaturesEnhancedProcessingFieldShippingAddressMode  = big.NewInt(1 << 2)
)

type ProcessingTerminalFeaturesEnhancedProcessing struct {
	// Indicates if the terminal can run level two and level three transactions.
	Enabled bool `json:"enabled" url:"enabled"`
	// Indicates if the terminal supports level two or level three transactions.
	TransactionDataLevel *ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel `json:"transactionDataLevel,omitempty" url:"transactionDataLevel,omitempty"`
	// Indicates the address information that the clerk must provide to qualify for level two or level three data. The value is one of the following:
	// - `fullAddress` - The clerk must provide the full address for the transaction to qualify.
	// - `postalCode` - The clerk must provide a postal code for the transaction to qualify.
	ShippingAddressMode *ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode `json:"shippingAddressMode,omitempty" url:"shippingAddressMode,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) GetEnabled() bool {
	if p == nil {
		return false
	}
	return p.Enabled
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) GetTransactionDataLevel() *ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel {
	if p == nil {
		return nil
	}
	return p.TransactionDataLevel
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) GetShippingAddressMode() *ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode {
	if p == nil {
		return nil
	}
	return p.ShippingAddressMode
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeaturesEnhancedProcessing) SetEnabled(enabled bool) {
	p.Enabled = enabled
	p.require(processingTerminalFeaturesEnhancedProcessingFieldEnabled)
}

// SetTransactionDataLevel sets the TransactionDataLevel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeaturesEnhancedProcessing) SetTransactionDataLevel(transactionDataLevel *ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel) {
	p.TransactionDataLevel = transactionDataLevel
	p.require(processingTerminalFeaturesEnhancedProcessingFieldTransactionDataLevel)
}

// SetShippingAddressMode sets the ShippingAddressMode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeaturesEnhancedProcessing) SetShippingAddressMode(shippingAddressMode *ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode) {
	p.ShippingAddressMode = shippingAddressMode
	p.require(processingTerminalFeaturesEnhancedProcessingFieldShippingAddressMode)
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalFeaturesEnhancedProcessing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalFeaturesEnhancedProcessing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalFeaturesEnhancedProcessing
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalFeaturesEnhancedProcessing) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the address information that the clerk must provide to qualify for level two or level three data. The value is one of the following:
// - `fullAddress` - The clerk must provide the full address for the transaction to qualify.
// - `postalCode` - The clerk must provide a postal code for the transaction to qualify.
type ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode string

const (
	ProcessingTerminalFeaturesEnhancedProcessingShippingAddressModeFullAddress ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode = "fullAddress"
	ProcessingTerminalFeaturesEnhancedProcessingShippingAddressModePostalCode  ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode = "postalCode"
)

func NewProcessingTerminalFeaturesEnhancedProcessingShippingAddressModeFromString(s string) (ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode, error) {
	switch s {
	case "fullAddress":
		return ProcessingTerminalFeaturesEnhancedProcessingShippingAddressModeFullAddress, nil
	case "postalCode":
		return ProcessingTerminalFeaturesEnhancedProcessingShippingAddressModePostalCode, nil
	}
	var t ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode) Ptr() *ProcessingTerminalFeaturesEnhancedProcessingShippingAddressMode {
	return &p
}

// Indicates if the terminal supports level two or level three transactions.
type ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel string

const (
	ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevelLevel2 ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel = "level2"
	ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevelLevel3 ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel = "level3"
)

func NewProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevelFromString(s string) (ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel, error) {
	switch s {
	case "level2":
		return ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevelLevel2, nil
	case "level3":
		return ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevelLevel3, nil
	}
	var t ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel) Ptr() *ProcessingTerminalFeaturesEnhancedProcessingTransactionDataLevel {
	return &p
}

// Object that contains details about payment links.
var (
	processingTerminalFeaturesPaymentLinksFieldEnabled     = big.NewInt(1 << 0)
	processingTerminalFeaturesPaymentLinksFieldLogoUrl     = big.NewInt(1 << 1)
	processingTerminalFeaturesPaymentLinksFieldFooterNotes = big.NewInt(1 << 2)
)

type ProcessingTerminalFeaturesPaymentLinks struct {
	// Indicates if the terminal supports payment links.
	Enabled bool `json:"enabled" url:"enabled"`
	// URL of the logo image that the merchant wants to display in their payment link email.
	LogoUrl *string `json:"logoUrl,omitempty" url:"logoUrl,omitempty"`
	// String that the merchant wants to display on the footer of their payment link email.
	FooterNotes *string `json:"footerNotes,omitempty" url:"footerNotes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalFeaturesPaymentLinks) GetEnabled() bool {
	if p == nil {
		return false
	}
	return p.Enabled
}

func (p *ProcessingTerminalFeaturesPaymentLinks) GetLogoUrl() *string {
	if p == nil {
		return nil
	}
	return p.LogoUrl
}

func (p *ProcessingTerminalFeaturesPaymentLinks) GetFooterNotes() *string {
	if p == nil {
		return nil
	}
	return p.FooterNotes
}

func (p *ProcessingTerminalFeaturesPaymentLinks) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalFeaturesPaymentLinks) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeaturesPaymentLinks) SetEnabled(enabled bool) {
	p.Enabled = enabled
	p.require(processingTerminalFeaturesPaymentLinksFieldEnabled)
}

// SetLogoUrl sets the LogoUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeaturesPaymentLinks) SetLogoUrl(logoUrl *string) {
	p.LogoUrl = logoUrl
	p.require(processingTerminalFeaturesPaymentLinksFieldLogoUrl)
}

// SetFooterNotes sets the FooterNotes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalFeaturesPaymentLinks) SetFooterNotes(footerNotes *string) {
	p.FooterNotes = footerNotes
	p.require(processingTerminalFeaturesPaymentLinksFieldFooterNotes)
}

func (p *ProcessingTerminalFeaturesPaymentLinks) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalFeaturesPaymentLinks
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalFeaturesPaymentLinks(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalFeaturesPaymentLinks) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalFeaturesPaymentLinks
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalFeaturesPaymentLinks) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Polymorphic object that indicates if the terminal accepts tips.
//
// The value of the enabled field determines which variant you should use:
// -	`true` - Terminal allows tips.
// -	`false` - Terminal doesn't allow tips.
type ProcessingTerminalFeaturesTips struct {
	TipProcessingEnabled  *TipProcessingEnabled
	TipProcessingDisabled *TipProcessingDisabled

	typ string
}

func (p *ProcessingTerminalFeaturesTips) GetTipProcessingEnabled() *TipProcessingEnabled {
	if p == nil {
		return nil
	}
	return p.TipProcessingEnabled
}

func (p *ProcessingTerminalFeaturesTips) GetTipProcessingDisabled() *TipProcessingDisabled {
	if p == nil {
		return nil
	}
	return p.TipProcessingDisabled
}

func (p *ProcessingTerminalFeaturesTips) UnmarshalJSON(data []byte) error {
	valueTipProcessingEnabled := new(TipProcessingEnabled)
	if err := json.Unmarshal(data, &valueTipProcessingEnabled); err == nil {
		p.typ = "TipProcessingEnabled"
		p.TipProcessingEnabled = valueTipProcessingEnabled
		return nil
	}
	valueTipProcessingDisabled := new(TipProcessingDisabled)
	if err := json.Unmarshal(data, &valueTipProcessingDisabled); err == nil {
		p.typ = "TipProcessingDisabled"
		p.TipProcessingDisabled = valueTipProcessingDisabled
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, p)
}

func (p ProcessingTerminalFeaturesTips) MarshalJSON() ([]byte, error) {
	if p.typ == "TipProcessingEnabled" || p.TipProcessingEnabled != nil {
		return json.Marshal(p.TipProcessingEnabled)
	}
	if p.typ == "TipProcessingDisabled" || p.TipProcessingDisabled != nil {
		return json.Marshal(p.TipProcessingDisabled)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", p)
}

type ProcessingTerminalFeaturesTipsVisitor interface {
	VisitTipProcessingEnabled(*TipProcessingEnabled) error
	VisitTipProcessingDisabled(*TipProcessingDisabled) error
}

func (p *ProcessingTerminalFeaturesTips) Accept(visitor ProcessingTerminalFeaturesTipsVisitor) error {
	if p.typ == "TipProcessingEnabled" || p.TipProcessingEnabled != nil {
		return visitor.VisitTipProcessingEnabled(p.TipProcessingEnabled)
	}
	if p.typ == "TipProcessingDisabled" || p.TipProcessingDisabled != nil {
		return visitor.VisitTipProcessingDisabled(p.TipProcessingDisabled)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", p)
}

// Object that indicates if the terminal can send email receipts or text receipts.
var (
	processingTerminalReceiptNotificationsFieldEmailReceipt = big.NewInt(1 << 0)
	processingTerminalReceiptNotificationsFieldSmsReceipt   = big.NewInt(1 << 1)
)

type ProcessingTerminalReceiptNotifications struct {
	// Indicates if the terminal can send receipts by email.
	EmailReceipt *bool `json:"emailReceipt,omitempty" url:"emailReceipt,omitempty"`
	// Indicates if the terminal can send receipts by text message.
	SmsReceipt *bool `json:"smsReceipt,omitempty" url:"smsReceipt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalReceiptNotifications) GetEmailReceipt() *bool {
	if p == nil {
		return nil
	}
	return p.EmailReceipt
}

func (p *ProcessingTerminalReceiptNotifications) GetSmsReceipt() *bool {
	if p == nil {
		return nil
	}
	return p.SmsReceipt
}

func (p *ProcessingTerminalReceiptNotifications) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalReceiptNotifications) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetEmailReceipt sets the EmailReceipt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalReceiptNotifications) SetEmailReceipt(emailReceipt *bool) {
	p.EmailReceipt = emailReceipt
	p.require(processingTerminalReceiptNotificationsFieldEmailReceipt)
}

// SetSmsReceipt sets the SmsReceipt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalReceiptNotifications) SetSmsReceipt(smsReceipt *bool) {
	p.SmsReceipt = smsReceipt
	p.require(processingTerminalReceiptNotificationsFieldSmsReceipt)
}

func (p *ProcessingTerminalReceiptNotifications) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalReceiptNotifications
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalReceiptNotifications(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalReceiptNotifications) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalReceiptNotifications
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalReceiptNotifications) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains the tokenization settings and AVS settings for the terminal.
var (
	processingTerminalSecurityFieldTokenization = big.NewInt(1 << 0)
	processingTerminalSecurityFieldAvsPrompt    = big.NewInt(1 << 1)
	processingTerminalSecurityFieldAvsLevel     = big.NewInt(1 << 2)
	processingTerminalSecurityFieldCvvPrompt    = big.NewInt(1 << 3)
)

type ProcessingTerminalSecurity struct {
	// Indicates if the terminal can tokenize customer's payment details. For more information about tokenization, go to [Tokenization](https://docs.payroc.com/knowledge/basic-concepts/tokenization).
	Tokenization bool `json:"tokenization" url:"tokenization"`
	// Indicates if the terminal should prompt for Address Verification Service (AVS) details when running a transaction.
	AvsPrompt bool `json:"avsPrompt" url:"avsPrompt"`
	// Indicates the level of AVS details that the terminal should prompt for.
	AvsLevel *ProcessingTerminalSecurityAvsLevel `json:"avsLevel,omitempty" url:"avsLevel,omitempty"`
	// Indicates if the terminal should prompt for a Card Verfication Value (CVV) when running a transaction.
	CvvPrompt bool `json:"cvvPrompt" url:"cvvPrompt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalSecurity) GetTokenization() bool {
	if p == nil {
		return false
	}
	return p.Tokenization
}

func (p *ProcessingTerminalSecurity) GetAvsPrompt() bool {
	if p == nil {
		return false
	}
	return p.AvsPrompt
}

func (p *ProcessingTerminalSecurity) GetAvsLevel() *ProcessingTerminalSecurityAvsLevel {
	if p == nil {
		return nil
	}
	return p.AvsLevel
}

func (p *ProcessingTerminalSecurity) GetCvvPrompt() bool {
	if p == nil {
		return false
	}
	return p.CvvPrompt
}

func (p *ProcessingTerminalSecurity) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalSecurity) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetTokenization sets the Tokenization field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSecurity) SetTokenization(tokenization bool) {
	p.Tokenization = tokenization
	p.require(processingTerminalSecurityFieldTokenization)
}

// SetAvsPrompt sets the AvsPrompt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSecurity) SetAvsPrompt(avsPrompt bool) {
	p.AvsPrompt = avsPrompt
	p.require(processingTerminalSecurityFieldAvsPrompt)
}

// SetAvsLevel sets the AvsLevel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSecurity) SetAvsLevel(avsLevel *ProcessingTerminalSecurityAvsLevel) {
	p.AvsLevel = avsLevel
	p.require(processingTerminalSecurityFieldAvsLevel)
}

// SetCvvPrompt sets the CvvPrompt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSecurity) SetCvvPrompt(cvvPrompt bool) {
	p.CvvPrompt = cvvPrompt
	p.require(processingTerminalSecurityFieldCvvPrompt)
}

func (p *ProcessingTerminalSecurity) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalSecurity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalSecurity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalSecurity) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalSecurity
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalSecurity) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the level of AVS details that the terminal should prompt for.
type ProcessingTerminalSecurityAvsLevel string

const (
	ProcessingTerminalSecurityAvsLevelFullAddress ProcessingTerminalSecurityAvsLevel = "fullAddress"
	ProcessingTerminalSecurityAvsLevelPostalCode  ProcessingTerminalSecurityAvsLevel = "postalCode"
)

func NewProcessingTerminalSecurityAvsLevelFromString(s string) (ProcessingTerminalSecurityAvsLevel, error) {
	switch s {
	case "fullAddress":
		return ProcessingTerminalSecurityAvsLevelFullAddress, nil
	case "postalCode":
		return ProcessingTerminalSecurityAvsLevelPostalCode, nil
	}
	var t ProcessingTerminalSecurityAvsLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingTerminalSecurityAvsLevel) Ptr() *ProcessingTerminalSecurityAvsLevel {
	return &p
}

// Indicates if the processing terminal is active.
type ProcessingTerminalStatus string

const (
	ProcessingTerminalStatusActive   ProcessingTerminalStatus = "active"
	ProcessingTerminalStatusInactive ProcessingTerminalStatus = "inactive"
)

func NewProcessingTerminalStatusFromString(s string) (ProcessingTerminalStatus, error) {
	switch s {
	case "active":
		return ProcessingTerminalStatusActive, nil
	case "inactive":
		return ProcessingTerminalStatusInactive, nil
	}
	var t ProcessingTerminalStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingTerminalStatus) Ptr() *ProcessingTerminalStatus {
	return &p
}

// Object that contains information about the processing terminal.
var (
	processingTerminalSummaryFieldProcessingTerminalId = big.NewInt(1 << 0)
	processingTerminalSummaryFieldLink                 = big.NewInt(1 << 1)
)

type ProcessingTerminalSummary struct {
	// Unique identifier that we assigned to the processing terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Array of links related to your request. For more information about HATEOAS, go to [Hypermedia as the engine of application state](https://docs.payroc.com/knowledge/basic-concepts/hypermedia-as-the-engine-of-application-state-hateoas).
	Link *ProcessingTerminalSummaryLink `json:"link" url:"link"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalSummary) GetProcessingTerminalId() string {
	if p == nil {
		return ""
	}
	return p.ProcessingTerminalId
}

func (p *ProcessingTerminalSummary) GetLink() *ProcessingTerminalSummaryLink {
	if p == nil {
		return nil
	}
	return p.Link
}

func (p *ProcessingTerminalSummary) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalSummary) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSummary) SetProcessingTerminalId(processingTerminalId string) {
	p.ProcessingTerminalId = processingTerminalId
	p.require(processingTerminalSummaryFieldProcessingTerminalId)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSummary) SetLink(link *ProcessingTerminalSummaryLink) {
	p.Link = link
	p.require(processingTerminalSummaryFieldLink)
}

func (p *ProcessingTerminalSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalSummary) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalSummary) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Array of links related to your request. For more information about HATEOAS, go to [Hypermedia as the engine of application state](https://docs.payroc.com/knowledge/basic-concepts/hypermedia-as-the-engine-of-application-state-hateoas).
var (
	processingTerminalSummaryLinkFieldHref   = big.NewInt(1 << 0)
	processingTerminalSummaryLinkFieldRel    = big.NewInt(1 << 1)
	processingTerminalSummaryLinkFieldMethod = big.NewInt(1 << 2)
)

type ProcessingTerminalSummaryLink struct {
	// URL of the target resource.
	Href string `json:"href" url:"href"`
	// Indicates the relationship between the current resource and the target resource.
	Rel string `json:"rel" url:"rel"`
	// HTTP method that you need to use with the target resource.
	Method string `json:"method" url:"method"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalSummaryLink) GetHref() string {
	if p == nil {
		return ""
	}
	return p.Href
}

func (p *ProcessingTerminalSummaryLink) GetRel() string {
	if p == nil {
		return ""
	}
	return p.Rel
}

func (p *ProcessingTerminalSummaryLink) GetMethod() string {
	if p == nil {
		return ""
	}
	return p.Method
}

func (p *ProcessingTerminalSummaryLink) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalSummaryLink) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetHref sets the Href field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSummaryLink) SetHref(href string) {
	p.Href = href
	p.require(processingTerminalSummaryLinkFieldHref)
}

// SetRel sets the Rel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSummaryLink) SetRel(rel string) {
	p.Rel = rel
	p.require(processingTerminalSummaryLinkFieldRel)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalSummaryLink) SetMethod(method string) {
	p.Method = method
	p.require(processingTerminalSummaryLinkFieldMethod)
}

func (p *ProcessingTerminalSummaryLink) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalSummaryLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalSummaryLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalSummaryLink) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalSummaryLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalSummaryLink) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains a tax rate with a short description of the tax rate.
var (
	processingTerminalTaxesItemFieldTaxRate  = big.NewInt(1 << 0)
	processingTerminalTaxesItemFieldTaxLabel = big.NewInt(1 << 1)
)

type ProcessingTerminalTaxesItem struct {
	// Rate of tax that the terminal applies to each transaction.
	TaxRate float64 `json:"taxRate" url:"taxRate"`
	// Short description of the tax rate, for example, "Sales Tax".
	TaxLabel string `json:"taxLabel" url:"taxLabel"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTerminalTaxesItem) GetTaxRate() float64 {
	if p == nil {
		return 0
	}
	return p.TaxRate
}

func (p *ProcessingTerminalTaxesItem) GetTaxLabel() string {
	if p == nil {
		return ""
	}
	return p.TaxLabel
}

func (p *ProcessingTerminalTaxesItem) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTerminalTaxesItem) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetTaxRate sets the TaxRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalTaxesItem) SetTaxRate(taxRate float64) {
	p.TaxRate = taxRate
	p.require(processingTerminalTaxesItemFieldTaxRate)
}

// SetTaxLabel sets the TaxLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTerminalTaxesItem) SetTaxLabel(taxLabel string) {
	p.TaxLabel = taxLabel
	p.require(processingTerminalTaxesItemFieldTaxLabel)
}

func (p *ProcessingTerminalTaxesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTerminalTaxesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTerminalTaxesItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTerminalTaxesItem) MarshalJSON() ([]byte, error) {
	type embed ProcessingTerminalTaxesItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTerminalTaxesItem) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Time zone of the processing terminal.
type ProcessingTerminalTimezone string

const (
	ProcessingTerminalTimezonePacificMidway              ProcessingTerminalTimezone = "Pacific/Midway"
	ProcessingTerminalTimezonePacificHonolulu            ProcessingTerminalTimezone = "Pacific/Honolulu"
	ProcessingTerminalTimezoneAmericaAnchorage           ProcessingTerminalTimezone = "America/Anchorage"
	ProcessingTerminalTimezoneAmericaLosAngeles          ProcessingTerminalTimezone = "America/Los_Angeles"
	ProcessingTerminalTimezoneAmericaDenver              ProcessingTerminalTimezone = "America/Denver"
	ProcessingTerminalTimezoneAmericaPhoenix             ProcessingTerminalTimezone = "America/Phoenix"
	ProcessingTerminalTimezoneAmericaChicago             ProcessingTerminalTimezone = "America/Chicago"
	ProcessingTerminalTimezoneAmericaIndianaIndianapolis ProcessingTerminalTimezone = "America/Indiana/Indianapolis"
	ProcessingTerminalTimezoneAmericaNewYork             ProcessingTerminalTimezone = "America/New_York"
)

func NewProcessingTerminalTimezoneFromString(s string) (ProcessingTerminalTimezone, error) {
	switch s {
	case "Pacific/Midway":
		return ProcessingTerminalTimezonePacificMidway, nil
	case "Pacific/Honolulu":
		return ProcessingTerminalTimezonePacificHonolulu, nil
	case "America/Anchorage":
		return ProcessingTerminalTimezoneAmericaAnchorage, nil
	case "America/Los_Angeles":
		return ProcessingTerminalTimezoneAmericaLosAngeles, nil
	case "America/Denver":
		return ProcessingTerminalTimezoneAmericaDenver, nil
	case "America/Phoenix":
		return ProcessingTerminalTimezoneAmericaPhoenix, nil
	case "America/Chicago":
		return ProcessingTerminalTimezoneAmericaChicago, nil
	case "America/Indiana/Indianapolis":
		return ProcessingTerminalTimezoneAmericaIndianaIndianapolis, nil
	case "America/New_York":
		return ProcessingTerminalTimezoneAmericaNewYork, nil
	}
	var t ProcessingTerminalTimezone
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProcessingTerminalTimezone) Ptr() *ProcessingTerminalTimezone {
	return &p
}

// Object that contains information about transaction amounts for the processing account.
var (
	processingTransactionAmountsFieldAverage = big.NewInt(1 << 0)
	processingTransactionAmountsFieldHighest = big.NewInt(1 << 1)
)

type ProcessingTransactionAmounts struct {
	// Estimated average transaction amount. The value is in the currency's lowest denomination, for example, cents. You must provide an amount that is greater than zero.
	Average int `json:"average" url:"average"`
	// Estimated maximum transaction amount. The value is in the currency's lowest denomination, for example, cents. You must provide an amount that is greater than zero.
	Highest int `json:"highest" url:"highest"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingTransactionAmounts) GetAverage() int {
	if p == nil {
		return 0
	}
	return p.Average
}

func (p *ProcessingTransactionAmounts) GetHighest() int {
	if p == nil {
		return 0
	}
	return p.Highest
}

func (p *ProcessingTransactionAmounts) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingTransactionAmounts) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetAverage sets the Average field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTransactionAmounts) SetAverage(average int) {
	p.Average = average
	p.require(processingTransactionAmountsFieldAverage)
}

// SetHighest sets the Highest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingTransactionAmounts) SetHighest(highest int) {
	p.Highest = highest
	p.require(processingTransactionAmountsFieldHighest)
}

func (p *ProcessingTransactionAmounts) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingTransactionAmounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingTransactionAmounts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingTransactionAmounts) MarshalJSON() ([]byte, error) {
	type embed ProcessingTransactionAmounts
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingTransactionAmounts) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the types of transactions ran by the processing account. The percentages for transaction types must total 100%.
var (
	processingVolumeBreakdownFieldCardPresent     = big.NewInt(1 << 0)
	processingVolumeBreakdownFieldMailOrTelephone = big.NewInt(1 << 1)
	processingVolumeBreakdownFieldEcommerce       = big.NewInt(1 << 2)
)

type ProcessingVolumeBreakdown struct {
	// Estimated percentage of card-present transactions.
	CardPresent int `json:"cardPresent" url:"cardPresent"`
	// Estimated percentage of mail order or telephone transactions.
	MailOrTelephone int `json:"mailOrTelephone" url:"mailOrTelephone"`
	// Estimated percentage of e-Commerce transactions.
	Ecommerce int `json:"ecommerce" url:"ecommerce"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingVolumeBreakdown) GetCardPresent() int {
	if p == nil {
		return 0
	}
	return p.CardPresent
}

func (p *ProcessingVolumeBreakdown) GetMailOrTelephone() int {
	if p == nil {
		return 0
	}
	return p.MailOrTelephone
}

func (p *ProcessingVolumeBreakdown) GetEcommerce() int {
	if p == nil {
		return 0
	}
	return p.Ecommerce
}

func (p *ProcessingVolumeBreakdown) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingVolumeBreakdown) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetCardPresent sets the CardPresent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingVolumeBreakdown) SetCardPresent(cardPresent int) {
	p.CardPresent = cardPresent
	p.require(processingVolumeBreakdownFieldCardPresent)
}

// SetMailOrTelephone sets the MailOrTelephone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingVolumeBreakdown) SetMailOrTelephone(mailOrTelephone int) {
	p.MailOrTelephone = mailOrTelephone
	p.require(processingVolumeBreakdownFieldMailOrTelephone)
}

// SetEcommerce sets the Ecommerce field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessingVolumeBreakdown) SetEcommerce(ecommerce int) {
	p.Ecommerce = ecommerce
	p.require(processingVolumeBreakdownFieldEcommerce)
}

func (p *ProcessingVolumeBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingVolumeBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingVolumeBreakdown(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingVolumeBreakdown) MarshalJSON() ([]byte, error) {
	type embed ProcessingVolumeBreakdown
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessingVolumeBreakdown) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Object that contains information about the processor fees.
var (
	processorFeeFieldVolume      = big.NewInt(1 << 0)
	processorFeeFieldTransaction = big.NewInt(1 << 1)
)

type ProcessorFee struct {
	// Percentage of total transaction amount that the processor charges the merchant.
	Volume *Percentage `json:"volume,omitempty" url:"volume,omitempty"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction *Amount `json:"transaction,omitempty" url:"transaction,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessorFee) GetVolume() *Percentage {
	if p == nil {
		return nil
	}
	return p.Volume
}

func (p *ProcessorFee) GetTransaction() *Amount {
	if p == nil {
		return nil
	}
	return p.Transaction
}

func (p *ProcessorFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessorFee) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetVolume sets the Volume field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessorFee) SetVolume(volume *Percentage) {
	p.Volume = volume
	p.require(processorFeeFieldVolume)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *ProcessorFee) SetTransaction(transaction *Amount) {
	p.Transaction = transaction
	p.require(processorFeeFieldTransaction)
}

func (p *ProcessorFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessorFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessorFee(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessorFee) MarshalJSON() ([]byte, error) {
	type embed ProcessorFee
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *ProcessorFee) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	qualRatesFieldQualifiedRate = big.NewInt(1 << 0)
	qualRatesFieldMidQualRate   = big.NewInt(1 << 1)
	qualRatesFieldNonQualRate   = big.NewInt(1 << 2)
)

type QualRates struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QualRates) GetQualifiedRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.QualifiedRate
}

func (q *QualRates) GetMidQualRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.MidQualRate
}

func (q *QualRates) GetNonQualRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.NonQualRate
}

func (q *QualRates) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QualRates) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRates) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	q.QualifiedRate = qualifiedRate
	q.require(qualRatesFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRates) SetMidQualRate(midQualRate *ProcessorFee) {
	q.MidQualRate = midQualRate
	q.require(qualRatesFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRates) SetNonQualRate(nonQualRate *ProcessorFee) {
	q.NonQualRate = nonQualRate
	q.require(qualRatesFieldNonQualRate)
}

func (q *QualRates) UnmarshalJSON(data []byte) error {
	type unmarshaler QualRates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QualRates(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QualRates) MarshalJSON() ([]byte, error) {
	type embed QualRates
	var marshaler = struct {
		embed
	}{
		embed: embed(*q),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, q.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (q *QualRates) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

var (
	qualRatesWithPremiumFieldQualifiedRate = big.NewInt(1 << 0)
	qualRatesWithPremiumFieldMidQualRate   = big.NewInt(1 << 1)
	qualRatesWithPremiumFieldNonQualRate   = big.NewInt(1 << 2)
	qualRatesWithPremiumFieldPremiumRate   = big.NewInt(1 << 3)
)

type QualRatesWithPremium struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`
	// Object that contains the fees for a premium rate transaction.
	PremiumRate *ProcessorFee `json:"premiumRate" url:"premiumRate"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QualRatesWithPremium) GetQualifiedRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.QualifiedRate
}

func (q *QualRatesWithPremium) GetMidQualRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.MidQualRate
}

func (q *QualRatesWithPremium) GetNonQualRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.NonQualRate
}

func (q *QualRatesWithPremium) GetPremiumRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.PremiumRate
}

func (q *QualRatesWithPremium) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QualRatesWithPremium) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremium) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	q.QualifiedRate = qualifiedRate
	q.require(qualRatesWithPremiumFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremium) SetMidQualRate(midQualRate *ProcessorFee) {
	q.MidQualRate = midQualRate
	q.require(qualRatesWithPremiumFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremium) SetNonQualRate(nonQualRate *ProcessorFee) {
	q.NonQualRate = nonQualRate
	q.require(qualRatesWithPremiumFieldNonQualRate)
}

// SetPremiumRate sets the PremiumRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremium) SetPremiumRate(premiumRate *ProcessorFee) {
	q.PremiumRate = premiumRate
	q.require(qualRatesWithPremiumFieldPremiumRate)
}

func (q *QualRatesWithPremium) UnmarshalJSON(data []byte) error {
	type unmarshaler QualRatesWithPremium
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QualRatesWithPremium(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QualRatesWithPremium) MarshalJSON() ([]byte, error) {
	type embed QualRatesWithPremium
	var marshaler = struct {
		embed
	}{
		embed: embed(*q),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, q.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (q *QualRatesWithPremium) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

var (
	qualRatesWithPremiumAndRegulatedFieldQualifiedRate        = big.NewInt(1 << 0)
	qualRatesWithPremiumAndRegulatedFieldMidQualRate          = big.NewInt(1 << 1)
	qualRatesWithPremiumAndRegulatedFieldNonQualRate          = big.NewInt(1 << 2)
	qualRatesWithPremiumAndRegulatedFieldPremiumRate          = big.NewInt(1 << 3)
	qualRatesWithPremiumAndRegulatedFieldRegulatedCheckCard   = big.NewInt(1 << 4)
	qualRatesWithPremiumAndRegulatedFieldUnregulatedCheckCard = big.NewInt(1 << 5)
)

type QualRatesWithPremiumAndRegulated struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`
	// Object that contains the fees for a premium rate transaction.
	PremiumRate *ProcessorFee `json:"premiumRate" url:"premiumRate"`
	// Object that contains the fees for a regulated debit-card transaction.
	RegulatedCheckCard *ProcessorFee `json:"regulatedCheckCard" url:"regulatedCheckCard"`
	// Object that contains the fees for an unregulated debit-card transaction.
	UnregulatedCheckCard *ProcessorFee `json:"unregulatedCheckCard" url:"unregulatedCheckCard"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QualRatesWithPremiumAndRegulated) GetQualifiedRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.QualifiedRate
}

func (q *QualRatesWithPremiumAndRegulated) GetMidQualRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.MidQualRate
}

func (q *QualRatesWithPremiumAndRegulated) GetNonQualRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.NonQualRate
}

func (q *QualRatesWithPremiumAndRegulated) GetPremiumRate() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.PremiumRate
}

func (q *QualRatesWithPremiumAndRegulated) GetRegulatedCheckCard() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.RegulatedCheckCard
}

func (q *QualRatesWithPremiumAndRegulated) GetUnregulatedCheckCard() *ProcessorFee {
	if q == nil {
		return nil
	}
	return q.UnregulatedCheckCard
}

func (q *QualRatesWithPremiumAndRegulated) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QualRatesWithPremiumAndRegulated) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremiumAndRegulated) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	q.QualifiedRate = qualifiedRate
	q.require(qualRatesWithPremiumAndRegulatedFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremiumAndRegulated) SetMidQualRate(midQualRate *ProcessorFee) {
	q.MidQualRate = midQualRate
	q.require(qualRatesWithPremiumAndRegulatedFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremiumAndRegulated) SetNonQualRate(nonQualRate *ProcessorFee) {
	q.NonQualRate = nonQualRate
	q.require(qualRatesWithPremiumAndRegulatedFieldNonQualRate)
}

// SetPremiumRate sets the PremiumRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremiumAndRegulated) SetPremiumRate(premiumRate *ProcessorFee) {
	q.PremiumRate = premiumRate
	q.require(qualRatesWithPremiumAndRegulatedFieldPremiumRate)
}

// SetRegulatedCheckCard sets the RegulatedCheckCard field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremiumAndRegulated) SetRegulatedCheckCard(regulatedCheckCard *ProcessorFee) {
	q.RegulatedCheckCard = regulatedCheckCard
	q.require(qualRatesWithPremiumAndRegulatedFieldRegulatedCheckCard)
}

// SetUnregulatedCheckCard sets the UnregulatedCheckCard field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QualRatesWithPremiumAndRegulated) SetUnregulatedCheckCard(unregulatedCheckCard *ProcessorFee) {
	q.UnregulatedCheckCard = unregulatedCheckCard
	q.require(qualRatesWithPremiumAndRegulatedFieldUnregulatedCheckCard)
}

func (q *QualRatesWithPremiumAndRegulated) UnmarshalJSON(data []byte) error {
	type unmarshaler QualRatesWithPremiumAndRegulated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QualRatesWithPremiumAndRegulated(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QualRatesWithPremiumAndRegulated) MarshalJSON() ([]byte, error) {
	type embed QualRatesWithPremiumAndRegulated
	var marshaler = struct {
		embed
	}{
		embed: embed(*q),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, q.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (q *QualRatesWithPremiumAndRegulated) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Object that contains information about the unencrypted card details.
var (
	rawCardDetailsFieldDowngradeTo         = big.NewInt(1 << 0)
	rawCardDetailsFieldDevice              = big.NewInt(1 << 1)
	rawCardDetailsFieldRawData             = big.NewInt(1 << 2)
	rawCardDetailsFieldCardholderSignature = big.NewInt(1 << 3)
)

type RawCardDetails struct {
	// If an offline transaction is not approved using the initial entry method, reprocess the transaction using a downgraded entry method.
	// For example, an Integrated Circuit Card (ICC) transaction can be downgraded to a swiped transaction or to a keyed transaction.
	DowngradeTo *RawCardDetailsDowngradeTo `json:"downgradeTo,omitempty" url:"downgradeTo,omitempty"`
	Device      *Device                    `json:"device" url:"device"`
	// Unencrypted data from the POS terminal.
	RawData string `json:"rawData" url:"rawData"`
	// Cardholder's signature. For more information about how to format the signature, go to [How to send a signature to our gateway](https://docs.payroc.com/knowledge/basic-concepts/signature-capture).
	CardholderSignature *string `json:"cardholderSignature,omitempty" url:"cardholderSignature,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RawCardDetails) GetDowngradeTo() *RawCardDetailsDowngradeTo {
	if r == nil {
		return nil
	}
	return r.DowngradeTo
}

func (r *RawCardDetails) GetDevice() *Device {
	if r == nil {
		return nil
	}
	return r.Device
}

func (r *RawCardDetails) GetRawData() string {
	if r == nil {
		return ""
	}
	return r.RawData
}

func (r *RawCardDetails) GetCardholderSignature() *string {
	if r == nil {
		return nil
	}
	return r.CardholderSignature
}

func (r *RawCardDetails) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawCardDetails) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetDowngradeTo sets the DowngradeTo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RawCardDetails) SetDowngradeTo(downgradeTo *RawCardDetailsDowngradeTo) {
	r.DowngradeTo = downgradeTo
	r.require(rawCardDetailsFieldDowngradeTo)
}

// SetDevice sets the Device field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RawCardDetails) SetDevice(device *Device) {
	r.Device = device
	r.require(rawCardDetailsFieldDevice)
}

// SetRawData sets the RawData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RawCardDetails) SetRawData(rawData string) {
	r.RawData = rawData
	r.require(rawCardDetailsFieldRawData)
}

// SetCardholderSignature sets the CardholderSignature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RawCardDetails) SetCardholderSignature(cardholderSignature *string) {
	r.CardholderSignature = cardholderSignature
	r.require(rawCardDetailsFieldCardholderSignature)
}

func (r *RawCardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler RawCardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawCardDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawCardDetails) MarshalJSON() ([]byte, error) {
	type embed RawCardDetails
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RawCardDetails) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// If an offline transaction is not approved using the initial entry method, reprocess the transaction using a downgraded entry method.
// For example, an Integrated Circuit Card (ICC) transaction can be downgraded to a swiped transaction or to a keyed transaction.
type RawCardDetailsDowngradeTo string

const (
	RawCardDetailsDowngradeToKeyed  RawCardDetailsDowngradeTo = "keyed"
	RawCardDetailsDowngradeToSwiped RawCardDetailsDowngradeTo = "swiped"
)

func NewRawCardDetailsDowngradeToFromString(s string) (RawCardDetailsDowngradeTo, error) {
	switch s {
	case "keyed":
		return RawCardDetailsDowngradeToKeyed, nil
	case "swiped":
		return RawCardDetailsDowngradeToSwiped, nil
	}
	var t RawCardDetailsDowngradeTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RawCardDetailsDowngradeTo) Ptr() *RawCardDetailsDowngradeTo {
	return &r
}

// Object that contains information about the unencrypted PIN details.
var (
	rawPinDetailsFieldPin = big.NewInt(1 << 0)
)

type RawPinDetails struct {
	// Customer’s unencrypted PIN.
	Pin string `json:"pin" url:"pin"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RawPinDetails) GetPin() string {
	if r == nil {
		return ""
	}
	return r.Pin
}

func (r *RawPinDetails) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RawPinDetails) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetPin sets the Pin field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RawPinDetails) SetPin(pin string) {
	r.Pin = pin
	r.require(rawPinDetailsFieldPin)
}

func (r *RawPinDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler RawPinDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RawPinDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RawPinDetails) MarshalJSON() ([]byte, error) {
	type embed RawPinDetails
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RawPinDetails) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	refundInstructionFieldStatus              = big.NewInt(1 << 0)
	refundInstructionFieldErrorMessage        = big.NewInt(1 << 1)
	refundInstructionFieldLink                = big.NewInt(1 << 2)
	refundInstructionFieldRefundInstructionId = big.NewInt(1 << 3)
)

type RefundInstruction struct {
	// Indicates the current status of the instruction.
	// - `canceled` – The instruction was canceled before it was completed.
	// - `completed` – The instruction has completed. Use the link object to check the resource.
	// - `failure` – The instruction failed. Check the errorMessage field for more information.
	// - `inProgress` – The instruction is currently in progress.
	Status *DeviceInstructionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Description of the error that caused the instruction to fail.
	//
	// **Note:** We return this field only if the status is `failure`.
	ErrorMessage *string `json:"errorMessage,omitempty" url:"errorMessage,omitempty"`
	Link         *Link   `json:"link,omitempty" url:"link,omitempty"`
	// Unique identifier that we assigned to the refund instruction.
	RefundInstructionId *string `json:"refundInstructionId,omitempty" url:"refundInstructionId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundInstruction) GetStatus() *DeviceInstructionStatus {
	if r == nil {
		return nil
	}
	return r.Status
}

func (r *RefundInstruction) GetErrorMessage() *string {
	if r == nil {
		return nil
	}
	return r.ErrorMessage
}

func (r *RefundInstruction) GetLink() *Link {
	if r == nil {
		return nil
	}
	return r.Link
}

func (r *RefundInstruction) GetRefundInstructionId() *string {
	if r == nil {
		return nil
	}
	return r.RefundInstructionId
}

func (r *RefundInstruction) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundInstruction) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstruction) SetStatus(status *DeviceInstructionStatus) {
	r.Status = status
	r.require(refundInstructionFieldStatus)
}

// SetErrorMessage sets the ErrorMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstruction) SetErrorMessage(errorMessage *string) {
	r.ErrorMessage = errorMessage
	r.require(refundInstructionFieldErrorMessage)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstruction) SetLink(link *Link) {
	r.Link = link
	r.require(refundInstructionFieldLink)
}

// SetRefundInstructionId sets the RefundInstructionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstruction) SetRefundInstructionId(refundInstructionId *string) {
	r.RefundInstructionId = refundInstructionId
	r.require(refundInstructionFieldRefundInstructionId)
}

func (r *RefundInstruction) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundInstruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundInstruction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundInstruction) MarshalJSON() ([]byte, error) {
	type embed RefundInstruction
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RefundInstruction) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about the refund.
var (
	refundInstructionOrderFieldOrderId     = big.NewInt(1 << 0)
	refundInstructionOrderFieldDateTime    = big.NewInt(1 << 1)
	refundInstructionOrderFieldDescription = big.NewInt(1 << 2)
	refundInstructionOrderFieldAmount      = big.NewInt(1 << 3)
	refundInstructionOrderFieldCurrency    = big.NewInt(1 << 4)
)

type RefundInstructionOrder struct {
	// Unique identifier that the merchant assigns to the transaction.
	OrderId string `json:"orderId" url:"orderId"`
	// Date and time that the processor processed the transaction. Our gateway returns this value in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Total amount of the transaction. The value is in the currency’s lowest denomination, for example, cents.
	Amount   int64    `json:"amount" url:"amount"`
	Currency Currency `json:"currency" url:"currency"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundInstructionOrder) GetOrderId() string {
	if r == nil {
		return ""
	}
	return r.OrderId
}

func (r *RefundInstructionOrder) GetDateTime() *time.Time {
	if r == nil {
		return nil
	}
	return r.DateTime
}

func (r *RefundInstructionOrder) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RefundInstructionOrder) GetAmount() int64 {
	if r == nil {
		return 0
	}
	return r.Amount
}

func (r *RefundInstructionOrder) GetCurrency() Currency {
	if r == nil {
		return ""
	}
	return r.Currency
}

func (r *RefundInstructionOrder) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundInstructionOrder) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstructionOrder) SetOrderId(orderId string) {
	r.OrderId = orderId
	r.require(refundInstructionOrderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstructionOrder) SetDateTime(dateTime *time.Time) {
	r.DateTime = dateTime
	r.require(refundInstructionOrderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstructionOrder) SetDescription(description *string) {
	r.Description = description
	r.require(refundInstructionOrderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstructionOrder) SetAmount(amount int64) {
	r.Amount = amount
	r.require(refundInstructionOrderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundInstructionOrder) SetCurrency(currency Currency) {
	r.Currency = currency
	r.require(refundInstructionOrderFieldCurrency)
}

func (r *RefundInstructionOrder) UnmarshalJSON(data []byte) error {
	type embed RefundInstructionOrder
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RefundInstructionOrder(unmarshaler.embed)
	r.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundInstructionOrder) MarshalJSON() ([]byte, error) {
	type embed RefundInstructionOrder
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*r),
		DateTime: internal.NewOptionalDateTime(r.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RefundInstructionOrder) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about the refund.
var (
	refundOrderFieldOrderId     = big.NewInt(1 << 0)
	refundOrderFieldDateTime    = big.NewInt(1 << 1)
	refundOrderFieldDescription = big.NewInt(1 << 2)
	refundOrderFieldAmount      = big.NewInt(1 << 3)
	refundOrderFieldCurrency    = big.NewInt(1 << 4)
	refundOrderFieldDccOffer    = big.NewInt(1 << 5)
)

type RefundOrder struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Date and time that our gateway processed the refund. The value follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.
	DateTime *time.Time `json:"dateTime,omitempty" url:"dateTime,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Amount of the refund. The value is in the currency's lowest denomination, for example, cents.
	Amount   *int64    `json:"amount,omitempty" url:"amount,omitempty"`
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	DccOffer *DccOffer `json:"dccOffer,omitempty" url:"dccOffer,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundOrder) GetOrderId() *string {
	if r == nil {
		return nil
	}
	return r.OrderId
}

func (r *RefundOrder) GetDateTime() *time.Time {
	if r == nil {
		return nil
	}
	return r.DateTime
}

func (r *RefundOrder) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RefundOrder) GetAmount() *int64 {
	if r == nil {
		return nil
	}
	return r.Amount
}

func (r *RefundOrder) GetCurrency() *Currency {
	if r == nil {
		return nil
	}
	return r.Currency
}

func (r *RefundOrder) GetDccOffer() *DccOffer {
	if r == nil {
		return nil
	}
	return r.DccOffer
}

func (r *RefundOrder) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundOrder) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundOrder) SetOrderId(orderId *string) {
	r.OrderId = orderId
	r.require(refundOrderFieldOrderId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundOrder) SetDateTime(dateTime *time.Time) {
	r.DateTime = dateTime
	r.require(refundOrderFieldDateTime)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundOrder) SetDescription(description *string) {
	r.Description = description
	r.require(refundOrderFieldDescription)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundOrder) SetAmount(amount *int64) {
	r.Amount = amount
	r.require(refundOrderFieldAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundOrder) SetCurrency(currency *Currency) {
	r.Currency = currency
	r.require(refundOrderFieldCurrency)
}

// SetDccOffer sets the DccOffer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundOrder) SetDccOffer(dccOffer *DccOffer) {
	r.DccOffer = dccOffer
	r.require(refundOrderFieldDccOffer)
}

func (r *RefundOrder) UnmarshalJSON(data []byte) error {
	type embed RefundOrder
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RefundOrder(unmarshaler.embed)
	r.DateTime = unmarshaler.DateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundOrder) MarshalJSON() ([]byte, error) {
	type embed RefundOrder
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime,omitempty"`
	}{
		embed:    embed(*r),
		DateTime: internal.NewOptionalDateTime(r.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RefundOrder) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about refund objects.
var (
	refundPaginatedListFieldLimit   = big.NewInt(1 << 0)
	refundPaginatedListFieldCount   = big.NewInt(1 << 1)
	refundPaginatedListFieldHasMore = big.NewInt(1 << 2)
	refundPaginatedListFieldLinks   = big.NewInt(1 << 3)
	refundPaginatedListFieldData    = big.NewInt(1 << 4)
)

type RefundPaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of refund objects.
	Data []*RetrievedRefund `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundPaginatedList) GetLimit() *int {
	if r == nil {
		return nil
	}
	return r.Limit
}

func (r *RefundPaginatedList) GetCount() *int {
	if r == nil {
		return nil
	}
	return r.Count
}

func (r *RefundPaginatedList) GetHasMore() *bool {
	if r == nil {
		return nil
	}
	return r.HasMore
}

func (r *RefundPaginatedList) GetLinks() []*Link {
	if r == nil {
		return nil
	}
	return r.Links
}

func (r *RefundPaginatedList) GetData() []*RetrievedRefund {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RefundPaginatedList) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundPaginatedList) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundPaginatedList) SetLimit(limit *int) {
	r.Limit = limit
	r.require(refundPaginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundPaginatedList) SetCount(count *int) {
	r.Count = count
	r.require(refundPaginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundPaginatedList) SetHasMore(hasMore *bool) {
	r.HasMore = hasMore
	r.require(refundPaginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundPaginatedList) SetLinks(links []*Link) {
	r.Links = links
	r.require(refundPaginatedListFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundPaginatedList) SetData(data []*RetrievedRefund) {
	r.Data = data
	r.require(refundPaginatedListFieldData)
}

func (r *RefundPaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundPaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundPaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundPaginatedList) MarshalJSON() ([]byte, error) {
	type embed RefundPaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RefundPaginatedList) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about a refund.
var (
	refundSummaryFieldRefundId        = big.NewInt(1 << 0)
	refundSummaryFieldDateTime        = big.NewInt(1 << 1)
	refundSummaryFieldCurrency        = big.NewInt(1 << 2)
	refundSummaryFieldAmount          = big.NewInt(1 << 3)
	refundSummaryFieldStatus          = big.NewInt(1 << 4)
	refundSummaryFieldResponseCode    = big.NewInt(1 << 5)
	refundSummaryFieldResponseMessage = big.NewInt(1 << 6)
	refundSummaryFieldLink            = big.NewInt(1 << 7)
)

type RefundSummary struct {
	// Unique identifier of the refund.
	RefundId string `json:"refundId" url:"refundId"`
	// Date and time that the refund was processed.
	DateTime time.Time `json:"dateTime" url:"dateTime"`
	Currency Currency  `json:"currency" url:"currency"`
	// Amount of the refund. This value is in the currency’s lowest denomination, for example, cents.
	Amount int64 `json:"amount" url:"amount"`
	// Current status of the refund.
	Status RefundSummaryStatus `json:"status" url:"status"`
	// Response from the processor.
	// - `A` - The processor approved the transaction.
	// - `D` - The processor declined the transaction.
	// - `E` - The processor received the transaction but will process the transaction later.
	// - `P` - The processor authorized a portion of the original amount of the transaction.
	// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
	// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
	ResponseCode RefundSummaryResponseCode `json:"responseCode" url:"responseCode"`
	// Description of the response from the processor.
	ResponseMessage string `json:"responseMessage" url:"responseMessage"`
	Link            *Link  `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundSummary) GetRefundId() string {
	if r == nil {
		return ""
	}
	return r.RefundId
}

func (r *RefundSummary) GetDateTime() time.Time {
	if r == nil {
		return time.Time{}
	}
	return r.DateTime
}

func (r *RefundSummary) GetCurrency() Currency {
	if r == nil {
		return ""
	}
	return r.Currency
}

func (r *RefundSummary) GetAmount() int64 {
	if r == nil {
		return 0
	}
	return r.Amount
}

func (r *RefundSummary) GetStatus() RefundSummaryStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *RefundSummary) GetResponseCode() RefundSummaryResponseCode {
	if r == nil {
		return ""
	}
	return r.ResponseCode
}

func (r *RefundSummary) GetResponseMessage() string {
	if r == nil {
		return ""
	}
	return r.ResponseMessage
}

func (r *RefundSummary) GetLink() *Link {
	if r == nil {
		return nil
	}
	return r.Link
}

func (r *RefundSummary) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundSummary) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRefundId sets the RefundId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetRefundId(refundId string) {
	r.RefundId = refundId
	r.require(refundSummaryFieldRefundId)
}

// SetDateTime sets the DateTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetDateTime(dateTime time.Time) {
	r.DateTime = dateTime
	r.require(refundSummaryFieldDateTime)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetCurrency(currency Currency) {
	r.Currency = currency
	r.require(refundSummaryFieldCurrency)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetAmount(amount int64) {
	r.Amount = amount
	r.require(refundSummaryFieldAmount)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetStatus(status RefundSummaryStatus) {
	r.Status = status
	r.require(refundSummaryFieldStatus)
}

// SetResponseCode sets the ResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetResponseCode(responseCode RefundSummaryResponseCode) {
	r.ResponseCode = responseCode
	r.require(refundSummaryFieldResponseCode)
}

// SetResponseMessage sets the ResponseMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetResponseMessage(responseMessage string) {
	r.ResponseMessage = responseMessage
	r.require(refundSummaryFieldResponseMessage)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RefundSummary) SetLink(link *Link) {
	r.Link = link
	r.require(refundSummaryFieldLink)
}

func (r *RefundSummary) UnmarshalJSON(data []byte) error {
	type embed RefundSummary
	var unmarshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RefundSummary(unmarshaler.embed)
	r.DateTime = unmarshaler.DateTime.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundSummary) MarshalJSON() ([]byte, error) {
	type embed RefundSummary
	var marshaler = struct {
		embed
		DateTime *internal.DateTime `json:"dateTime"`
	}{
		embed:    embed(*r),
		DateTime: internal.NewDateTime(r.DateTime),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RefundSummary) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Response from the processor.
// - `A` - The processor approved the transaction.
// - `D` - The processor declined the transaction.
// - `E` - The processor received the transaction but will process the transaction later.
// - `P` - The processor authorized a portion of the original amount of the transaction.
// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
type RefundSummaryResponseCode string

const (
	RefundSummaryResponseCodeA RefundSummaryResponseCode = "A"
	RefundSummaryResponseCodeD RefundSummaryResponseCode = "D"
	RefundSummaryResponseCodeE RefundSummaryResponseCode = "E"
	RefundSummaryResponseCodeP RefundSummaryResponseCode = "P"
	RefundSummaryResponseCodeR RefundSummaryResponseCode = "R"
	RefundSummaryResponseCodeC RefundSummaryResponseCode = "C"
)

func NewRefundSummaryResponseCodeFromString(s string) (RefundSummaryResponseCode, error) {
	switch s {
	case "A":
		return RefundSummaryResponseCodeA, nil
	case "D":
		return RefundSummaryResponseCodeD, nil
	case "E":
		return RefundSummaryResponseCodeE, nil
	case "P":
		return RefundSummaryResponseCodeP, nil
	case "R":
		return RefundSummaryResponseCodeR, nil
	case "C":
		return RefundSummaryResponseCodeC, nil
	}
	var t RefundSummaryResponseCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefundSummaryResponseCode) Ptr() *RefundSummaryResponseCode {
	return &r
}

// Current status of the refund.
type RefundSummaryStatus string

const (
	RefundSummaryStatusReady    RefundSummaryStatus = "ready"
	RefundSummaryStatusPending  RefundSummaryStatus = "pending"
	RefundSummaryStatusDeclined RefundSummaryStatus = "declined"
	RefundSummaryStatusComplete RefundSummaryStatus = "complete"
	RefundSummaryStatusReferral RefundSummaryStatus = "referral"
	RefundSummaryStatusPickup   RefundSummaryStatus = "pickup"
	RefundSummaryStatusReversal RefundSummaryStatus = "reversal"
	RefundSummaryStatusReturned RefundSummaryStatus = "returned"
	RefundSummaryStatusAdmin    RefundSummaryStatus = "admin"
	RefundSummaryStatusExpired  RefundSummaryStatus = "expired"
	RefundSummaryStatusAccepted RefundSummaryStatus = "accepted"
)

func NewRefundSummaryStatusFromString(s string) (RefundSummaryStatus, error) {
	switch s {
	case "ready":
		return RefundSummaryStatusReady, nil
	case "pending":
		return RefundSummaryStatusPending, nil
	case "declined":
		return RefundSummaryStatusDeclined, nil
	case "complete":
		return RefundSummaryStatusComplete, nil
	case "referral":
		return RefundSummaryStatusReferral, nil
	case "pickup":
		return RefundSummaryStatusPickup, nil
	case "reversal":
		return RefundSummaryStatusReversal, nil
	case "returned":
		return RefundSummaryStatusReturned, nil
	case "admin":
		return RefundSummaryStatusAdmin, nil
	case "expired":
		return RefundSummaryStatusExpired, nil
	case "accepted":
		return RefundSummaryStatusAccepted, nil
	}
	var t RefundSummaryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefundSummaryStatus) Ptr() *RefundSummaryStatus {
	return &r
}

// Object that contains information about the address.
var (
	retrievedAddressFieldAddress1   = big.NewInt(1 << 0)
	retrievedAddressFieldAddress2   = big.NewInt(1 << 1)
	retrievedAddressFieldAddress3   = big.NewInt(1 << 2)
	retrievedAddressFieldCity       = big.NewInt(1 << 3)
	retrievedAddressFieldState      = big.NewInt(1 << 4)
	retrievedAddressFieldCountry    = big.NewInt(1 << 5)
	retrievedAddressFieldPostalCode = big.NewInt(1 << 6)
)

type RetrievedAddress struct {
	// Address line 1.
	Address1 *string `json:"address1,omitempty" url:"address1,omitempty"`
	// Address line 2.
	Address2 *string `json:"address2,omitempty" url:"address2,omitempty"`
	// Address line 3.
	Address3 *string `json:"address3,omitempty" url:"address3,omitempty"`
	// City.
	City *string `json:"city,omitempty" url:"city,omitempty"`
	// Name of the state or state abbreviation.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// Two-digit country code for the country that the business operates in. The format follows the [ISO-3166-1](https://www.iso.org/iso-3166-country-codes.html) standard.
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// Zip code or postal code.
	PostalCode *string `json:"postalCode,omitempty" url:"postalCode,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrievedAddress) GetAddress1() *string {
	if r == nil {
		return nil
	}
	return r.Address1
}

func (r *RetrievedAddress) GetAddress2() *string {
	if r == nil {
		return nil
	}
	return r.Address2
}

func (r *RetrievedAddress) GetAddress3() *string {
	if r == nil {
		return nil
	}
	return r.Address3
}

func (r *RetrievedAddress) GetCity() *string {
	if r == nil {
		return nil
	}
	return r.City
}

func (r *RetrievedAddress) GetState() *string {
	if r == nil {
		return nil
	}
	return r.State
}

func (r *RetrievedAddress) GetCountry() *string {
	if r == nil {
		return nil
	}
	return r.Country
}

func (r *RetrievedAddress) GetPostalCode() *string {
	if r == nil {
		return nil
	}
	return r.PostalCode
}

func (r *RetrievedAddress) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrievedAddress) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetAddress1 sets the Address1 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedAddress) SetAddress1(address1 *string) {
	r.Address1 = address1
	r.require(retrievedAddressFieldAddress1)
}

// SetAddress2 sets the Address2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedAddress) SetAddress2(address2 *string) {
	r.Address2 = address2
	r.require(retrievedAddressFieldAddress2)
}

// SetAddress3 sets the Address3 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedAddress) SetAddress3(address3 *string) {
	r.Address3 = address3
	r.require(retrievedAddressFieldAddress3)
}

// SetCity sets the City field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedAddress) SetCity(city *string) {
	r.City = city
	r.require(retrievedAddressFieldCity)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedAddress) SetState(state *string) {
	r.State = state
	r.require(retrievedAddressFieldState)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedAddress) SetCountry(country *string) {
	r.Country = country
	r.require(retrievedAddressFieldCountry)
}

// SetPostalCode sets the PostalCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedAddress) SetPostalCode(postalCode *string) {
	r.PostalCode = postalCode
	r.require(retrievedAddressFieldPostalCode)
}

func (r *RetrievedAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrievedAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrievedAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrievedAddress) MarshalJSON() ([]byte, error) {
	type embed RetrievedAddress
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrievedAddress) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains the details of the payment card.
var (
	retrievedCardFieldType                = big.NewInt(1 << 0)
	retrievedCardFieldEntryMethod         = big.NewInt(1 << 1)
	retrievedCardFieldCardholderName      = big.NewInt(1 << 2)
	retrievedCardFieldCardholderSignature = big.NewInt(1 << 3)
	retrievedCardFieldCardNumber          = big.NewInt(1 << 4)
	retrievedCardFieldExpiryDate          = big.NewInt(1 << 5)
	retrievedCardFieldSecureToken         = big.NewInt(1 << 6)
	retrievedCardFieldSecurityChecks      = big.NewInt(1 << 7)
	retrievedCardFieldEmvTags             = big.NewInt(1 << 8)
	retrievedCardFieldBalances            = big.NewInt(1 << 9)
)

type RetrievedCard struct {
	// Card brand that the card is linked to. For example, Visa.
	Type string `json:"type" url:"type"`
	// Method that the device used to capture the card details.
	EntryMethod *RetrievedCardEntryMethod `json:"entryMethod,omitempty" url:"entryMethod,omitempty"`
	// Cardholder’s name.
	CardholderName *string `json:"cardholderName,omitempty" url:"cardholderName,omitempty"`
	// Cardholder’s signature.
	CardholderSignature *string `json:"cardholderSignature,omitempty" url:"cardholderSignature,omitempty"`
	// Masked card number. Our gateway shows only the first six digits and the last four digits of the card number, for example, 500165******0000.
	CardNumber string `json:"cardNumber" url:"cardNumber"`
	// Expiry date of the customer's card. The format is in **MMYY**.
	ExpiryDate     string              `json:"expiryDate" url:"expiryDate"`
	SecureToken    *SecureTokenSummary `json:"secureToken,omitempty" url:"secureToken,omitempty"`
	SecurityChecks *SecurityCheck      `json:"securityChecks,omitempty" url:"securityChecks,omitempty"`
	// Array of emvTag objects.
	EmvTags []*EmvTag `json:"emvTags,omitempty" url:"emvTags,omitempty"`
	// Array of cardBalance objects. Our gateway returns this array only when the customer uses an Electronic Benefit Transfer (EBT) card.
	Balances []*CardBalance `json:"balances,omitempty" url:"balances,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrievedCard) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RetrievedCard) GetEntryMethod() *RetrievedCardEntryMethod {
	if r == nil {
		return nil
	}
	return r.EntryMethod
}

func (r *RetrievedCard) GetCardholderName() *string {
	if r == nil {
		return nil
	}
	return r.CardholderName
}

func (r *RetrievedCard) GetCardholderSignature() *string {
	if r == nil {
		return nil
	}
	return r.CardholderSignature
}

func (r *RetrievedCard) GetCardNumber() string {
	if r == nil {
		return ""
	}
	return r.CardNumber
}

func (r *RetrievedCard) GetExpiryDate() string {
	if r == nil {
		return ""
	}
	return r.ExpiryDate
}

func (r *RetrievedCard) GetSecureToken() *SecureTokenSummary {
	if r == nil {
		return nil
	}
	return r.SecureToken
}

func (r *RetrievedCard) GetSecurityChecks() *SecurityCheck {
	if r == nil {
		return nil
	}
	return r.SecurityChecks
}

func (r *RetrievedCard) GetEmvTags() []*EmvTag {
	if r == nil {
		return nil
	}
	return r.EmvTags
}

func (r *RetrievedCard) GetBalances() []*CardBalance {
	if r == nil {
		return nil
	}
	return r.Balances
}

func (r *RetrievedCard) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrievedCard) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetType(type_ string) {
	r.Type = type_
	r.require(retrievedCardFieldType)
}

// SetEntryMethod sets the EntryMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetEntryMethod(entryMethod *RetrievedCardEntryMethod) {
	r.EntryMethod = entryMethod
	r.require(retrievedCardFieldEntryMethod)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetCardholderName(cardholderName *string) {
	r.CardholderName = cardholderName
	r.require(retrievedCardFieldCardholderName)
}

// SetCardholderSignature sets the CardholderSignature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetCardholderSignature(cardholderSignature *string) {
	r.CardholderSignature = cardholderSignature
	r.require(retrievedCardFieldCardholderSignature)
}

// SetCardNumber sets the CardNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetCardNumber(cardNumber string) {
	r.CardNumber = cardNumber
	r.require(retrievedCardFieldCardNumber)
}

// SetExpiryDate sets the ExpiryDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetExpiryDate(expiryDate string) {
	r.ExpiryDate = expiryDate
	r.require(retrievedCardFieldExpiryDate)
}

// SetSecureToken sets the SecureToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetSecureToken(secureToken *SecureTokenSummary) {
	r.SecureToken = secureToken
	r.require(retrievedCardFieldSecureToken)
}

// SetSecurityChecks sets the SecurityChecks field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetSecurityChecks(securityChecks *SecurityCheck) {
	r.SecurityChecks = securityChecks
	r.require(retrievedCardFieldSecurityChecks)
}

// SetEmvTags sets the EmvTags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetEmvTags(emvTags []*EmvTag) {
	r.EmvTags = emvTags
	r.require(retrievedCardFieldEmvTags)
}

// SetBalances sets the Balances field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCard) SetBalances(balances []*CardBalance) {
	r.Balances = balances
	r.require(retrievedCardFieldBalances)
}

func (r *RetrievedCard) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrievedCard
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrievedCard(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrievedCard) MarshalJSON() ([]byte, error) {
	type embed RetrievedCard
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrievedCard) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Method that the device used to capture the card details.
type RetrievedCardEntryMethod string

const (
	RetrievedCardEntryMethodIcc            RetrievedCardEntryMethod = "icc"
	RetrievedCardEntryMethodKeyed          RetrievedCardEntryMethod = "keyed"
	RetrievedCardEntryMethodSwiped         RetrievedCardEntryMethod = "swiped"
	RetrievedCardEntryMethodSwipedFallback RetrievedCardEntryMethod = "swipedFallback"
	RetrievedCardEntryMethodContactlessIcc RetrievedCardEntryMethod = "contactlessIcc"
	RetrievedCardEntryMethodContactlessMsr RetrievedCardEntryMethod = "contactlessMsr"
)

func NewRetrievedCardEntryMethodFromString(s string) (RetrievedCardEntryMethod, error) {
	switch s {
	case "icc":
		return RetrievedCardEntryMethodIcc, nil
	case "keyed":
		return RetrievedCardEntryMethodKeyed, nil
	case "swiped":
		return RetrievedCardEntryMethodSwiped, nil
	case "swipedFallback":
		return RetrievedCardEntryMethodSwipedFallback, nil
	case "contactlessIcc":
		return RetrievedCardEntryMethodContactlessIcc, nil
	case "contactlessMsr":
		return RetrievedCardEntryMethodContactlessMsr, nil
	}
	var t RetrievedCardEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RetrievedCardEntryMethod) Ptr() *RetrievedCardEntryMethod {
	return &r
}

// Object that contains the customer's contact details and address information.
var (
	retrievedCustomerFieldFirstName            = big.NewInt(1 << 0)
	retrievedCustomerFieldLastName             = big.NewInt(1 << 1)
	retrievedCustomerFieldDateOfBirth          = big.NewInt(1 << 2)
	retrievedCustomerFieldReferenceNumber      = big.NewInt(1 << 3)
	retrievedCustomerFieldBillingAddress       = big.NewInt(1 << 4)
	retrievedCustomerFieldShippingAddress      = big.NewInt(1 << 5)
	retrievedCustomerFieldContactMethods       = big.NewInt(1 << 6)
	retrievedCustomerFieldNotificationLanguage = big.NewInt(1 << 7)
)

type RetrievedCustomer struct {
	// Customer's first name.
	FirstName *string `json:"firstName,omitempty" url:"firstName,omitempty"`
	// Customer's last name.
	LastName *string `json:"lastName,omitempty" url:"lastName,omitempty"`
	// Customer's date of birth. The format for this value is **YYYY-MM-DD**.
	DateOfBirth *time.Time `json:"dateOfBirth,omitempty" url:"dateOfBirth,omitempty" format:"date"`
	// Identifier of the transaction, also known as a customer code.
	//
	// For requests, you must send a value for **referenceNumber** if the customer provides one.
	ReferenceNumber *string `json:"referenceNumber,omitempty" url:"referenceNumber,omitempty"`
	// Object that contains information about the address that the card is registered to.
	BillingAddress  *RetrievedAddress  `json:"billingAddress,omitempty" url:"billingAddress,omitempty"`
	ShippingAddress *RetrievedShipping `json:"shippingAddress,omitempty" url:"shippingAddress,omitempty"`
	// Array of polymorphic objects, which contain contact information.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`email` - Email address
	// -	`phone` - Phone number
	// -	`mobile` - Mobile number
	// -	`fax` - Fax number
	ContactMethods []*ContactMethod `json:"contactMethods,omitempty" url:"contactMethods,omitempty"`
	// Language that the customer uses for notifications. This code follows the [ISO 639-1](https://www.iso.org/iso-639-language-code) alpha-2 standard.
	NotificationLanguage *RetrievedCustomerNotificationLanguage `json:"notificationLanguage,omitempty" url:"notificationLanguage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrievedCustomer) GetFirstName() *string {
	if r == nil {
		return nil
	}
	return r.FirstName
}

func (r *RetrievedCustomer) GetLastName() *string {
	if r == nil {
		return nil
	}
	return r.LastName
}

func (r *RetrievedCustomer) GetDateOfBirth() *time.Time {
	if r == nil {
		return nil
	}
	return r.DateOfBirth
}

func (r *RetrievedCustomer) GetReferenceNumber() *string {
	if r == nil {
		return nil
	}
	return r.ReferenceNumber
}

func (r *RetrievedCustomer) GetBillingAddress() *RetrievedAddress {
	if r == nil {
		return nil
	}
	return r.BillingAddress
}

func (r *RetrievedCustomer) GetShippingAddress() *RetrievedShipping {
	if r == nil {
		return nil
	}
	return r.ShippingAddress
}

func (r *RetrievedCustomer) GetContactMethods() []*ContactMethod {
	if r == nil {
		return nil
	}
	return r.ContactMethods
}

func (r *RetrievedCustomer) GetNotificationLanguage() *RetrievedCustomerNotificationLanguage {
	if r == nil {
		return nil
	}
	return r.NotificationLanguage
}

func (r *RetrievedCustomer) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrievedCustomer) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetFirstName sets the FirstName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetFirstName(firstName *string) {
	r.FirstName = firstName
	r.require(retrievedCustomerFieldFirstName)
}

// SetLastName sets the LastName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetLastName(lastName *string) {
	r.LastName = lastName
	r.require(retrievedCustomerFieldLastName)
}

// SetDateOfBirth sets the DateOfBirth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetDateOfBirth(dateOfBirth *time.Time) {
	r.DateOfBirth = dateOfBirth
	r.require(retrievedCustomerFieldDateOfBirth)
}

// SetReferenceNumber sets the ReferenceNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetReferenceNumber(referenceNumber *string) {
	r.ReferenceNumber = referenceNumber
	r.require(retrievedCustomerFieldReferenceNumber)
}

// SetBillingAddress sets the BillingAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetBillingAddress(billingAddress *RetrievedAddress) {
	r.BillingAddress = billingAddress
	r.require(retrievedCustomerFieldBillingAddress)
}

// SetShippingAddress sets the ShippingAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetShippingAddress(shippingAddress *RetrievedShipping) {
	r.ShippingAddress = shippingAddress
	r.require(retrievedCustomerFieldShippingAddress)
}

// SetContactMethods sets the ContactMethods field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetContactMethods(contactMethods []*ContactMethod) {
	r.ContactMethods = contactMethods
	r.require(retrievedCustomerFieldContactMethods)
}

// SetNotificationLanguage sets the NotificationLanguage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedCustomer) SetNotificationLanguage(notificationLanguage *RetrievedCustomerNotificationLanguage) {
	r.NotificationLanguage = notificationLanguage
	r.require(retrievedCustomerFieldNotificationLanguage)
}

func (r *RetrievedCustomer) UnmarshalJSON(data []byte) error {
	type embed RetrievedCustomer
	var unmarshaler = struct {
		embed
		DateOfBirth *internal.Date `json:"dateOfBirth,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RetrievedCustomer(unmarshaler.embed)
	r.DateOfBirth = unmarshaler.DateOfBirth.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrievedCustomer) MarshalJSON() ([]byte, error) {
	type embed RetrievedCustomer
	var marshaler = struct {
		embed
		DateOfBirth *internal.Date `json:"dateOfBirth,omitempty"`
	}{
		embed:       embed(*r),
		DateOfBirth: internal.NewOptionalDate(r.DateOfBirth),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrievedCustomer) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Language that the customer uses for notifications. This code follows the [ISO 639-1](https://www.iso.org/iso-639-language-code) alpha-2 standard.
type RetrievedCustomerNotificationLanguage string

const (
	RetrievedCustomerNotificationLanguageEn RetrievedCustomerNotificationLanguage = "en"
	RetrievedCustomerNotificationLanguageFr RetrievedCustomerNotificationLanguage = "fr"
)

func NewRetrievedCustomerNotificationLanguageFromString(s string) (RetrievedCustomerNotificationLanguage, error) {
	switch s {
	case "en":
		return RetrievedCustomerNotificationLanguageEn, nil
	case "fr":
		return RetrievedCustomerNotificationLanguageFr, nil
	}
	var t RetrievedCustomerNotificationLanguage
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RetrievedCustomerNotificationLanguage) Ptr() *RetrievedCustomerNotificationLanguage {
	return &r
}

var (
	retrievedPaymentFieldPaymentId            = big.NewInt(1 << 0)
	retrievedPaymentFieldProcessingTerminalId = big.NewInt(1 << 1)
	retrievedPaymentFieldOperator             = big.NewInt(1 << 2)
	retrievedPaymentFieldOrder                = big.NewInt(1 << 3)
	retrievedPaymentFieldCustomer             = big.NewInt(1 << 4)
	retrievedPaymentFieldCard                 = big.NewInt(1 << 5)
	retrievedPaymentFieldRefunds              = big.NewInt(1 << 6)
	retrievedPaymentFieldSupportedOperations  = big.NewInt(1 << 7)
	retrievedPaymentFieldTransactionResult    = big.NewInt(1 << 8)
	retrievedPaymentFieldCustomFields         = big.NewInt(1 << 9)
)

type RetrievedPayment struct {
	// Unique identifier that our gateway assigned to the transaction.
	PaymentId string `json:"paymentId" url:"paymentId"`
	// Unique identifier of the terminal that initiated the transaction.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Operator who initiated the request.
	Operator *string            `json:"operator,omitempty" url:"operator,omitempty"`
	Order    *PaymentOrder      `json:"order" url:"order"`
	Customer *RetrievedCustomer `json:"customer,omitempty" url:"customer,omitempty"`
	Card     *RetrievedCard     `json:"card" url:"card"`
	// Array of refundSummary objects.
	// Each object contains information about refunds linked to the transaction.
	Refunds             []*RefundSummary     `json:"refunds,omitempty" url:"refunds,omitempty"`
	SupportedOperations *SupportedOperations `json:"supportedOperations,omitempty" url:"supportedOperations,omitempty"`
	TransactionResult   *TransactionResult   `json:"transactionResult" url:"transactionResult"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrievedPayment) GetPaymentId() string {
	if r == nil {
		return ""
	}
	return r.PaymentId
}

func (r *RetrievedPayment) GetProcessingTerminalId() string {
	if r == nil {
		return ""
	}
	return r.ProcessingTerminalId
}

func (r *RetrievedPayment) GetOperator() *string {
	if r == nil {
		return nil
	}
	return r.Operator
}

func (r *RetrievedPayment) GetOrder() *PaymentOrder {
	if r == nil {
		return nil
	}
	return r.Order
}

func (r *RetrievedPayment) GetCustomer() *RetrievedCustomer {
	if r == nil {
		return nil
	}
	return r.Customer
}

func (r *RetrievedPayment) GetCard() *RetrievedCard {
	if r == nil {
		return nil
	}
	return r.Card
}

func (r *RetrievedPayment) GetRefunds() []*RefundSummary {
	if r == nil {
		return nil
	}
	return r.Refunds
}

func (r *RetrievedPayment) GetSupportedOperations() *SupportedOperations {
	if r == nil {
		return nil
	}
	return r.SupportedOperations
}

func (r *RetrievedPayment) GetTransactionResult() *TransactionResult {
	if r == nil {
		return nil
	}
	return r.TransactionResult
}

func (r *RetrievedPayment) GetCustomFields() []*CustomField {
	if r == nil {
		return nil
	}
	return r.CustomFields
}

func (r *RetrievedPayment) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrievedPayment) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetPaymentId(paymentId string) {
	r.PaymentId = paymentId
	r.require(retrievedPaymentFieldPaymentId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetProcessingTerminalId(processingTerminalId string) {
	r.ProcessingTerminalId = processingTerminalId
	r.require(retrievedPaymentFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetOperator(operator *string) {
	r.Operator = operator
	r.require(retrievedPaymentFieldOperator)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetOrder(order *PaymentOrder) {
	r.Order = order
	r.require(retrievedPaymentFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetCustomer(customer *RetrievedCustomer) {
	r.Customer = customer
	r.require(retrievedPaymentFieldCustomer)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetCard(card *RetrievedCard) {
	r.Card = card
	r.require(retrievedPaymentFieldCard)
}

// SetRefunds sets the Refunds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetRefunds(refunds []*RefundSummary) {
	r.Refunds = refunds
	r.require(retrievedPaymentFieldRefunds)
}

// SetSupportedOperations sets the SupportedOperations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetSupportedOperations(supportedOperations *SupportedOperations) {
	r.SupportedOperations = supportedOperations
	r.require(retrievedPaymentFieldSupportedOperations)
}

// SetTransactionResult sets the TransactionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetTransactionResult(transactionResult *TransactionResult) {
	r.TransactionResult = transactionResult
	r.require(retrievedPaymentFieldTransactionResult)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedPayment) SetCustomFields(customFields []*CustomField) {
	r.CustomFields = customFields
	r.require(retrievedPaymentFieldCustomFields)
}

func (r *RetrievedPayment) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrievedPayment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrievedPayment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrievedPayment) MarshalJSON() ([]byte, error) {
	type embed RetrievedPayment
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrievedPayment) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about the retrieved refund.
var (
	retrievedRefundFieldRefundId             = big.NewInt(1 << 0)
	retrievedRefundFieldProcessingTerminalId = big.NewInt(1 << 1)
	retrievedRefundFieldOperator             = big.NewInt(1 << 2)
	retrievedRefundFieldOrder                = big.NewInt(1 << 3)
	retrievedRefundFieldCustomer             = big.NewInt(1 << 4)
	retrievedRefundFieldCard                 = big.NewInt(1 << 5)
	retrievedRefundFieldPayment              = big.NewInt(1 << 6)
	retrievedRefundFieldSupportedOperations  = big.NewInt(1 << 7)
	retrievedRefundFieldTransactionResult    = big.NewInt(1 << 8)
	retrievedRefundFieldCustomFields         = big.NewInt(1 << 9)
)

type RetrievedRefund struct {
	// Unique identifier that our gateway assigned to the refund.
	RefundId string `json:"refundId" url:"refundId"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Operator who requested the refund.
	Operator            *string              `json:"operator,omitempty" url:"operator,omitempty"`
	Order               *RefundOrder         `json:"order" url:"order"`
	Customer            *RetrievedCustomer   `json:"customer,omitempty" url:"customer,omitempty"`
	Card                *RetrievedCard       `json:"card" url:"card"`
	Payment             *PaymentSummary      `json:"payment,omitempty" url:"payment,omitempty"`
	SupportedOperations *SupportedOperations `json:"supportedOperations,omitempty" url:"supportedOperations,omitempty"`
	TransactionResult   *TransactionResult   `json:"transactionResult" url:"transactionResult"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrievedRefund) GetRefundId() string {
	if r == nil {
		return ""
	}
	return r.RefundId
}

func (r *RetrievedRefund) GetProcessingTerminalId() string {
	if r == nil {
		return ""
	}
	return r.ProcessingTerminalId
}

func (r *RetrievedRefund) GetOperator() *string {
	if r == nil {
		return nil
	}
	return r.Operator
}

func (r *RetrievedRefund) GetOrder() *RefundOrder {
	if r == nil {
		return nil
	}
	return r.Order
}

func (r *RetrievedRefund) GetCustomer() *RetrievedCustomer {
	if r == nil {
		return nil
	}
	return r.Customer
}

func (r *RetrievedRefund) GetCard() *RetrievedCard {
	if r == nil {
		return nil
	}
	return r.Card
}

func (r *RetrievedRefund) GetPayment() *PaymentSummary {
	if r == nil {
		return nil
	}
	return r.Payment
}

func (r *RetrievedRefund) GetSupportedOperations() *SupportedOperations {
	if r == nil {
		return nil
	}
	return r.SupportedOperations
}

func (r *RetrievedRefund) GetTransactionResult() *TransactionResult {
	if r == nil {
		return nil
	}
	return r.TransactionResult
}

func (r *RetrievedRefund) GetCustomFields() []*CustomField {
	if r == nil {
		return nil
	}
	return r.CustomFields
}

func (r *RetrievedRefund) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrievedRefund) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRefundId sets the RefundId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetRefundId(refundId string) {
	r.RefundId = refundId
	r.require(retrievedRefundFieldRefundId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetProcessingTerminalId(processingTerminalId string) {
	r.ProcessingTerminalId = processingTerminalId
	r.require(retrievedRefundFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetOperator(operator *string) {
	r.Operator = operator
	r.require(retrievedRefundFieldOperator)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetOrder(order *RefundOrder) {
	r.Order = order
	r.require(retrievedRefundFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetCustomer(customer *RetrievedCustomer) {
	r.Customer = customer
	r.require(retrievedRefundFieldCustomer)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetCard(card *RetrievedCard) {
	r.Card = card
	r.require(retrievedRefundFieldCard)
}

// SetPayment sets the Payment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetPayment(payment *PaymentSummary) {
	r.Payment = payment
	r.require(retrievedRefundFieldPayment)
}

// SetSupportedOperations sets the SupportedOperations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetSupportedOperations(supportedOperations *SupportedOperations) {
	r.SupportedOperations = supportedOperations
	r.require(retrievedRefundFieldSupportedOperations)
}

// SetTransactionResult sets the TransactionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetTransactionResult(transactionResult *TransactionResult) {
	r.TransactionResult = transactionResult
	r.require(retrievedRefundFieldTransactionResult)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedRefund) SetCustomFields(customFields []*CustomField) {
	r.CustomFields = customFields
	r.require(retrievedRefundFieldCustomFields)
}

func (r *RetrievedRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrievedRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrievedRefund(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrievedRefund) MarshalJSON() ([]byte, error) {
	type embed RetrievedRefund
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrievedRefund) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about the customer and their shipping address.
var (
	retrievedShippingFieldRecipientName = big.NewInt(1 << 0)
	retrievedShippingFieldAddress       = big.NewInt(1 << 1)
)

type RetrievedShipping struct {
	// Recipient's name.
	RecipientName *string           `json:"recipientName,omitempty" url:"recipientName,omitempty"`
	Address       *RetrievedAddress `json:"address,omitempty" url:"address,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrievedShipping) GetRecipientName() *string {
	if r == nil {
		return nil
	}
	return r.RecipientName
}

func (r *RetrievedShipping) GetAddress() *RetrievedAddress {
	if r == nil {
		return nil
	}
	return r.Address
}

func (r *RetrievedShipping) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrievedShipping) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetRecipientName sets the RecipientName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedShipping) SetRecipientName(recipientName *string) {
	r.RecipientName = recipientName
	r.require(retrievedShippingFieldRecipientName)
}

// SetAddress sets the Address field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedShipping) SetAddress(address *RetrievedAddress) {
	r.Address = address
	r.require(retrievedShippingFieldAddress)
}

func (r *RetrievedShipping) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrievedShipping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrievedShipping(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrievedShipping) MarshalJSON() ([]byte, error) {
	type embed RetrievedShipping
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrievedShipping) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	retrievedTaxFieldName   = big.NewInt(1 << 0)
	retrievedTaxFieldRate   = big.NewInt(1 << 1)
	retrievedTaxFieldAmount = big.NewInt(1 << 2)
)

type RetrievedTax struct {
	// Name of the tax.
	Name string `json:"name" url:"name"`
	// Tax percentage for the transaction.
	Rate float64 `json:"rate" url:"rate"`
	// Amount of tax that was applied to the transaction. The value is in the currency's lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrievedTax) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

func (r *RetrievedTax) GetRate() float64 {
	if r == nil {
		return 0
	}
	return r.Rate
}

func (r *RetrievedTax) GetAmount() *int64 {
	if r == nil {
		return nil
	}
	return r.Amount
}

func (r *RetrievedTax) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrievedTax) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedTax) SetName(name string) {
	r.Name = name
	r.require(retrievedTaxFieldName)
}

// SetRate sets the Rate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedTax) SetRate(rate float64) {
	r.Rate = rate
	r.require(retrievedTaxFieldRate)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievedTax) SetAmount(amount *int64) {
	r.Amount = amount
	r.require(retrievedTaxFieldAmount)
}

func (r *RetrievedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrievedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrievedTax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrievedTax) MarshalJSON() ([]byte, error) {
	type embed RetrievedTax
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RetrievedTax) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about RewardPay.
var (
	rewardPayFieldFees = big.NewInt(1 << 0)
)

type RewardPay struct {
	// Object that contains information about the fees.
	Fees *RewardPayFees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RewardPay) GetFees() *RewardPayFees {
	if r == nil {
		return nil
	}
	return r.Fees
}

func (r *RewardPay) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RewardPay) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPay) SetFees(fees *RewardPayFees) {
	r.Fees = fees
	r.require(rewardPayFieldFees)
}

func (r *RewardPay) UnmarshalJSON(data []byte) error {
	type unmarshaler RewardPay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RewardPay(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RewardPay) MarshalJSON() ([]byte, error) {
	type embed RewardPay
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RewardPay) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about RewardPayChoice.
var (
	rewardPayChoiceFieldFees = big.NewInt(1 << 0)
)

type RewardPayChoice struct {
	// Object that contains information about the fees.
	Fees *RewardPayChoiceFees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RewardPayChoice) GetFees() *RewardPayChoiceFees {
	if r == nil {
		return nil
	}
	return r.Fees
}

func (r *RewardPayChoice) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RewardPayChoice) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoice) SetFees(fees *RewardPayChoiceFees) {
	r.Fees = fees
	r.require(rewardPayChoiceFieldFees)
}

func (r *RewardPayChoice) UnmarshalJSON(data []byte) error {
	type unmarshaler RewardPayChoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RewardPayChoice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RewardPayChoice) MarshalJSON() ([]byte, error) {
	type embed RewardPayChoice
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RewardPayChoice) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about the fees.
var (
	rewardPayChoiceFeesFieldMonthlySubscription = big.NewInt(1 << 0)
	rewardPayChoiceFeesFieldDebit               = big.NewInt(1 << 1)
	rewardPayChoiceFeesFieldCredit              = big.NewInt(1 << 2)
	rewardPayChoiceFeesFieldSpecialityCards     = big.NewInt(1 << 3)
)

type RewardPayChoiceFees struct {
	// Fee for the monthly subscription for the processing plan. The value is in the currency's lowest denomination, for example, cents.
	MonthlySubscription Amount `json:"monthlySubscription" url:"monthlySubscription"`
	// Object that contains information about fees for debit transactions.
	Debit *RewardPayChoiceFeesDebit `json:"debit" url:"debit"`
	// Object that contains information about fees for credit transactions.
	Credit          *RewardPayChoiceFeesCredit `json:"credit" url:"credit"`
	SpecialityCards *SpecialityCards           `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RewardPayChoiceFees) GetMonthlySubscription() Amount {
	if r == nil {
		return 0
	}
	return r.MonthlySubscription
}

func (r *RewardPayChoiceFees) GetDebit() *RewardPayChoiceFeesDebit {
	if r == nil {
		return nil
	}
	return r.Debit
}

func (r *RewardPayChoiceFees) GetCredit() *RewardPayChoiceFeesCredit {
	if r == nil {
		return nil
	}
	return r.Credit
}

func (r *RewardPayChoiceFees) GetSpecialityCards() *SpecialityCards {
	if r == nil {
		return nil
	}
	return r.SpecialityCards
}

func (r *RewardPayChoiceFees) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RewardPayChoiceFees) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetMonthlySubscription sets the MonthlySubscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFees) SetMonthlySubscription(monthlySubscription Amount) {
	r.MonthlySubscription = monthlySubscription
	r.require(rewardPayChoiceFeesFieldMonthlySubscription)
}

// SetDebit sets the Debit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFees) SetDebit(debit *RewardPayChoiceFeesDebit) {
	r.Debit = debit
	r.require(rewardPayChoiceFeesFieldDebit)
}

// SetCredit sets the Credit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFees) SetCredit(credit *RewardPayChoiceFeesCredit) {
	r.Credit = credit
	r.require(rewardPayChoiceFeesFieldCredit)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFees) SetSpecialityCards(specialityCards *SpecialityCards) {
	r.SpecialityCards = specialityCards
	r.require(rewardPayChoiceFeesFieldSpecialityCards)
}

func (r *RewardPayChoiceFees) UnmarshalJSON(data []byte) error {
	type unmarshaler RewardPayChoiceFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RewardPayChoiceFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RewardPayChoiceFees) MarshalJSON() ([]byte, error) {
	type embed RewardPayChoiceFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RewardPayChoiceFees) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Object that contains information about fees for credit transactions.
var (
	rewardPayChoiceFeesCreditFieldTips                         = big.NewInt(1 << 0)
	rewardPayChoiceFeesCreditFieldCardChargePercentage         = big.NewInt(1 << 1)
	rewardPayChoiceFeesCreditFieldMerchantChargePercentage     = big.NewInt(1 << 2)
	rewardPayChoiceFeesCreditFieldMerchantChargePerTransaction = big.NewInt(1 << 3)
)

type RewardPayChoiceFeesCredit struct {
	// Indicates how the merchant manages tips.
	Tips *RewardPayChoiceFeesCreditTips `json:"tips,omitempty" url:"tips,omitempty"`
	// Percentage of the total transaction amount that the processor charges the cardholder.
	CardChargePercentage *float64 `json:"cardChargePercentage,omitempty" url:"cardChargePercentage,omitempty"`
	// Percentage of the total transaction amount that the processor charges the merchant.
	MerchantChargePercentage *float64 `json:"merchantChargePercentage,omitempty" url:"merchantChargePercentage,omitempty"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	MerchantChargePerTransaction *Amount `json:"merchantChargePerTransaction,omitempty" url:"merchantChargePerTransaction,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RewardPayChoiceFeesCredit) GetTips() *RewardPayChoiceFeesCreditTips {
	if r == nil {
		return nil
	}
	return r.Tips
}

func (r *RewardPayChoiceFeesCredit) GetCardChargePercentage() *float64 {
	if r == nil {
		return nil
	}
	return r.CardChargePercentage
}

func (r *RewardPayChoiceFeesCredit) GetMerchantChargePercentage() *float64 {
	if r == nil {
		return nil
	}
	return r.MerchantChargePercentage
}

func (r *RewardPayChoiceFeesCredit) GetMerchantChargePerTransaction() *Amount {
	if r == nil {
		return nil
	}
	return r.MerchantChargePerTransaction
}

func (r *RewardPayChoiceFeesCredit) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RewardPayChoiceFeesCredit) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetTips sets the Tips field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFeesCredit) SetTips(tips *RewardPayChoiceFeesCreditTips) {
	r.Tips = tips
	r.require(rewardPayChoiceFeesCreditFieldTips)
}

// SetCardChargePercentage sets the CardChargePercentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFeesCredit) SetCardChargePercentage(cardChargePercentage *float64) {
	r.CardChargePercentage = cardChargePercentage
	r.require(rewardPayChoiceFeesCreditFieldCardChargePercentage)
}

// SetMerchantChargePercentage sets the MerchantChargePercentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFeesCredit) SetMerchantChargePercentage(merchantChargePercentage *float64) {
	r.MerchantChargePercentage = merchantChargePercentage
	r.require(rewardPayChoiceFeesCreditFieldMerchantChargePercentage)
}

// SetMerchantChargePerTransaction sets the MerchantChargePerTransaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFeesCredit) SetMerchantChargePerTransaction(merchantChargePerTransaction *Amount) {
	r.MerchantChargePerTransaction = merchantChargePerTransaction
	r.require(rewardPayChoiceFeesCreditFieldMerchantChargePerTransaction)
}

func (r *RewardPayChoiceFeesCredit) UnmarshalJSON(data []byte) error {
	type unmarshaler RewardPayChoiceFeesCredit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RewardPayChoiceFeesCredit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RewardPayChoiceFeesCredit) MarshalJSON() ([]byte, error) {
	type embed RewardPayChoiceFeesCredit
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RewardPayChoiceFeesCredit) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates how the merchant manages tips.
type RewardPayChoiceFeesCreditTips string

const (
	RewardPayChoiceFeesCreditTipsNoTips    RewardPayChoiceFeesCreditTips = "noTips"
	RewardPayChoiceFeesCreditTipsTipPrompt RewardPayChoiceFeesCreditTips = "tipPrompt"
	RewardPayChoiceFeesCreditTipsTipAdjust RewardPayChoiceFeesCreditTips = "tipAdjust"
)

func NewRewardPayChoiceFeesCreditTipsFromString(s string) (RewardPayChoiceFeesCreditTips, error) {
	switch s {
	case "noTips":
		return RewardPayChoiceFeesCreditTipsNoTips, nil
	case "tipPrompt":
		return RewardPayChoiceFeesCreditTipsTipPrompt, nil
	case "tipAdjust":
		return RewardPayChoiceFeesCreditTipsTipAdjust, nil
	}
	var t RewardPayChoiceFeesCreditTips
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RewardPayChoiceFeesCreditTips) Ptr() *RewardPayChoiceFeesCreditTips {
	return &r
}

// Object that contains information about fees for debit transactions.
var (
	rewardPayChoiceFeesDebitFieldOption      = big.NewInt(1 << 0)
	rewardPayChoiceFeesDebitFieldVolume      = big.NewInt(1 << 1)
	rewardPayChoiceFeesDebitFieldTransaction = big.NewInt(1 << 2)
)

type RewardPayChoiceFeesDebit struct {
	// Indicates if debit transactions should be charged at interchange plus or flat rate pricing.
	Option *RewardPayChoiceFeesDebitOption `json:"option,omitempty" url:"option,omitempty"`
	// Percentage of the total transaction that the processor charges the merchant.
	Volume Percentage `json:"volume" url:"volume"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RewardPayChoiceFeesDebit) GetOption() *RewardPayChoiceFeesDebitOption {
	if r == nil {
		return nil
	}
	return r.Option
}

func (r *RewardPayChoiceFeesDebit) GetVolume() Percentage {
	if r == nil {
		return 0
	}
	return r.Volume
}

func (r *RewardPayChoiceFeesDebit) GetTransaction() Amount {
	if r == nil {
		return 0
	}
	return r.Transaction
}

func (r *RewardPayChoiceFeesDebit) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RewardPayChoiceFeesDebit) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetOption sets the Option field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFeesDebit) SetOption(option *RewardPayChoiceFeesDebitOption) {
	r.Option = option
	r.require(rewardPayChoiceFeesDebitFieldOption)
}

// SetVolume sets the Volume field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFeesDebit) SetVolume(volume Percentage) {
	r.Volume = volume
	r.require(rewardPayChoiceFeesDebitFieldVolume)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayChoiceFeesDebit) SetTransaction(transaction Amount) {
	r.Transaction = transaction
	r.require(rewardPayChoiceFeesDebitFieldTransaction)
}

func (r *RewardPayChoiceFeesDebit) UnmarshalJSON(data []byte) error {
	type unmarshaler RewardPayChoiceFeesDebit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RewardPayChoiceFeesDebit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RewardPayChoiceFeesDebit) MarshalJSON() ([]byte, error) {
	type embed RewardPayChoiceFeesDebit
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RewardPayChoiceFeesDebit) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates if debit transactions should be charged at interchange plus or flat rate pricing.
type RewardPayChoiceFeesDebitOption string

const (
	RewardPayChoiceFeesDebitOptionInterchangePlus RewardPayChoiceFeesDebitOption = "interchangePlus"
	RewardPayChoiceFeesDebitOptionFlatRate        RewardPayChoiceFeesDebitOption = "flatRate"
)

func NewRewardPayChoiceFeesDebitOptionFromString(s string) (RewardPayChoiceFeesDebitOption, error) {
	switch s {
	case "interchangePlus":
		return RewardPayChoiceFeesDebitOptionInterchangePlus, nil
	case "flatRate":
		return RewardPayChoiceFeesDebitOptionFlatRate, nil
	}
	var t RewardPayChoiceFeesDebitOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RewardPayChoiceFeesDebitOption) Ptr() *RewardPayChoiceFeesDebitOption {
	return &r
}

// Object that contains information about the fees.
var (
	rewardPayFeesFieldMonthlySubscription      = big.NewInt(1 << 0)
	rewardPayFeesFieldCardChargePercentage     = big.NewInt(1 << 1)
	rewardPayFeesFieldMerchantChargePercentage = big.NewInt(1 << 2)
	rewardPayFeesFieldTransaction              = big.NewInt(1 << 3)
	rewardPayFeesFieldTips                     = big.NewInt(1 << 4)
	rewardPayFeesFieldSpecialityCards          = big.NewInt(1 << 5)
)

type RewardPayFees struct {
	// Fee for the monthly subscription for the processing plan. The value is in the currency's lowest denomination, for example, cents.
	MonthlySubscription Amount `json:"monthlySubscription" url:"monthlySubscription"`
	// Percentage of the total transaction amount that the processor charges the cardholder.
	CardChargePercentage *float64 `json:"cardChargePercentage,omitempty" url:"cardChargePercentage,omitempty"`
	// Percentage of the total transaction amount that the processor charges the merchant.
	MerchantChargePercentage *float64 `json:"merchantChargePercentage,omitempty" url:"merchantChargePercentage,omitempty"`
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction *int `json:"transaction,omitempty" url:"transaction,omitempty"`
	// Indicates how the merchant manages tips.
	Tips            RewardPayFeesTips `json:"tips" url:"tips"`
	SpecialityCards *SpecialityCards  `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RewardPayFees) GetMonthlySubscription() Amount {
	if r == nil {
		return 0
	}
	return r.MonthlySubscription
}

func (r *RewardPayFees) GetCardChargePercentage() *float64 {
	if r == nil {
		return nil
	}
	return r.CardChargePercentage
}

func (r *RewardPayFees) GetMerchantChargePercentage() *float64 {
	if r == nil {
		return nil
	}
	return r.MerchantChargePercentage
}

func (r *RewardPayFees) GetTransaction() *int {
	if r == nil {
		return nil
	}
	return r.Transaction
}

func (r *RewardPayFees) GetTips() RewardPayFeesTips {
	if r == nil {
		return ""
	}
	return r.Tips
}

func (r *RewardPayFees) GetSpecialityCards() *SpecialityCards {
	if r == nil {
		return nil
	}
	return r.SpecialityCards
}

func (r *RewardPayFees) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RewardPayFees) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetMonthlySubscription sets the MonthlySubscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayFees) SetMonthlySubscription(monthlySubscription Amount) {
	r.MonthlySubscription = monthlySubscription
	r.require(rewardPayFeesFieldMonthlySubscription)
}

// SetCardChargePercentage sets the CardChargePercentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayFees) SetCardChargePercentage(cardChargePercentage *float64) {
	r.CardChargePercentage = cardChargePercentage
	r.require(rewardPayFeesFieldCardChargePercentage)
}

// SetMerchantChargePercentage sets the MerchantChargePercentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayFees) SetMerchantChargePercentage(merchantChargePercentage *float64) {
	r.MerchantChargePercentage = merchantChargePercentage
	r.require(rewardPayFeesFieldMerchantChargePercentage)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayFees) SetTransaction(transaction *int) {
	r.Transaction = transaction
	r.require(rewardPayFeesFieldTransaction)
}

// SetTips sets the Tips field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayFees) SetTips(tips RewardPayFeesTips) {
	r.Tips = tips
	r.require(rewardPayFeesFieldTips)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RewardPayFees) SetSpecialityCards(specialityCards *SpecialityCards) {
	r.SpecialityCards = specialityCards
	r.require(rewardPayFeesFieldSpecialityCards)
}

func (r *RewardPayFees) UnmarshalJSON(data []byte) error {
	type unmarshaler RewardPayFees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RewardPayFees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RewardPayFees) MarshalJSON() ([]byte, error) {
	type embed RewardPayFees
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RewardPayFees) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates how the merchant manages tips.
type RewardPayFeesTips string

const (
	RewardPayFeesTipsNoTips    RewardPayFeesTips = "noTips"
	RewardPayFeesTipsTipPrompt RewardPayFeesTips = "tipPrompt"
	RewardPayFeesTipsTipAdjust RewardPayFeesTips = "tipAdjust"
)

func NewRewardPayFeesTipsFromString(s string) (RewardPayFeesTips, error) {
	switch s {
	case "noTips":
		return RewardPayFeesTipsNoTips, nil
	case "tipPrompt":
		return RewardPayFeesTipsTipPrompt, nil
	case "tipAdjust":
		return RewardPayFeesTipsTipAdjust, nil
	}
	var t RewardPayFeesTips
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RewardPayFeesTips) Ptr() *RewardPayFeesTips {
	return &r
}

// Indicates how authorized transactions will be batched for settlement
var (
	schemasAutomaticBatchCloseFieldBatchCloseTime = big.NewInt(1 << 0)
)

type SchemasAutomaticBatchClose struct {
	// The time, within the specified timezone, at which the batch automatically closes
	BatchCloseTime string `json:"batchCloseTime" url:"batchCloseTime"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SchemasAutomaticBatchClose) GetBatchCloseTime() string {
	if s == nil {
		return ""
	}
	return s.BatchCloseTime
}

func (s *SchemasAutomaticBatchClose) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SchemasAutomaticBatchClose) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetBatchCloseTime sets the BatchCloseTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemasAutomaticBatchClose) SetBatchCloseTime(batchCloseTime string) {
	s.BatchCloseTime = batchCloseTime
	s.require(schemasAutomaticBatchCloseFieldBatchCloseTime)
}

func (s *SchemasAutomaticBatchClose) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemasAutomaticBatchClose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemasAutomaticBatchClose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemasAutomaticBatchClose) MarshalJSON() ([]byte, error) {
	type embed SchemasAutomaticBatchClose
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SchemasAutomaticBatchClose) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about saving the customer’s payment details.
var (
	schemasCredentialOnFileFieldExternalVault = big.NewInt(1 << 0)
	schemasCredentialOnFileFieldTokenize      = big.NewInt(1 << 1)
	schemasCredentialOnFileFieldSecureTokenId = big.NewInt(1 << 2)
	schemasCredentialOnFileFieldMitAgreement  = big.NewInt(1 << 3)
)

type SchemasCredentialOnFile struct {
	// Indicates if the merchant uses a third-party vault to store the customer’s payment details.
	ExternalVault *bool `json:"externalVault,omitempty" url:"externalVault,omitempty"`
	// Indicates if our gateway should tokenize the customer’s payment details as part of the transaction.
	Tokenize *bool `json:"tokenize,omitempty" url:"tokenize,omitempty"`
	// Unique identifier that the merchant creates for the secure token that represents the customer’s payment details.
	// **Note:** If you do not send a value for the **secureTokenId**, our gateway generates a unique identifier for the token.
	SecureTokenId *string `json:"secureTokenId,omitempty" url:"secureTokenId,omitempty"`
	// Indicates how the merchant can use the customer’s card details, as agreed by the customer:
	//
	// - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
	// - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don’t have a fixed duration and run until the customer cancels the agreement.
	// - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.
	//
	// **Note:** If you send a value for **mitAgreement**, you must send the **standingInstructions** object in the **paymentOrder** object.
	MitAgreement *SchemasCredentialOnFileMitAgreement `json:"mitAgreement,omitempty" url:"mitAgreement,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SchemasCredentialOnFile) GetExternalVault() *bool {
	if s == nil {
		return nil
	}
	return s.ExternalVault
}

func (s *SchemasCredentialOnFile) GetTokenize() *bool {
	if s == nil {
		return nil
	}
	return s.Tokenize
}

func (s *SchemasCredentialOnFile) GetSecureTokenId() *string {
	if s == nil {
		return nil
	}
	return s.SecureTokenId
}

func (s *SchemasCredentialOnFile) GetMitAgreement() *SchemasCredentialOnFileMitAgreement {
	if s == nil {
		return nil
	}
	return s.MitAgreement
}

func (s *SchemasCredentialOnFile) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SchemasCredentialOnFile) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetExternalVault sets the ExternalVault field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemasCredentialOnFile) SetExternalVault(externalVault *bool) {
	s.ExternalVault = externalVault
	s.require(schemasCredentialOnFileFieldExternalVault)
}

// SetTokenize sets the Tokenize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemasCredentialOnFile) SetTokenize(tokenize *bool) {
	s.Tokenize = tokenize
	s.require(schemasCredentialOnFileFieldTokenize)
}

// SetSecureTokenId sets the SecureTokenId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemasCredentialOnFile) SetSecureTokenId(secureTokenId *string) {
	s.SecureTokenId = secureTokenId
	s.require(schemasCredentialOnFileFieldSecureTokenId)
}

// SetMitAgreement sets the MitAgreement field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemasCredentialOnFile) SetMitAgreement(mitAgreement *SchemasCredentialOnFileMitAgreement) {
	s.MitAgreement = mitAgreement
	s.require(schemasCredentialOnFileFieldMitAgreement)
}

func (s *SchemasCredentialOnFile) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemasCredentialOnFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemasCredentialOnFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemasCredentialOnFile) MarshalJSON() ([]byte, error) {
	type embed SchemasCredentialOnFile
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SchemasCredentialOnFile) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Indicates how the merchant can use the customer’s card details, as agreed by the customer:
//
// - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
// - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don’t have a fixed duration and run until the customer cancels the agreement.
// - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.
//
// **Note:** If you send a value for **mitAgreement**, you must send the **standingInstructions** object in the **paymentOrder** object.
type SchemasCredentialOnFileMitAgreement string

const (
	SchemasCredentialOnFileMitAgreementUnscheduled SchemasCredentialOnFileMitAgreement = "unscheduled"
	SchemasCredentialOnFileMitAgreementRecurring   SchemasCredentialOnFileMitAgreement = "recurring"
	SchemasCredentialOnFileMitAgreementInstallment SchemasCredentialOnFileMitAgreement = "installment"
)

func NewSchemasCredentialOnFileMitAgreementFromString(s string) (SchemasCredentialOnFileMitAgreement, error) {
	switch s {
	case "unscheduled":
		return SchemasCredentialOnFileMitAgreementUnscheduled, nil
	case "recurring":
		return SchemasCredentialOnFileMitAgreementRecurring, nil
	case "installment":
		return SchemasCredentialOnFileMitAgreementInstallment, nil
	}
	var t SchemasCredentialOnFileMitAgreement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SchemasCredentialOnFileMitAgreement) Ptr() *SchemasCredentialOnFileMitAgreement {
	return &s
}

// Indicates how authorized transactions will be batched for settlement
type SchemasManualBatchClose struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SchemasManualBatchClose) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SchemasManualBatchClose) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

func (s *SchemasManualBatchClose) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemasManualBatchClose
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemasManualBatchClose(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemasManualBatchClose) MarshalJSON() ([]byte, error) {
	type embed SchemasManualBatchClose
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SchemasManualBatchClose) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Time zone of the terminal.
// **Note**: If you don't send a value for this parameter, we use the time zone of the processing account.
type SchemasTimezone string

const (
	SchemasTimezonePacificMidway              SchemasTimezone = "Pacific/Midway"
	SchemasTimezonePacificHonolulu            SchemasTimezone = "Pacific/Honolulu"
	SchemasTimezoneAmericaAnchorage           SchemasTimezone = "America/Anchorage"
	SchemasTimezoneAmericaLosAngeles          SchemasTimezone = "America/Los_Angeles"
	SchemasTimezoneAmericaDenver              SchemasTimezone = "America/Denver"
	SchemasTimezoneAmericaPhoenix             SchemasTimezone = "America/Phoenix"
	SchemasTimezoneAmericaChicago             SchemasTimezone = "America/Chicago"
	SchemasTimezoneAmericaIndianaIndianapolis SchemasTimezone = "America/Indiana/Indianapolis"
	SchemasTimezoneAmericaNewYork             SchemasTimezone = "America/New_York"
)

func NewSchemasTimezoneFromString(s string) (SchemasTimezone, error) {
	switch s {
	case "Pacific/Midway":
		return SchemasTimezonePacificMidway, nil
	case "Pacific/Honolulu":
		return SchemasTimezonePacificHonolulu, nil
	case "America/Anchorage":
		return SchemasTimezoneAmericaAnchorage, nil
	case "America/Los_Angeles":
		return SchemasTimezoneAmericaLosAngeles, nil
	case "America/Denver":
		return SchemasTimezoneAmericaDenver, nil
	case "America/Phoenix":
		return SchemasTimezoneAmericaPhoenix, nil
	case "America/Chicago":
		return SchemasTimezoneAmericaChicago, nil
	case "America/Indiana/Indianapolis":
		return SchemasTimezoneAmericaIndianaIndianapolis, nil
	case "America/New_York":
		return SchemasTimezoneAmericaNewYork, nil
	}
	var t SchemasTimezone
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SchemasTimezone) Ptr() *SchemasTimezone {
	return &s
}

// Object that contains information about the secure token.
var (
	secureTokenFieldSecureTokenId        = big.NewInt(1 << 0)
	secureTokenFieldProcessingTerminalId = big.NewInt(1 << 1)
	secureTokenFieldMitAgreement         = big.NewInt(1 << 2)
	secureTokenFieldCustomer             = big.NewInt(1 << 3)
	secureTokenFieldSource               = big.NewInt(1 << 4)
	secureTokenFieldToken                = big.NewInt(1 << 5)
	secureTokenFieldStatus               = big.NewInt(1 << 6)
	secureTokenFieldCustomFields         = big.NewInt(1 << 7)
)

type SecureToken struct {
	// Unique identifier that the merchant created for the secure token that represents the customer's payment details.
	SecureTokenId string `json:"secureTokenId" url:"secureTokenId"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Indicates how the merchant can use the customer's card details, as agreed by the customer:
	//
	// - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
	// - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don't have a fixed duration and run until the customer cancels the agreement.
	// - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.
	MitAgreement *SecureTokenMitAgreement `json:"mitAgreement,omitempty" url:"mitAgreement,omitempty"`
	Customer     *RetrievedCustomer       `json:"customer,omitempty" url:"customer,omitempty"`
	// Polymorphic object that contains the payment method that we tokenized.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`pad` - Pre-authorized debit (PAD) details
	// -	`card` - Payment card details
	Source *SecureTokenSource `json:"source" url:"source"`
	// Token that the merchant can use in future transactions to represent the customer's payment details. The token:
	// - Begins with the six-digit identification number **296753**.
	// - Contains up to 12 digits.
	// - Contains a single check digit that we calculate using the Luhn algorithm.
	Token string `json:"token" url:"token"`
	// Outcome of a security check on the status of the customer's payment card or bank account.
	//
	// **Note:** Depending on the merchant's account settings, this feature may be unavailable.
	Status SecureTokenStatus `json:"status" url:"status"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecureToken) GetSecureTokenId() string {
	if s == nil {
		return ""
	}
	return s.SecureTokenId
}

func (s *SecureToken) GetProcessingTerminalId() string {
	if s == nil {
		return ""
	}
	return s.ProcessingTerminalId
}

func (s *SecureToken) GetMitAgreement() *SecureTokenMitAgreement {
	if s == nil {
		return nil
	}
	return s.MitAgreement
}

func (s *SecureToken) GetCustomer() *RetrievedCustomer {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *SecureToken) GetSource() *SecureTokenSource {
	if s == nil {
		return nil
	}
	return s.Source
}

func (s *SecureToken) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SecureToken) GetStatus() SecureTokenStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SecureToken) GetCustomFields() []*CustomField {
	if s == nil {
		return nil
	}
	return s.CustomFields
}

func (s *SecureToken) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecureToken) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSecureTokenId sets the SecureTokenId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetSecureTokenId(secureTokenId string) {
	s.SecureTokenId = secureTokenId
	s.require(secureTokenFieldSecureTokenId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetProcessingTerminalId(processingTerminalId string) {
	s.ProcessingTerminalId = processingTerminalId
	s.require(secureTokenFieldProcessingTerminalId)
}

// SetMitAgreement sets the MitAgreement field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetMitAgreement(mitAgreement *SecureTokenMitAgreement) {
	s.MitAgreement = mitAgreement
	s.require(secureTokenFieldMitAgreement)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetCustomer(customer *RetrievedCustomer) {
	s.Customer = customer
	s.require(secureTokenFieldCustomer)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetSource(source *SecureTokenSource) {
	s.Source = source
	s.require(secureTokenFieldSource)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetToken(token string) {
	s.Token = token
	s.require(secureTokenFieldToken)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetStatus(status SecureTokenStatus) {
	s.Status = status
	s.require(secureTokenFieldStatus)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureToken) SetCustomFields(customFields []*CustomField) {
	s.CustomFields = customFields
	s.require(secureTokenFieldCustomFields)
}

func (s *SecureToken) UnmarshalJSON(data []byte) error {
	type unmarshaler SecureToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecureToken(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecureToken) MarshalJSON() ([]byte, error) {
	type embed SecureToken
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SecureToken) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Indicates how the merchant can use the customer's card details, as agreed by the customer:
//
// - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
// - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don't have a fixed duration and run until the customer cancels the agreement.
// - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.
type SecureTokenMitAgreement string

const (
	SecureTokenMitAgreementUnscheduled SecureTokenMitAgreement = "unscheduled"
	SecureTokenMitAgreementRecurring   SecureTokenMitAgreement = "recurring"
	SecureTokenMitAgreementInstallment SecureTokenMitAgreement = "installment"
)

func NewSecureTokenMitAgreementFromString(s string) (SecureTokenMitAgreement, error) {
	switch s {
	case "unscheduled":
		return SecureTokenMitAgreementUnscheduled, nil
	case "recurring":
		return SecureTokenMitAgreementRecurring, nil
	case "installment":
		return SecureTokenMitAgreementInstallment, nil
	}
	var t SecureTokenMitAgreement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecureTokenMitAgreement) Ptr() *SecureTokenMitAgreement {
	return &s
}

var (
	secureTokenPaginatedListWithAccountTypeFieldLimit   = big.NewInt(1 << 0)
	secureTokenPaginatedListWithAccountTypeFieldCount   = big.NewInt(1 << 1)
	secureTokenPaginatedListWithAccountTypeFieldHasMore = big.NewInt(1 << 2)
	secureTokenPaginatedListWithAccountTypeFieldLinks   = big.NewInt(1 << 3)
	secureTokenPaginatedListWithAccountTypeFieldData    = big.NewInt(1 << 4)
)

type SecureTokenPaginatedListWithAccountType struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of saved payment details.
	Data []*SecureTokenWithAccountType `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecureTokenPaginatedListWithAccountType) GetLimit() *int {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SecureTokenPaginatedListWithAccountType) GetCount() *int {
	if s == nil {
		return nil
	}
	return s.Count
}

func (s *SecureTokenPaginatedListWithAccountType) GetHasMore() *bool {
	if s == nil {
		return nil
	}
	return s.HasMore
}

func (s *SecureTokenPaginatedListWithAccountType) GetLinks() []*Link {
	if s == nil {
		return nil
	}
	return s.Links
}

func (s *SecureTokenPaginatedListWithAccountType) GetData() []*SecureTokenWithAccountType {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SecureTokenPaginatedListWithAccountType) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecureTokenPaginatedListWithAccountType) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPaginatedListWithAccountType) SetLimit(limit *int) {
	s.Limit = limit
	s.require(secureTokenPaginatedListWithAccountTypeFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPaginatedListWithAccountType) SetCount(count *int) {
	s.Count = count
	s.require(secureTokenPaginatedListWithAccountTypeFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPaginatedListWithAccountType) SetHasMore(hasMore *bool) {
	s.HasMore = hasMore
	s.require(secureTokenPaginatedListWithAccountTypeFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPaginatedListWithAccountType) SetLinks(links []*Link) {
	s.Links = links
	s.require(secureTokenPaginatedListWithAccountTypeFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPaginatedListWithAccountType) SetData(data []*SecureTokenWithAccountType) {
	s.Data = data
	s.require(secureTokenPaginatedListWithAccountTypeFieldData)
}

func (s *SecureTokenPaginatedListWithAccountType) UnmarshalJSON(data []byte) error {
	type unmarshaler SecureTokenPaginatedListWithAccountType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecureTokenPaginatedListWithAccountType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecureTokenPaginatedListWithAccountType) MarshalJSON() ([]byte, error) {
	type embed SecureTokenPaginatedListWithAccountType
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SecureTokenPaginatedListWithAccountType) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the secure token that represents the customer’s payment details.
var (
	secureTokenPayloadFieldAccountType = big.NewInt(1 << 0)
	secureTokenPayloadFieldToken       = big.NewInt(1 << 1)
	secureTokenPayloadFieldSecCode     = big.NewInt(1 << 2)
)

type SecureTokenPayload struct {
	// Indicates the customer’s account type.
	//
	// **Note:** Send a value for accountType only if the secure token represents bank account details.
	AccountType *SecureTokenPayloadAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`
	// Unique token that the gateway assigned to the payment details.
	Token string `json:"token" url:"token"`
	// Indicates how the customer authorized the ACH transaction. Send one of the following values:
	//
	// - `web` – Online transaction.
	// - `tel` – Telephone transaction.
	// - `ccd` – Corporate credit card or debit card transaction.
	// - `ppd` – Pre-arranged transaction.
	SecCode *SecureTokenPayloadSecCode `json:"secCode,omitempty" url:"secCode,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecureTokenPayload) GetAccountType() *SecureTokenPayloadAccountType {
	if s == nil {
		return nil
	}
	return s.AccountType
}

func (s *SecureTokenPayload) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SecureTokenPayload) GetSecCode() *SecureTokenPayloadSecCode {
	if s == nil {
		return nil
	}
	return s.SecCode
}

func (s *SecureTokenPayload) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecureTokenPayload) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPayload) SetAccountType(accountType *SecureTokenPayloadAccountType) {
	s.AccountType = accountType
	s.require(secureTokenPayloadFieldAccountType)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPayload) SetToken(token string) {
	s.Token = token
	s.require(secureTokenPayloadFieldToken)
}

// SetSecCode sets the SecCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenPayload) SetSecCode(secCode *SecureTokenPayloadSecCode) {
	s.SecCode = secCode
	s.require(secureTokenPayloadFieldSecCode)
}

func (s *SecureTokenPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler SecureTokenPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecureTokenPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecureTokenPayload) MarshalJSON() ([]byte, error) {
	type embed SecureTokenPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SecureTokenPayload) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Indicates the customer’s account type.
//
// **Note:** Send a value for accountType only if the secure token represents bank account details.
type SecureTokenPayloadAccountType string

const (
	SecureTokenPayloadAccountTypeChecking SecureTokenPayloadAccountType = "checking"
	SecureTokenPayloadAccountTypeSavings  SecureTokenPayloadAccountType = "savings"
)

func NewSecureTokenPayloadAccountTypeFromString(s string) (SecureTokenPayloadAccountType, error) {
	switch s {
	case "checking":
		return SecureTokenPayloadAccountTypeChecking, nil
	case "savings":
		return SecureTokenPayloadAccountTypeSavings, nil
	}
	var t SecureTokenPayloadAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecureTokenPayloadAccountType) Ptr() *SecureTokenPayloadAccountType {
	return &s
}

// Indicates how the customer authorized the ACH transaction. Send one of the following values:
//
// - `web` – Online transaction.
// - `tel` – Telephone transaction.
// - `ccd` – Corporate credit card or debit card transaction.
// - `ppd` – Pre-arranged transaction.
type SecureTokenPayloadSecCode string

const (
	SecureTokenPayloadSecCodeWeb SecureTokenPayloadSecCode = "web"
	SecureTokenPayloadSecCodeTel SecureTokenPayloadSecCode = "tel"
	SecureTokenPayloadSecCodeCcd SecureTokenPayloadSecCode = "ccd"
	SecureTokenPayloadSecCodePpd SecureTokenPayloadSecCode = "ppd"
)

func NewSecureTokenPayloadSecCodeFromString(s string) (SecureTokenPayloadSecCode, error) {
	switch s {
	case "web":
		return SecureTokenPayloadSecCodeWeb, nil
	case "tel":
		return SecureTokenPayloadSecCodeTel, nil
	case "ccd":
		return SecureTokenPayloadSecCodeCcd, nil
	case "ppd":
		return SecureTokenPayloadSecCodePpd, nil
	}
	var t SecureTokenPayloadSecCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecureTokenPayloadSecCode) Ptr() *SecureTokenPayloadSecCode {
	return &s
}

// Polymorphic object that contains the payment method that we tokenized.
//
// The value of the type parameter determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`pad` - Pre-authorized debit (PAD) details
// -	`card` - Payment card details
type SecureTokenSource struct {
	Type string
	Ach  *AchSource
	Pad  *PadSource
	Card *CardSource
}

func (s *SecureTokenSource) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SecureTokenSource) GetAch() *AchSource {
	if s == nil {
		return nil
	}
	return s.Ach
}

func (s *SecureTokenSource) GetPad() *PadSource {
	if s == nil {
		return nil
	}
	return s.Pad
}

func (s *SecureTokenSource) GetCard() *CardSource {
	if s == nil {
		return nil
	}
	return s.Card
}

func (s *SecureTokenSource) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(AchSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Ach = value
	case "pad":
		value := new(PadSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Pad = value
	case "card":
		value := new(CardSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Card = value
	}
	return nil
}

func (s SecureTokenSource) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(s.Ach, "type", "ach")
	}
	if s.Pad != nil {
		return internal.MarshalJSONWithExtraProperty(s.Pad, "type", "pad")
	}
	if s.Card != nil {
		return internal.MarshalJSONWithExtraProperty(s.Card, "type", "card")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SecureTokenSourceVisitor interface {
	VisitAch(*AchSource) error
	VisitPad(*PadSource) error
	VisitCard(*CardSource) error
}

func (s *SecureTokenSource) Accept(visitor SecureTokenSourceVisitor) error {
	if s.Ach != nil {
		return visitor.VisitAch(s.Ach)
	}
	if s.Pad != nil {
		return visitor.VisitPad(s.Pad)
	}
	if s.Card != nil {
		return visitor.VisitCard(s.Card)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SecureTokenSource) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Ach != nil {
		fields = append(fields, "ach")
	}
	if s.Pad != nil {
		fields = append(fields, "pad")
	}
	if s.Card != nil {
		fields = append(fields, "card")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// Outcome of a security check on the status of the customer's payment card or bank account.
//
// **Note:** Depending on the merchant's account settings, this feature may be unavailable.
type SecureTokenStatus string

const (
	SecureTokenStatusNotValidated         SecureTokenStatus = "notValidated"
	SecureTokenStatusCvvValidated         SecureTokenStatus = "cvvValidated"
	SecureTokenStatusValidationFailed     SecureTokenStatus = "validationFailed"
	SecureTokenStatusIssueNumberValidated SecureTokenStatus = "issueNumberValidated"
	SecureTokenStatusCardNumberValidated  SecureTokenStatus = "cardNumberValidated"
	SecureTokenStatusBankAccountValidated SecureTokenStatus = "bankAccountValidated"
)

func NewSecureTokenStatusFromString(s string) (SecureTokenStatus, error) {
	switch s {
	case "notValidated":
		return SecureTokenStatusNotValidated, nil
	case "cvvValidated":
		return SecureTokenStatusCvvValidated, nil
	case "validationFailed":
		return SecureTokenStatusValidationFailed, nil
	case "issueNumberValidated":
		return SecureTokenStatusIssueNumberValidated, nil
	case "cardNumberValidated":
		return SecureTokenStatusCardNumberValidated, nil
	case "bankAccountValidated":
		return SecureTokenStatusBankAccountValidated, nil
	}
	var t SecureTokenStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecureTokenStatus) Ptr() *SecureTokenStatus {
	return &s
}

// Object that contains information about the secure token.
var (
	secureTokenSummaryFieldSecureTokenId = big.NewInt(1 << 0)
	secureTokenSummaryFieldCustomerName  = big.NewInt(1 << 1)
	secureTokenSummaryFieldToken         = big.NewInt(1 << 2)
	secureTokenSummaryFieldStatus        = big.NewInt(1 << 3)
	secureTokenSummaryFieldLink          = big.NewInt(1 << 4)
)

type SecureTokenSummary struct {
	// Unique identifier that the merchant assigned to the secure token.
	SecureTokenId string `json:"secureTokenId" url:"secureTokenId"`
	// Customer's name.
	CustomerName string `json:"customerName" url:"customerName"`
	// Token that the merchant can use in future transactions to represent the customer's payment details. The token:
	// - Begins with the six-digit identification number **296753**.
	// - Contains up to 12 digits.
	// - Contains a single check digit that we calculate using the Luhn algorithm.
	Token string `json:"token" url:"token"`
	// Status of the customer's bank account. The processor performs a security check on the customer's bank account and returns the status of the account.
	// **Note:** Depending on the merchant's account settings, this feature may be unavailable.
	Status SecureTokenSummaryStatus `json:"status" url:"status"`
	Link   *Link                    `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecureTokenSummary) GetSecureTokenId() string {
	if s == nil {
		return ""
	}
	return s.SecureTokenId
}

func (s *SecureTokenSummary) GetCustomerName() string {
	if s == nil {
		return ""
	}
	return s.CustomerName
}

func (s *SecureTokenSummary) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SecureTokenSummary) GetStatus() SecureTokenSummaryStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SecureTokenSummary) GetLink() *Link {
	if s == nil {
		return nil
	}
	return s.Link
}

func (s *SecureTokenSummary) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecureTokenSummary) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSecureTokenId sets the SecureTokenId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenSummary) SetSecureTokenId(secureTokenId string) {
	s.SecureTokenId = secureTokenId
	s.require(secureTokenSummaryFieldSecureTokenId)
}

// SetCustomerName sets the CustomerName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenSummary) SetCustomerName(customerName string) {
	s.CustomerName = customerName
	s.require(secureTokenSummaryFieldCustomerName)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenSummary) SetToken(token string) {
	s.Token = token
	s.require(secureTokenSummaryFieldToken)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenSummary) SetStatus(status SecureTokenSummaryStatus) {
	s.Status = status
	s.require(secureTokenSummaryFieldStatus)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenSummary) SetLink(link *Link) {
	s.Link = link
	s.require(secureTokenSummaryFieldLink)
}

func (s *SecureTokenSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler SecureTokenSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecureTokenSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecureTokenSummary) MarshalJSON() ([]byte, error) {
	type embed SecureTokenSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SecureTokenSummary) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Status of the customer's bank account. The processor performs a security check on the customer's bank account and returns the status of the account.
// **Note:** Depending on the merchant's account settings, this feature may be unavailable.
type SecureTokenSummaryStatus string

const (
	SecureTokenSummaryStatusNotValidated         SecureTokenSummaryStatus = "notValidated"
	SecureTokenSummaryStatusCvvValidated         SecureTokenSummaryStatus = "cvvValidated"
	SecureTokenSummaryStatusValidationFailed     SecureTokenSummaryStatus = "validationFailed"
	SecureTokenSummaryStatusIssueNumberValidated SecureTokenSummaryStatus = "issueNumberValidated"
	SecureTokenSummaryStatusCardNumberValidated  SecureTokenSummaryStatus = "cardNumberValidated"
	SecureTokenSummaryStatusBankAccountValidated SecureTokenSummaryStatus = "bankAccountValidated"
)

func NewSecureTokenSummaryStatusFromString(s string) (SecureTokenSummaryStatus, error) {
	switch s {
	case "notValidated":
		return SecureTokenSummaryStatusNotValidated, nil
	case "cvvValidated":
		return SecureTokenSummaryStatusCvvValidated, nil
	case "validationFailed":
		return SecureTokenSummaryStatusValidationFailed, nil
	case "issueNumberValidated":
		return SecureTokenSummaryStatusIssueNumberValidated, nil
	case "cardNumberValidated":
		return SecureTokenSummaryStatusCardNumberValidated, nil
	case "bankAccountValidated":
		return SecureTokenSummaryStatusBankAccountValidated, nil
	}
	var t SecureTokenSummaryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecureTokenSummaryStatus) Ptr() *SecureTokenSummaryStatus {
	return &s
}

var (
	secureTokenWithAccountTypeFieldSource               = big.NewInt(1 << 0)
	secureTokenWithAccountTypeFieldSecureTokenId        = big.NewInt(1 << 1)
	secureTokenWithAccountTypeFieldProcessingTerminalId = big.NewInt(1 << 2)
	secureTokenWithAccountTypeFieldMitAgreement         = big.NewInt(1 << 3)
	secureTokenWithAccountTypeFieldCustomer             = big.NewInt(1 << 4)
	secureTokenWithAccountTypeFieldToken                = big.NewInt(1 << 5)
	secureTokenWithAccountTypeFieldStatus               = big.NewInt(1 << 6)
	secureTokenWithAccountTypeFieldCustomFields         = big.NewInt(1 << 7)
)

type SecureTokenWithAccountType struct {
	// Polymorphic object that contains the payment method that we tokenized.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`pad` - Pre-authorized debit (PAD) details
	// -	`card` - Payment card details
	Source *SecureTokenWithAccountTypeSource `json:"source,omitempty" url:"source,omitempty"`
	// Unique identifier that the merchant created for the secure token that represents the customer's payment details.
	SecureTokenId string `json:"secureTokenId" url:"secureTokenId"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"processingTerminalId" url:"processingTerminalId"`
	// Indicates how the merchant can use the customer's card details, as agreed by the customer:
	//
	// - `unscheduled` - Transactions for a fixed or variable amount that are run at a certain pre-defined event.
	// - `recurring` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Recurring transactions don't have a fixed duration and run until the customer cancels the agreement.
	// - `installment` - Transactions for a fixed amount that are run at regular intervals, for example, monthly. Installment transactions have a fixed duration.
	MitAgreement *SecureTokenMitAgreement `json:"mitAgreement,omitempty" url:"mitAgreement,omitempty"`
	Customer     *RetrievedCustomer       `json:"customer,omitempty" url:"customer,omitempty"`
	// Token that the merchant can use in future transactions to represent the customer's payment details. The token:
	// - Begins with the six-digit identification number **296753**.
	// - Contains up to 12 digits.
	// - Contains a single check digit that we calculate using the Luhn algorithm.
	Token string `json:"token" url:"token"`
	// Outcome of a security check on the status of the customer's payment card or bank account.
	//
	// **Note:** Depending on the merchant's account settings, this feature may be unavailable.
	Status SecureTokenStatus `json:"status" url:"status"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecureTokenWithAccountType) GetSource() *SecureTokenWithAccountTypeSource {
	if s == nil {
		return nil
	}
	return s.Source
}

func (s *SecureTokenWithAccountType) GetSecureTokenId() string {
	if s == nil {
		return ""
	}
	return s.SecureTokenId
}

func (s *SecureTokenWithAccountType) GetProcessingTerminalId() string {
	if s == nil {
		return ""
	}
	return s.ProcessingTerminalId
}

func (s *SecureTokenWithAccountType) GetMitAgreement() *SecureTokenMitAgreement {
	if s == nil {
		return nil
	}
	return s.MitAgreement
}

func (s *SecureTokenWithAccountType) GetCustomer() *RetrievedCustomer {
	if s == nil {
		return nil
	}
	return s.Customer
}

func (s *SecureTokenWithAccountType) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SecureTokenWithAccountType) GetStatus() SecureTokenStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SecureTokenWithAccountType) GetCustomFields() []*CustomField {
	if s == nil {
		return nil
	}
	return s.CustomFields
}

func (s *SecureTokenWithAccountType) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecureTokenWithAccountType) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetSource(source *SecureTokenWithAccountTypeSource) {
	s.Source = source
	s.require(secureTokenWithAccountTypeFieldSource)
}

// SetSecureTokenId sets the SecureTokenId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetSecureTokenId(secureTokenId string) {
	s.SecureTokenId = secureTokenId
	s.require(secureTokenWithAccountTypeFieldSecureTokenId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetProcessingTerminalId(processingTerminalId string) {
	s.ProcessingTerminalId = processingTerminalId
	s.require(secureTokenWithAccountTypeFieldProcessingTerminalId)
}

// SetMitAgreement sets the MitAgreement field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetMitAgreement(mitAgreement *SecureTokenMitAgreement) {
	s.MitAgreement = mitAgreement
	s.require(secureTokenWithAccountTypeFieldMitAgreement)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetCustomer(customer *RetrievedCustomer) {
	s.Customer = customer
	s.require(secureTokenWithAccountTypeFieldCustomer)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetToken(token string) {
	s.Token = token
	s.require(secureTokenWithAccountTypeFieldToken)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetStatus(status SecureTokenStatus) {
	s.Status = status
	s.require(secureTokenWithAccountTypeFieldStatus)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecureTokenWithAccountType) SetCustomFields(customFields []*CustomField) {
	s.CustomFields = customFields
	s.require(secureTokenWithAccountTypeFieldCustomFields)
}

func (s *SecureTokenWithAccountType) UnmarshalJSON(data []byte) error {
	type unmarshaler SecureTokenWithAccountType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecureTokenWithAccountType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecureTokenWithAccountType) MarshalJSON() ([]byte, error) {
	type embed SecureTokenWithAccountType
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SecureTokenWithAccountType) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Polymorphic object that contains the payment method that we tokenized.
//
// The value of the type parameter determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`pad` - Pre-authorized debit (PAD) details
// -	`card` - Payment card details
type SecureTokenWithAccountTypeSource struct {
	Type string
	Ach  *AchSourceWithAccountType
	Pad  *PadSourceWithAccountType
	Card *CardSource
}

func (s *SecureTokenWithAccountTypeSource) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SecureTokenWithAccountTypeSource) GetAch() *AchSourceWithAccountType {
	if s == nil {
		return nil
	}
	return s.Ach
}

func (s *SecureTokenWithAccountTypeSource) GetPad() *PadSourceWithAccountType {
	if s == nil {
		return nil
	}
	return s.Pad
}

func (s *SecureTokenWithAccountTypeSource) GetCard() *CardSource {
	if s == nil {
		return nil
	}
	return s.Card
}

func (s *SecureTokenWithAccountTypeSource) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(AchSourceWithAccountType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Ach = value
	case "pad":
		value := new(PadSourceWithAccountType)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Pad = value
	case "card":
		value := new(CardSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Card = value
	}
	return nil
}

func (s SecureTokenWithAccountTypeSource) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(s.Ach, "type", "ach")
	}
	if s.Pad != nil {
		return internal.MarshalJSONWithExtraProperty(s.Pad, "type", "pad")
	}
	if s.Card != nil {
		return internal.MarshalJSONWithExtraProperty(s.Card, "type", "card")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SecureTokenWithAccountTypeSourceVisitor interface {
	VisitAch(*AchSourceWithAccountType) error
	VisitPad(*PadSourceWithAccountType) error
	VisitCard(*CardSource) error
}

func (s *SecureTokenWithAccountTypeSource) Accept(visitor SecureTokenWithAccountTypeSourceVisitor) error {
	if s.Ach != nil {
		return visitor.VisitAch(s.Ach)
	}
	if s.Pad != nil {
		return visitor.VisitPad(s.Pad)
	}
	if s.Card != nil {
		return visitor.VisitCard(s.Card)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SecureTokenWithAccountTypeSource) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Ach != nil {
		fields = append(fields, "ach")
	}
	if s.Pad != nil {
		fields = append(fields, "pad")
	}
	if s.Card != nil {
		fields = append(fields, "card")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// Object that contains information about card verification and security checks.
var (
	securityCheckFieldCvvResult = big.NewInt(1 << 0)
	securityCheckFieldAvsResult = big.NewInt(1 << 1)
)

type SecurityCheck struct {
	// Indicates if the card verification value (CVV) that the customer provided in the request matches the CVV on the card.
	// - `M` – The CVV matches the card’s CVV.
	// - `N` – The CVV doesn’t match the card’s CVV.
	// - `P` – The CVV wasn’t processed.
	// - `U` – The CVV isn’t registered.
	//
	// **Note:** Our gateway doesn’t automatically decline transactions when the CVV doesn’t match the card’s CVV, unless the merchant selects this setting in their account.
	CvvResult *SecurityCheckCvvResult `json:"cvvResult,omitempty" url:"cvvResult,omitempty"`
	// Indicates if the address that the customer provided in the request matches the address linked to the card.
	//
	// - `Y` – The address in the request matches the address linked to the card.
	// - `N` – The address in the request doesn’t match the address linked to the card.
	// - `A` – The street address matches, but ZIP code or postal code doesn’t match.
	// - `Z` - The ZIP code or postal code matches, but street address doesn’t match.
	// - `U` – The address information is unavailable.
	// - `G` – The issuer or card brand doesn’t support the Address Verification Service (AVS).
	// - `R` – The AVS is currently unavailable. Try again later.
	// - `S` – There was no AVS data in the request, or it was sent in the wrong format.
	// - `F` - For UK addresses, the address in the request matches the address linked to the card.
	// - `W` – For US addresses, the nine-digit ZIP code or postal code in the request matches the address linked to the card but the street address doesn’t.
	// - `X` – For US addresses, the nine-digit ZIP code or postal code and the street address matches the address linked to the card.
	//
	// **Note:** Our gateway doesn’t automatically decline transactions when the address doesn’t match the address linked to the card,
	// unless the merchant selects this setting in their account.
	AvsResult *SecurityCheckAvsResult `json:"avsResult,omitempty" url:"avsResult,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SecurityCheck) GetCvvResult() *SecurityCheckCvvResult {
	if s == nil {
		return nil
	}
	return s.CvvResult
}

func (s *SecurityCheck) GetAvsResult() *SecurityCheckAvsResult {
	if s == nil {
		return nil
	}
	return s.AvsResult
}

func (s *SecurityCheck) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SecurityCheck) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetCvvResult sets the CvvResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecurityCheck) SetCvvResult(cvvResult *SecurityCheckCvvResult) {
	s.CvvResult = cvvResult
	s.require(securityCheckFieldCvvResult)
}

// SetAvsResult sets the AvsResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SecurityCheck) SetAvsResult(avsResult *SecurityCheckAvsResult) {
	s.AvsResult = avsResult
	s.require(securityCheckFieldAvsResult)
}

func (s *SecurityCheck) UnmarshalJSON(data []byte) error {
	type unmarshaler SecurityCheck
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SecurityCheck(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SecurityCheck) MarshalJSON() ([]byte, error) {
	type embed SecurityCheck
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SecurityCheck) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Indicates if the address that the customer provided in the request matches the address linked to the card.
//
// - `Y` – The address in the request matches the address linked to the card.
// - `N` – The address in the request doesn’t match the address linked to the card.
// - `A` – The street address matches, but ZIP code or postal code doesn’t match.
// - `Z` - The ZIP code or postal code matches, but street address doesn’t match.
// - `U` – The address information is unavailable.
// - `G` – The issuer or card brand doesn’t support the Address Verification Service (AVS).
// - `R` – The AVS is currently unavailable. Try again later.
// - `S` – There was no AVS data in the request, or it was sent in the wrong format.
// - `F` - For UK addresses, the address in the request matches the address linked to the card.
// - `W` – For US addresses, the nine-digit ZIP code or postal code in the request matches the address linked to the card but the street address doesn’t.
// - `X` – For US addresses, the nine-digit ZIP code or postal code and the street address matches the address linked to the card.
//
// **Note:** Our gateway doesn’t automatically decline transactions when the address doesn’t match the address linked to the card,
// unless the merchant selects this setting in their account.
type SecurityCheckAvsResult string

const (
	SecurityCheckAvsResultY SecurityCheckAvsResult = "Y"
	SecurityCheckAvsResultA SecurityCheckAvsResult = "A"
	SecurityCheckAvsResultZ SecurityCheckAvsResult = "Z"
	SecurityCheckAvsResultN SecurityCheckAvsResult = "N"
	SecurityCheckAvsResultU SecurityCheckAvsResult = "U"
	SecurityCheckAvsResultR SecurityCheckAvsResult = "R"
	SecurityCheckAvsResultG SecurityCheckAvsResult = "G"
	SecurityCheckAvsResultS SecurityCheckAvsResult = "S"
	SecurityCheckAvsResultF SecurityCheckAvsResult = "F"
	SecurityCheckAvsResultW SecurityCheckAvsResult = "W"
	SecurityCheckAvsResultX SecurityCheckAvsResult = "X"
)

func NewSecurityCheckAvsResultFromString(s string) (SecurityCheckAvsResult, error) {
	switch s {
	case "Y":
		return SecurityCheckAvsResultY, nil
	case "A":
		return SecurityCheckAvsResultA, nil
	case "Z":
		return SecurityCheckAvsResultZ, nil
	case "N":
		return SecurityCheckAvsResultN, nil
	case "U":
		return SecurityCheckAvsResultU, nil
	case "R":
		return SecurityCheckAvsResultR, nil
	case "G":
		return SecurityCheckAvsResultG, nil
	case "S":
		return SecurityCheckAvsResultS, nil
	case "F":
		return SecurityCheckAvsResultF, nil
	case "W":
		return SecurityCheckAvsResultW, nil
	case "X":
		return SecurityCheckAvsResultX, nil
	}
	var t SecurityCheckAvsResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecurityCheckAvsResult) Ptr() *SecurityCheckAvsResult {
	return &s
}

// Indicates if the card verification value (CVV) that the customer provided in the request matches the CVV on the card.
// - `M` – The CVV matches the card’s CVV.
// - `N` – The CVV doesn’t match the card’s CVV.
// - `P` – The CVV wasn’t processed.
// - `U` – The CVV isn’t registered.
//
// **Note:** Our gateway doesn’t automatically decline transactions when the CVV doesn’t match the card’s CVV, unless the merchant selects this setting in their account.
type SecurityCheckCvvResult string

const (
	SecurityCheckCvvResultM SecurityCheckCvvResult = "M"
	SecurityCheckCvvResultN SecurityCheckCvvResult = "N"
	SecurityCheckCvvResultP SecurityCheckCvvResult = "P"
	SecurityCheckCvvResultU SecurityCheckCvvResult = "U"
)

func NewSecurityCheckCvvResultFromString(s string) (SecurityCheckCvvResult, error) {
	switch s {
	case "M":
		return SecurityCheckCvvResultM, nil
	case "N":
		return SecurityCheckCvvResultN, nil
	case "P":
		return SecurityCheckCvvResultP, nil
	case "U":
		return SecurityCheckCvvResultU, nil
	}
	var t SecurityCheckCvvResult
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SecurityCheckCvvResult) Ptr() *SecurityCheckCvvResult {
	return &s
}

// Object that contains information about the Hardware Advantage Plan.
type ServiceUs50 struct {
	Name                  string
	HardwareAdvantagePlan *HardwareAdvantagePlan
}

func (s *ServiceUs50) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *ServiceUs50) GetHardwareAdvantagePlan() *HardwareAdvantagePlan {
	if s == nil {
		return nil
	}
	return s.HardwareAdvantagePlan
}

func (s *ServiceUs50) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Name string `json:"name"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Name = unmarshaler.Name
	if unmarshaler.Name == "" {
		return fmt.Errorf("%T did not include discriminant name", s)
	}
	switch unmarshaler.Name {
	case "hardwareAdvantagePlan":
		value := new(HardwareAdvantagePlan)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.HardwareAdvantagePlan = value
	}
	return nil
}

func (s ServiceUs50) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.HardwareAdvantagePlan != nil {
		return internal.MarshalJSONWithExtraProperty(s.HardwareAdvantagePlan, "name", "hardwareAdvantagePlan")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type ServiceUs50Visitor interface {
	VisitHardwareAdvantagePlan(*HardwareAdvantagePlan) error
}

func (s *ServiceUs50) Accept(visitor ServiceUs50Visitor) error {
	if s.HardwareAdvantagePlan != nil {
		return visitor.VisitHardwareAdvantagePlan(s.HardwareAdvantagePlan)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *ServiceUs50) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.HardwareAdvantagePlan != nil {
		fields = append(fields, "hardwareAdvantagePlan")
	}
	if len(fields) == 0 {
		if s.Name != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Name)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Name != "" {
		field := fields[0]
		if s.Name != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Name,
				s,
			)
		}
	}
	return nil
}

// Array of polymorphic objects that contain information about additional services that we offer.
type ServicesUs50 = []*ServiceUs50

// Object that contains information about the settlement.
var (
	settledSummaryFieldSettledBy    = big.NewInt(1 << 0)
	settledSummaryFieldAchDate      = big.NewInt(1 << 1)
	settledSummaryFieldAchDepositId = big.NewInt(1 << 2)
	settledSummaryFieldLink         = big.NewInt(1 << 3)
)

type SettledSummary struct {
	// Processor that settled the transaction.
	SettledBy *string `json:"settledBy,omitempty" url:"settledBy,omitempty"`
	// Date that the processor settled the transaction. The format of this value is **YYYY-MM-DD**.
	AchDate *time.Time `json:"achDate,omitempty" url:"achDate,omitempty" format:"date"`
	// Unique identifier of the ACH deposit.
	AchDepositId *int  `json:"achDepositId,omitempty" url:"achDepositId,omitempty"`
	Link         *Link `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SettledSummary) GetSettledBy() *string {
	if s == nil {
		return nil
	}
	return s.SettledBy
}

func (s *SettledSummary) GetAchDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.AchDate
}

func (s *SettledSummary) GetAchDepositId() *int {
	if s == nil {
		return nil
	}
	return s.AchDepositId
}

func (s *SettledSummary) GetLink() *Link {
	if s == nil {
		return nil
	}
	return s.Link
}

func (s *SettledSummary) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SettledSummary) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSettledBy sets the SettledBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettledSummary) SetSettledBy(settledBy *string) {
	s.SettledBy = settledBy
	s.require(settledSummaryFieldSettledBy)
}

// SetAchDate sets the AchDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettledSummary) SetAchDate(achDate *time.Time) {
	s.AchDate = achDate
	s.require(settledSummaryFieldAchDate)
}

// SetAchDepositId sets the AchDepositId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettledSummary) SetAchDepositId(achDepositId *int) {
	s.AchDepositId = achDepositId
	s.require(settledSummaryFieldAchDepositId)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettledSummary) SetLink(link *Link) {
	s.Link = link
	s.require(settledSummaryFieldLink)
}

func (s *SettledSummary) UnmarshalJSON(data []byte) error {
	type embed SettledSummary
	var unmarshaler = struct {
		embed
		AchDate *internal.Date `json:"achDate,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SettledSummary(unmarshaler.embed)
	s.AchDate = unmarshaler.AchDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SettledSummary) MarshalJSON() ([]byte, error) {
	type embed SettledSummary
	var marshaler = struct {
		embed
		AchDate *internal.Date `json:"achDate,omitempty"`
	}{
		embed:   embed(*s),
		AchDate: internal.NewOptionalDate(s.AchDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SettledSummary) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sharingEventPaginatedListFieldLimit   = big.NewInt(1 << 0)
	sharingEventPaginatedListFieldCount   = big.NewInt(1 << 1)
	sharingEventPaginatedListFieldHasMore = big.NewInt(1 << 2)
	sharingEventPaginatedListFieldLinks   = big.NewInt(1 << 3)
	sharingEventPaginatedListFieldData    = big.NewInt(1 << 4)
)

type SharingEventPaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of polymorphic objects that contain information about how the merchant shared a payment link.
	Data []*PaymentLinkEmailShareEvent `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SharingEventPaginatedList) GetLimit() *int {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SharingEventPaginatedList) GetCount() *int {
	if s == nil {
		return nil
	}
	return s.Count
}

func (s *SharingEventPaginatedList) GetHasMore() *bool {
	if s == nil {
		return nil
	}
	return s.HasMore
}

func (s *SharingEventPaginatedList) GetLinks() []*Link {
	if s == nil {
		return nil
	}
	return s.Links
}

func (s *SharingEventPaginatedList) GetData() []*PaymentLinkEmailShareEvent {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SharingEventPaginatedList) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SharingEventPaginatedList) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SharingEventPaginatedList) SetLimit(limit *int) {
	s.Limit = limit
	s.require(sharingEventPaginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SharingEventPaginatedList) SetCount(count *int) {
	s.Count = count
	s.require(sharingEventPaginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SharingEventPaginatedList) SetHasMore(hasMore *bool) {
	s.HasMore = hasMore
	s.require(sharingEventPaginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SharingEventPaginatedList) SetLinks(links []*Link) {
	s.Links = links
	s.require(sharingEventPaginatedListFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SharingEventPaginatedList) SetData(data []*PaymentLinkEmailShareEvent) {
	s.Data = data
	s.require(sharingEventPaginatedListFieldData)
}

func (s *SharingEventPaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler SharingEventPaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SharingEventPaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SharingEventPaginatedList) MarshalJSON() ([]byte, error) {
	type embed SharingEventPaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SharingEventPaginatedList) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the customer and their shipping address.
var (
	shippingFieldRecipientName = big.NewInt(1 << 0)
	shippingFieldAddress       = big.NewInt(1 << 1)
)

type Shipping struct {
	// Recipient's name.
	RecipientName *string  `json:"recipientName,omitempty" url:"recipientName,omitempty"`
	Address       *Address `json:"address,omitempty" url:"address,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Shipping) GetRecipientName() *string {
	if s == nil {
		return nil
	}
	return s.RecipientName
}

func (s *Shipping) GetAddress() *Address {
	if s == nil {
		return nil
	}
	return s.Address
}

func (s *Shipping) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Shipping) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetRecipientName sets the RecipientName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Shipping) SetRecipientName(recipientName *string) {
	s.RecipientName = recipientName
	s.require(shippingFieldRecipientName)
}

// SetAddress sets the Address field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Shipping) SetAddress(address *Address) {
	s.Address = address
	s.require(shippingFieldAddress)
}

func (s *Shipping) UnmarshalJSON(data []byte) error {
	type unmarshaler Shipping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Shipping(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Shipping) MarshalJSON() ([]byte, error) {
	type embed Shipping
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Shipping) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Polymorphic object that contains information about how we captured the owner's signature.
//
// The value of the type parameter determines which variant you should use:
// -	`requestedViaDirectLink` - Request signature using a link.
// -	`requestedViaEmail` - Request signature by email.
type Signature struct {
	Type                   string
	RequestedViaDirectLink *SignatureByDirectLink
	RequestedViaEmail      *SignatureByEmail
}

func (s *Signature) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Signature) GetRequestedViaDirectLink() *SignatureByDirectLink {
	if s == nil {
		return nil
	}
	return s.RequestedViaDirectLink
}

func (s *Signature) GetRequestedViaEmail() *SignatureByEmail {
	if s == nil {
		return nil
	}
	return s.RequestedViaEmail
}

func (s *Signature) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "requestedViaDirectLink":
		value := new(SignatureByDirectLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.RequestedViaDirectLink = value
	case "requestedViaEmail":
		value := new(SignatureByEmail)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.RequestedViaEmail = value
	}
	return nil
}

func (s Signature) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.RequestedViaDirectLink != nil {
		return internal.MarshalJSONWithExtraProperty(s.RequestedViaDirectLink, "type", "requestedViaDirectLink")
	}
	if s.RequestedViaEmail != nil {
		return internal.MarshalJSONWithExtraProperty(s.RequestedViaEmail, "type", "requestedViaEmail")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SignatureVisitor interface {
	VisitRequestedViaDirectLink(*SignatureByDirectLink) error
	VisitRequestedViaEmail(*SignatureByEmail) error
}

func (s *Signature) Accept(visitor SignatureVisitor) error {
	if s.RequestedViaDirectLink != nil {
		return visitor.VisitRequestedViaDirectLink(s.RequestedViaDirectLink)
	}
	if s.RequestedViaEmail != nil {
		return visitor.VisitRequestedViaEmail(s.RequestedViaEmail)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *Signature) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.RequestedViaDirectLink != nil {
		fields = append(fields, "requestedViaDirectLink")
	}
	if s.RequestedViaEmail != nil {
		fields = append(fields, "requestedViaEmail")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// Object that contains the signature for the transaction.
// **Note:** If the merchant previously added a signature to the transaction, they can’t adjust or delete the signature.
var (
	signatureAdjustmentFieldCardholderSignature = big.NewInt(1 << 0)
)

type SignatureAdjustment struct {
	// Cardholder’s signature. For more information about the format of the signature, see Special Fields and Parameters.
	CardholderSignature string `json:"cardholderSignature" url:"cardholderSignature"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignatureAdjustment) GetCardholderSignature() string {
	if s == nil {
		return ""
	}
	return s.CardholderSignature
}

func (s *SignatureAdjustment) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureAdjustment) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetCardholderSignature sets the CardholderSignature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SignatureAdjustment) SetCardholderSignature(cardholderSignature string) {
	s.CardholderSignature = cardholderSignature
	s.require(signatureAdjustmentFieldCardholderSignature)
}

func (s *SignatureAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureAdjustment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureAdjustment) MarshalJSON() ([]byte, error) {
	type embed SignatureAdjustment
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SignatureAdjustment) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains signature information if we captured the merchant’s signature by direct link.
var (
	signatureByDirectLinkFieldLink = big.NewInt(1 << 0)
)

type SignatureByDirectLink struct {
	// Object that contains links to the signed contract.
	Link *Link `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignatureByDirectLink) GetLink() *Link {
	if s == nil {
		return nil
	}
	return s.Link
}

func (s *SignatureByDirectLink) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureByDirectLink) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SignatureByDirectLink) SetLink(link *Link) {
	s.Link = link
	s.require(signatureByDirectLinkFieldLink)
}

func (s *SignatureByDirectLink) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureByDirectLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureByDirectLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureByDirectLink) MarshalJSON() ([]byte, error) {
	type embed SignatureByDirectLink
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SignatureByDirectLink) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains signature information if we captured the merchant’s signature by email.
type SignatureByEmail struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignatureByEmail) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureByEmail) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

func (s *SignatureByEmail) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureByEmail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureByEmail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureByEmail) MarshalJSON() ([]byte, error) {
	type embed SignatureByEmail
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SignatureByEmail) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	signatureInstructionFieldStatus                 = big.NewInt(1 << 0)
	signatureInstructionFieldErrorMessage           = big.NewInt(1 << 1)
	signatureInstructionFieldLink                   = big.NewInt(1 << 2)
	signatureInstructionFieldSignatureInstructionId = big.NewInt(1 << 3)
)

type SignatureInstruction struct {
	// Indicates the current status of the instruction.
	// - `canceled` – The instruction was canceled before it was completed.
	// - `completed` – The instruction has completed. Use the link object to check the resource.
	// - `failure` – The instruction failed. Check the errorMessage field for more information.
	// - `inProgress` – The instruction is currently in progress.
	Status *DeviceInstructionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Description of the error that caused the instruction to fail.
	//
	// **Note:** We return this field only if the status is `failure`.
	ErrorMessage *string `json:"errorMessage,omitempty" url:"errorMessage,omitempty"`
	Link         *Link   `json:"link,omitempty" url:"link,omitempty"`
	// Unique identifier that our gateway assigned to the instruction.
	SignatureInstructionId *string `json:"signatureInstructionId,omitempty" url:"signatureInstructionId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignatureInstruction) GetStatus() *DeviceInstructionStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SignatureInstruction) GetErrorMessage() *string {
	if s == nil {
		return nil
	}
	return s.ErrorMessage
}

func (s *SignatureInstruction) GetLink() *Link {
	if s == nil {
		return nil
	}
	return s.Link
}

func (s *SignatureInstruction) GetSignatureInstructionId() *string {
	if s == nil {
		return nil
	}
	return s.SignatureInstructionId
}

func (s *SignatureInstruction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureInstruction) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SignatureInstruction) SetStatus(status *DeviceInstructionStatus) {
	s.Status = status
	s.require(signatureInstructionFieldStatus)
}

// SetErrorMessage sets the ErrorMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SignatureInstruction) SetErrorMessage(errorMessage *string) {
	s.ErrorMessage = errorMessage
	s.require(signatureInstructionFieldErrorMessage)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SignatureInstruction) SetLink(link *Link) {
	s.Link = link
	s.require(signatureInstructionFieldLink)
}

// SetSignatureInstructionId sets the SignatureInstructionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SignatureInstruction) SetSignatureInstructionId(signatureInstructionId *string) {
	s.SignatureInstructionId = signatureInstructionId
	s.require(signatureInstructionFieldSignatureInstructionId)
}

func (s *SignatureInstruction) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureInstruction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureInstruction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureInstruction) MarshalJSON() ([]byte, error) {
	type embed SignatureInstruction
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SignatureInstruction) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	singleUseTokenFieldProcessingTerminalId = big.NewInt(1 << 0)
	singleUseTokenFieldOperator             = big.NewInt(1 << 1)
	singleUseTokenFieldPaymentMethod        = big.NewInt(1 << 2)
	singleUseTokenFieldToken                = big.NewInt(1 << 3)
	singleUseTokenFieldExpiresAt            = big.NewInt(1 << 4)
	singleUseTokenFieldSource               = big.NewInt(1 << 5)
)

type SingleUseToken struct {
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId *string `json:"processingTerminalId,omitempty" url:"processingTerminalId,omitempty"`
	// Operator who initiated the request.
	Operator *string `json:"operator,omitempty" url:"operator,omitempty"`
	// Polymorphic object that contains payment card details.
	PaymentMethod *SingleUseTokenPaymentMethod `json:"paymentMethod,omitempty" url:"paymentMethod,omitempty"`
	// Unique identifier that our gateway assigned to the payment details.
	// **Note:** Merchants can use the token with other terminals linked to their account.
	Token *string `json:"token,omitempty" url:"token,omitempty"`
	// Date and time that the token expires. We return this value in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	ExpiresAt *time.Time `json:"expiresAt,omitempty" url:"expiresAt,omitempty"`
	// Polymorphic object that contains the payment method that we tokenized.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`pad` - Pre-authorized debit (PAD) details
	// -	`card` - Payment card details
	Source *SingleUseTokenSource `json:"source" url:"source"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleUseToken) GetProcessingTerminalId() *string {
	if s == nil {
		return nil
	}
	return s.ProcessingTerminalId
}

func (s *SingleUseToken) GetOperator() *string {
	if s == nil {
		return nil
	}
	return s.Operator
}

func (s *SingleUseToken) GetPaymentMethod() *SingleUseTokenPaymentMethod {
	if s == nil {
		return nil
	}
	return s.PaymentMethod
}

func (s *SingleUseToken) GetToken() *string {
	if s == nil {
		return nil
	}
	return s.Token
}

func (s *SingleUseToken) GetExpiresAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ExpiresAt
}

func (s *SingleUseToken) GetSource() *SingleUseTokenSource {
	if s == nil {
		return nil
	}
	return s.Source
}

func (s *SingleUseToken) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUseToken) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseToken) SetProcessingTerminalId(processingTerminalId *string) {
	s.ProcessingTerminalId = processingTerminalId
	s.require(singleUseTokenFieldProcessingTerminalId)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseToken) SetOperator(operator *string) {
	s.Operator = operator
	s.require(singleUseTokenFieldOperator)
}

// SetPaymentMethod sets the PaymentMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseToken) SetPaymentMethod(paymentMethod *SingleUseTokenPaymentMethod) {
	s.PaymentMethod = paymentMethod
	s.require(singleUseTokenFieldPaymentMethod)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseToken) SetToken(token *string) {
	s.Token = token
	s.require(singleUseTokenFieldToken)
}

// SetExpiresAt sets the ExpiresAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseToken) SetExpiresAt(expiresAt *time.Time) {
	s.ExpiresAt = expiresAt
	s.require(singleUseTokenFieldExpiresAt)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseToken) SetSource(source *SingleUseTokenSource) {
	s.Source = source
	s.require(singleUseTokenFieldSource)
}

func (s *SingleUseToken) UnmarshalJSON(data []byte) error {
	type embed SingleUseToken
	var unmarshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SingleUseToken(unmarshaler.embed)
	s.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUseToken) MarshalJSON() ([]byte, error) {
	type embed SingleUseToken
	var marshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt,omitempty"`
	}{
		embed:     embed(*s),
		ExpiresAt: internal.NewOptionalDateTime(s.ExpiresAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleUseToken) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains the token.
var (
	singleUseTokenAccountUpdateFieldToken = big.NewInt(1 << 0)
)

type SingleUseTokenAccountUpdate struct {
	// Single-use token that the gateway assigned to the payment details.
	Token string `json:"token" url:"token"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleUseTokenAccountUpdate) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SingleUseTokenAccountUpdate) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUseTokenAccountUpdate) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenAccountUpdate) SetToken(token string) {
	s.Token = token
	s.require(singleUseTokenAccountUpdateFieldToken)
}

func (s *SingleUseTokenAccountUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUseTokenAccountUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUseTokenAccountUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUseTokenAccountUpdate) MarshalJSON() ([]byte, error) {
	type embed SingleUseTokenAccountUpdate
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleUseTokenAccountUpdate) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the single-use token, which represents the customer’s payment details.
var (
	singleUseTokenPayloadFieldAccountType = big.NewInt(1 << 0)
	singleUseTokenPayloadFieldToken       = big.NewInt(1 << 1)
	singleUseTokenPayloadFieldPinDetails  = big.NewInt(1 << 2)
	singleUseTokenPayloadFieldEbtDetails  = big.NewInt(1 << 3)
	singleUseTokenPayloadFieldSecCode     = big.NewInt(1 << 4)
)

type SingleUseTokenPayload struct {
	// Indicates the customer’s account type.
	//
	// **Note:** Send a value for accountType only if the single-use token represents bank account details.
	AccountType *SingleUseTokenPayloadAccountType `json:"accountType,omitempty" url:"accountType,omitempty"`
	// Unique token that the gateway assigned to the payment details.
	Token string `json:"token" url:"token"`
	// Polymorphic object that contains information about a customer's PIN.
	//
	// The value of the dataFormat parameter determines which variant you should use:
	// - `dukpt` - PIN information is encrypted.
	// - `raw` - PIN information is unencrypted.
	PinDetails *SingleUseTokenPayloadPinDetails `json:"pinDetails,omitempty" url:"pinDetails,omitempty"`
	EbtDetails *EbtDetailsWithVoucher           `json:"ebtDetails,omitempty" url:"ebtDetails,omitempty"`
	// Indicates how the customer authorized the ACH transaction. Send one of the following values:
	//
	// - `web` – Online transaction.
	// - `tel` – Telephone transaction.
	// - `ccd` – Corporate credit card or debit card transaction.
	// - `ppd` – Pre-arranged transaction.
	SecCode *SingleUseTokenPayloadSecCode `json:"secCode,omitempty" url:"secCode,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SingleUseTokenPayload) GetAccountType() *SingleUseTokenPayloadAccountType {
	if s == nil {
		return nil
	}
	return s.AccountType
}

func (s *SingleUseTokenPayload) GetToken() string {
	if s == nil {
		return ""
	}
	return s.Token
}

func (s *SingleUseTokenPayload) GetPinDetails() *SingleUseTokenPayloadPinDetails {
	if s == nil {
		return nil
	}
	return s.PinDetails
}

func (s *SingleUseTokenPayload) GetEbtDetails() *EbtDetailsWithVoucher {
	if s == nil {
		return nil
	}
	return s.EbtDetails
}

func (s *SingleUseTokenPayload) GetSecCode() *SingleUseTokenPayloadSecCode {
	if s == nil {
		return nil
	}
	return s.SecCode
}

func (s *SingleUseTokenPayload) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SingleUseTokenPayload) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenPayload) SetAccountType(accountType *SingleUseTokenPayloadAccountType) {
	s.AccountType = accountType
	s.require(singleUseTokenPayloadFieldAccountType)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenPayload) SetToken(token string) {
	s.Token = token
	s.require(singleUseTokenPayloadFieldToken)
}

// SetPinDetails sets the PinDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenPayload) SetPinDetails(pinDetails *SingleUseTokenPayloadPinDetails) {
	s.PinDetails = pinDetails
	s.require(singleUseTokenPayloadFieldPinDetails)
}

// SetEbtDetails sets the EbtDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenPayload) SetEbtDetails(ebtDetails *EbtDetailsWithVoucher) {
	s.EbtDetails = ebtDetails
	s.require(singleUseTokenPayloadFieldEbtDetails)
}

// SetSecCode sets the SecCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SingleUseTokenPayload) SetSecCode(secCode *SingleUseTokenPayloadSecCode) {
	s.SecCode = secCode
	s.require(singleUseTokenPayloadFieldSecCode)
}

func (s *SingleUseTokenPayload) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleUseTokenPayload
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleUseTokenPayload(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleUseTokenPayload) MarshalJSON() ([]byte, error) {
	type embed SingleUseTokenPayload
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SingleUseTokenPayload) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Indicates the customer’s account type.
//
// **Note:** Send a value for accountType only if the single-use token represents bank account details.
type SingleUseTokenPayloadAccountType string

const (
	SingleUseTokenPayloadAccountTypeChecking SingleUseTokenPayloadAccountType = "checking"
	SingleUseTokenPayloadAccountTypeSavings  SingleUseTokenPayloadAccountType = "savings"
)

func NewSingleUseTokenPayloadAccountTypeFromString(s string) (SingleUseTokenPayloadAccountType, error) {
	switch s {
	case "checking":
		return SingleUseTokenPayloadAccountTypeChecking, nil
	case "savings":
		return SingleUseTokenPayloadAccountTypeSavings, nil
	}
	var t SingleUseTokenPayloadAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleUseTokenPayloadAccountType) Ptr() *SingleUseTokenPayloadAccountType {
	return &s
}

// Polymorphic object that contains information about a customer's PIN.
//
// The value of the dataFormat parameter determines which variant you should use:
// - `dukpt` - PIN information is encrypted.
// - `raw` - PIN information is unencrypted.
type SingleUseTokenPayloadPinDetails struct {
	DataFormat string
	Dukpt      *DukptPinDetails
	Raw        *RawPinDetails
}

func (s *SingleUseTokenPayloadPinDetails) GetDataFormat() string {
	if s == nil {
		return ""
	}
	return s.DataFormat
}

func (s *SingleUseTokenPayloadPinDetails) GetDukpt() *DukptPinDetails {
	if s == nil {
		return nil
	}
	return s.Dukpt
}

func (s *SingleUseTokenPayloadPinDetails) GetRaw() *RawPinDetails {
	if s == nil {
		return nil
	}
	return s.Raw
}

func (s *SingleUseTokenPayloadPinDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		DataFormat string `json:"dataFormat"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.DataFormat = unmarshaler.DataFormat
	if unmarshaler.DataFormat == "" {
		return fmt.Errorf("%T did not include discriminant dataFormat", s)
	}
	switch unmarshaler.DataFormat {
	case "dukpt":
		value := new(DukptPinDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Dukpt = value
	case "raw":
		value := new(RawPinDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Raw = value
	}
	return nil
}

func (s SingleUseTokenPayloadPinDetails) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Dukpt != nil {
		return internal.MarshalJSONWithExtraProperty(s.Dukpt, "dataFormat", "dukpt")
	}
	if s.Raw != nil {
		return internal.MarshalJSONWithExtraProperty(s.Raw, "dataFormat", "raw")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleUseTokenPayloadPinDetailsVisitor interface {
	VisitDukpt(*DukptPinDetails) error
	VisitRaw(*RawPinDetails) error
}

func (s *SingleUseTokenPayloadPinDetails) Accept(visitor SingleUseTokenPayloadPinDetailsVisitor) error {
	if s.Dukpt != nil {
		return visitor.VisitDukpt(s.Dukpt)
	}
	if s.Raw != nil {
		return visitor.VisitRaw(s.Raw)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleUseTokenPayloadPinDetails) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Dukpt != nil {
		fields = append(fields, "dukpt")
	}
	if s.Raw != nil {
		fields = append(fields, "raw")
	}
	if len(fields) == 0 {
		if s.DataFormat != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.DataFormat)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.DataFormat != "" {
		field := fields[0]
		if s.DataFormat != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.DataFormat,
				s,
			)
		}
	}
	return nil
}

// Indicates how the customer authorized the ACH transaction. Send one of the following values:
//
// - `web` – Online transaction.
// - `tel` – Telephone transaction.
// - `ccd` – Corporate credit card or debit card transaction.
// - `ppd` – Pre-arranged transaction.
type SingleUseTokenPayloadSecCode string

const (
	SingleUseTokenPayloadSecCodeWeb SingleUseTokenPayloadSecCode = "web"
	SingleUseTokenPayloadSecCodeTel SingleUseTokenPayloadSecCode = "tel"
	SingleUseTokenPayloadSecCodeCcd SingleUseTokenPayloadSecCode = "ccd"
	SingleUseTokenPayloadSecCodePpd SingleUseTokenPayloadSecCode = "ppd"
)

func NewSingleUseTokenPayloadSecCodeFromString(s string) (SingleUseTokenPayloadSecCode, error) {
	switch s {
	case "web":
		return SingleUseTokenPayloadSecCodeWeb, nil
	case "tel":
		return SingleUseTokenPayloadSecCodeTel, nil
	case "ccd":
		return SingleUseTokenPayloadSecCodeCcd, nil
	case "ppd":
		return SingleUseTokenPayloadSecCodePpd, nil
	}
	var t SingleUseTokenPayloadSecCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SingleUseTokenPayloadSecCode) Ptr() *SingleUseTokenPayloadSecCode {
	return &s
}

// Polymorphic object that contains payment card details.
type SingleUseTokenPaymentMethod struct {
	Type string
	Card *CardPayload
}

func (s *SingleUseTokenPaymentMethod) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SingleUseTokenPaymentMethod) GetCard() *CardPayload {
	if s == nil {
		return nil
	}
	return s.Card
}

func (s *SingleUseTokenPaymentMethod) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "card":
		value := new(CardPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Card = value
	}
	return nil
}

func (s SingleUseTokenPaymentMethod) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Card != nil {
		return internal.MarshalJSONWithExtraProperty(s.Card, "type", "card")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleUseTokenPaymentMethodVisitor interface {
	VisitCard(*CardPayload) error
}

func (s *SingleUseTokenPaymentMethod) Accept(visitor SingleUseTokenPaymentMethodVisitor) error {
	if s.Card != nil {
		return visitor.VisitCard(s.Card)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleUseTokenPaymentMethod) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Card != nil {
		fields = append(fields, "card")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// Polymorphic object that contains the payment method that we tokenized.
//
// The value of the type parameter determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`pad` - Pre-authorized debit (PAD) details
// -	`card` - Payment card details
type SingleUseTokenSource struct {
	Type string
	Ach  *AchSource
	Pad  *PadSource
	Card *CardSource
}

func (s *SingleUseTokenSource) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SingleUseTokenSource) GetAch() *AchSource {
	if s == nil {
		return nil
	}
	return s.Ach
}

func (s *SingleUseTokenSource) GetPad() *PadSource {
	if s == nil {
		return nil
	}
	return s.Pad
}

func (s *SingleUseTokenSource) GetCard() *CardSource {
	if s == nil {
		return nil
	}
	return s.Card
}

func (s *SingleUseTokenSource) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(AchSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Ach = value
	case "pad":
		value := new(PadSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Pad = value
	case "card":
		value := new(CardSource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Card = value
	}
	return nil
}

func (s SingleUseTokenSource) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(s.Ach, "type", "ach")
	}
	if s.Pad != nil {
		return internal.MarshalJSONWithExtraProperty(s.Pad, "type", "pad")
	}
	if s.Card != nil {
		return internal.MarshalJSONWithExtraProperty(s.Card, "type", "card")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SingleUseTokenSourceVisitor interface {
	VisitAch(*AchSource) error
	VisitPad(*PadSource) error
	VisitCard(*CardSource) error
}

func (s *SingleUseTokenSource) Accept(visitor SingleUseTokenSourceVisitor) error {
	if s.Ach != nil {
		return visitor.VisitAch(s.Ach)
	}
	if s.Pad != nil {
		return visitor.VisitPad(s.Pad)
	}
	if s.Card != nil {
		return visitor.VisitCard(s.Card)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SingleUseTokenSource) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Ach != nil {
		fields = append(fields, "ach")
	}
	if s.Pad != nil {
		fields = append(fields, "pad")
	}
	if s.Card != nil {
		fields = append(fields, "card")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

// Object that contains the fees for speciality cards.
var (
	specialityCardsFieldTransaction = big.NewInt(1 << 0)
)

type SpecialityCards struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SpecialityCards) GetTransaction() Amount {
	if s == nil {
		return 0
	}
	return s.Transaction
}

func (s *SpecialityCards) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SpecialityCards) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SpecialityCards) SetTransaction(transaction Amount) {
	s.Transaction = transaction
	s.require(specialityCardsFieldTransaction)
}

func (s *SpecialityCards) UnmarshalJSON(data []byte) error {
	type unmarshaler SpecialityCards
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SpecialityCards(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SpecialityCards) MarshalJSON() ([]byte, error) {
	type embed SpecialityCards
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SpecialityCards) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// If you don't use our Subscriptions mechanism, include this section to configure your standing/recurring orders.
var (
	standingInstructionsFieldSequence                = big.NewInt(1 << 0)
	standingInstructionsFieldProcessingModel         = big.NewInt(1 << 1)
	standingInstructionsFieldReferenceDataOfFirstTxn = big.NewInt(1 << 2)
)

type StandingInstructions struct {
	// Position of the transaction in the payment plan sequence.
	Sequence StandingInstructionsSequence `json:"sequence" url:"sequence"`
	// Indicates the type of payment instruction.
	//
	// - 'unscheduled' – The payment is not part of a regular billing cycle.
	// - 'recurring' – The payment is part of a regular billing cycle with no end date.
	// - 'installment' – The payment is part of a regular billing cycle with an end date.
	ProcessingModel StandingInstructionsProcessingModel `json:"processingModel" url:"processingModel"`
	// Object that contains information about the initial payment for the payment instruction.
	ReferenceDataOfFirstTxn *FirstTxnReferenceData `json:"referenceDataOfFirstTxn,omitempty" url:"referenceDataOfFirstTxn,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StandingInstructions) GetSequence() StandingInstructionsSequence {
	if s == nil {
		return ""
	}
	return s.Sequence
}

func (s *StandingInstructions) GetProcessingModel() StandingInstructionsProcessingModel {
	if s == nil {
		return ""
	}
	return s.ProcessingModel
}

func (s *StandingInstructions) GetReferenceDataOfFirstTxn() *FirstTxnReferenceData {
	if s == nil {
		return nil
	}
	return s.ReferenceDataOfFirstTxn
}

func (s *StandingInstructions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StandingInstructions) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSequence sets the Sequence field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandingInstructions) SetSequence(sequence StandingInstructionsSequence) {
	s.Sequence = sequence
	s.require(standingInstructionsFieldSequence)
}

// SetProcessingModel sets the ProcessingModel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandingInstructions) SetProcessingModel(processingModel StandingInstructionsProcessingModel) {
	s.ProcessingModel = processingModel
	s.require(standingInstructionsFieldProcessingModel)
}

// SetReferenceDataOfFirstTxn sets the ReferenceDataOfFirstTxn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StandingInstructions) SetReferenceDataOfFirstTxn(referenceDataOfFirstTxn *FirstTxnReferenceData) {
	s.ReferenceDataOfFirstTxn = referenceDataOfFirstTxn
	s.require(standingInstructionsFieldReferenceDataOfFirstTxn)
}

func (s *StandingInstructions) UnmarshalJSON(data []byte) error {
	type unmarshaler StandingInstructions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StandingInstructions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StandingInstructions) MarshalJSON() ([]byte, error) {
	type embed StandingInstructions
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StandingInstructions) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Indicates the type of payment instruction.
//
// - 'unscheduled' – The payment is not part of a regular billing cycle.
// - 'recurring' – The payment is part of a regular billing cycle with no end date.
// - 'installment' – The payment is part of a regular billing cycle with an end date.
type StandingInstructionsProcessingModel string

const (
	StandingInstructionsProcessingModelUnscheduled StandingInstructionsProcessingModel = "unscheduled"
	StandingInstructionsProcessingModelRecurring   StandingInstructionsProcessingModel = "recurring"
	StandingInstructionsProcessingModelInstallment StandingInstructionsProcessingModel = "installment"
)

func NewStandingInstructionsProcessingModelFromString(s string) (StandingInstructionsProcessingModel, error) {
	switch s {
	case "unscheduled":
		return StandingInstructionsProcessingModelUnscheduled, nil
	case "recurring":
		return StandingInstructionsProcessingModelRecurring, nil
	case "installment":
		return StandingInstructionsProcessingModelInstallment, nil
	}
	var t StandingInstructionsProcessingModel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StandingInstructionsProcessingModel) Ptr() *StandingInstructionsProcessingModel {
	return &s
}

// Position of the transaction in the payment plan sequence.
type StandingInstructionsSequence string

const (
	StandingInstructionsSequenceFirst      StandingInstructionsSequence = "first"
	StandingInstructionsSequenceSubsequent StandingInstructionsSequence = "subsequent"
)

func NewStandingInstructionsSequenceFromString(s string) (StandingInstructionsSequence, error) {
	switch s {
	case "first":
		return StandingInstructionsSequenceFirst, nil
	case "subsequent":
		return StandingInstructionsSequenceSubsequent, nil
	}
	var t StandingInstructionsSequence
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StandingInstructionsSequence) Ptr() *StandingInstructionsSequence {
	return &s
}

// Object that contains information about the adjustment to the transaction. Send this object if the merchant is adjusting the status of the transaction.
var (
	statusAdjustmentFieldToStatus = big.NewInt(1 << 0)
)

type StatusAdjustment struct {
	// Status that you want to change the transaction to.
	ToStatus StatusAdjustmentToStatus `json:"toStatus" url:"toStatus"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StatusAdjustment) GetToStatus() StatusAdjustmentToStatus {
	if s == nil {
		return ""
	}
	return s.ToStatus
}

func (s *StatusAdjustment) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StatusAdjustment) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetToStatus sets the ToStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StatusAdjustment) SetToStatus(toStatus StatusAdjustmentToStatus) {
	s.ToStatus = toStatus
	s.require(statusAdjustmentFieldToStatus)
}

func (s *StatusAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler StatusAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StatusAdjustment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StatusAdjustment) MarshalJSON() ([]byte, error) {
	type embed StatusAdjustment
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StatusAdjustment) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Status that you want to change the transaction to.
type StatusAdjustmentToStatus string

const (
	StatusAdjustmentToStatusReady   StatusAdjustmentToStatus = "ready"
	StatusAdjustmentToStatusPending StatusAdjustmentToStatus = "pending"
)

func NewStatusAdjustmentToStatusFromString(s string) (StatusAdjustmentToStatus, error) {
	switch s {
	case "ready":
		return StatusAdjustmentToStatusReady, nil
	case "pending":
		return StatusAdjustmentToStatusPending, nil
	}
	var t StatusAdjustmentToStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StatusAdjustmentToStatus) Ptr() *StatusAdjustmentToStatus {
	return &s
}

var (
	subscriptionFieldSubscriptionId       = big.NewInt(1 << 0)
	subscriptionFieldProcessingTerminalId = big.NewInt(1 << 1)
	subscriptionFieldPaymentPlan          = big.NewInt(1 << 2)
	subscriptionFieldSecureToken          = big.NewInt(1 << 3)
	subscriptionFieldName                 = big.NewInt(1 << 4)
	subscriptionFieldDescription          = big.NewInt(1 << 5)
	subscriptionFieldCurrency             = big.NewInt(1 << 6)
	subscriptionFieldSetupOrder           = big.NewInt(1 << 7)
	subscriptionFieldRecurringOrder       = big.NewInt(1 << 8)
	subscriptionFieldCurrentState         = big.NewInt(1 << 9)
	subscriptionFieldStartDate            = big.NewInt(1 << 10)
	subscriptionFieldEndDate              = big.NewInt(1 << 11)
	subscriptionFieldLength               = big.NewInt(1 << 12)
	subscriptionFieldType                 = big.NewInt(1 << 13)
	subscriptionFieldFrequency            = big.NewInt(1 << 14)
	subscriptionFieldPauseCollectionFor   = big.NewInt(1 << 15)
	subscriptionFieldCustomFields         = big.NewInt(1 << 16)
)

type Subscription struct {
	// Unique identifier that the merchant assigned to the subscription.
	SubscriptionId string `json:"subscriptionId" url:"subscriptionId"`
	// Unique identifier of the terminal that the subscription is linked to.
	ProcessingTerminalId string              `json:"processingTerminalId" url:"processingTerminalId"`
	PaymentPlan          *PaymentPlanSummary `json:"paymentPlan" url:"paymentPlan"`
	SecureToken          *SecureTokenSummary `json:"secureToken" url:"secureToken"`
	// Name of the subscription.
	Name string `json:"name" url:"name"`
	// Description of the subscription.
	Description    *string                     `json:"description,omitempty" url:"description,omitempty"`
	Currency       Currency                    `json:"currency" url:"currency"`
	SetupOrder     *SubscriptionPaymentOrder   `json:"setupOrder,omitempty" url:"setupOrder,omitempty"`
	RecurringOrder *SubscriptionRecurringOrder `json:"recurringOrder,omitempty" url:"recurringOrder,omitempty"`
	CurrentState   *SubscriptionState          `json:"currentState" url:"currentState"`
	// Format: **YYYY-MM-DD**
	// Subscription's start date.
	StartDate time.Time `json:"startDate" url:"startDate" format:"date"`
	// Format: **YYYY-MM-DD**
	// Subscription's end date.
	// **Note:** If you provide values for both **length** and **endDate**,
	// our gateway uses the value for **endDate** to determine when the subscription should end.
	EndDate *time.Time `json:"endDate,omitempty" url:"endDate,omitempty" format:"date"`
	// Total number of billing cycles. To indicate that the subscription should run indefinitely, send a value of `0`. This value replaces the **length** inherited from the payment plan.
	// **Note:** If you provide values for both **length** and **endDate**, our gateway uses the value for **endDate** to determine when the subscription should end.
	Length *int `json:"length,omitempty" url:"length,omitempty"`
	// How the merchant takes the payment from the customer’s account.
	// - `manual` – The merchant manually collects payments from the customer.
	// - `automatic` – The terminal automatically collects payments from the customer.
	Type SubscriptionType `json:"type" url:"type"`
	// Indicates how often the merchant or the terminal collects a payment from the customer.
	Frequency SubscriptionFrequency `json:"frequency" url:"frequency"`
	// Number of billing cycles that the merchant wants to pause payments for.
	// For example, if the merchant wants to offer a free trial period.
	PauseCollectionFor *int `json:"pauseCollectionFor,omitempty" url:"pauseCollectionFor,omitempty"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Subscription) GetSubscriptionId() string {
	if s == nil {
		return ""
	}
	return s.SubscriptionId
}

func (s *Subscription) GetProcessingTerminalId() string {
	if s == nil {
		return ""
	}
	return s.ProcessingTerminalId
}

func (s *Subscription) GetPaymentPlan() *PaymentPlanSummary {
	if s == nil {
		return nil
	}
	return s.PaymentPlan
}

func (s *Subscription) GetSecureToken() *SecureTokenSummary {
	if s == nil {
		return nil
	}
	return s.SecureToken
}

func (s *Subscription) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *Subscription) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *Subscription) GetCurrency() Currency {
	if s == nil {
		return ""
	}
	return s.Currency
}

func (s *Subscription) GetSetupOrder() *SubscriptionPaymentOrder {
	if s == nil {
		return nil
	}
	return s.SetupOrder
}

func (s *Subscription) GetRecurringOrder() *SubscriptionRecurringOrder {
	if s == nil {
		return nil
	}
	return s.RecurringOrder
}

func (s *Subscription) GetCurrentState() *SubscriptionState {
	if s == nil {
		return nil
	}
	return s.CurrentState
}

func (s *Subscription) GetStartDate() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.StartDate
}

func (s *Subscription) GetEndDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.EndDate
}

func (s *Subscription) GetLength() *int {
	if s == nil {
		return nil
	}
	return s.Length
}

func (s *Subscription) GetType() SubscriptionType {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *Subscription) GetFrequency() SubscriptionFrequency {
	if s == nil {
		return ""
	}
	return s.Frequency
}

func (s *Subscription) GetPauseCollectionFor() *int {
	if s == nil {
		return nil
	}
	return s.PauseCollectionFor
}

func (s *Subscription) GetCustomFields() []*CustomField {
	if s == nil {
		return nil
	}
	return s.CustomFields
}

func (s *Subscription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subscription) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSubscriptionId sets the SubscriptionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetSubscriptionId(subscriptionId string) {
	s.SubscriptionId = subscriptionId
	s.require(subscriptionFieldSubscriptionId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetProcessingTerminalId(processingTerminalId string) {
	s.ProcessingTerminalId = processingTerminalId
	s.require(subscriptionFieldProcessingTerminalId)
}

// SetPaymentPlan sets the PaymentPlan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetPaymentPlan(paymentPlan *PaymentPlanSummary) {
	s.PaymentPlan = paymentPlan
	s.require(subscriptionFieldPaymentPlan)
}

// SetSecureToken sets the SecureToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetSecureToken(secureToken *SecureTokenSummary) {
	s.SecureToken = secureToken
	s.require(subscriptionFieldSecureToken)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetName(name string) {
	s.Name = name
	s.require(subscriptionFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetDescription(description *string) {
	s.Description = description
	s.require(subscriptionFieldDescription)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCurrency(currency Currency) {
	s.Currency = currency
	s.require(subscriptionFieldCurrency)
}

// SetSetupOrder sets the SetupOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetSetupOrder(setupOrder *SubscriptionPaymentOrder) {
	s.SetupOrder = setupOrder
	s.require(subscriptionFieldSetupOrder)
}

// SetRecurringOrder sets the RecurringOrder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetRecurringOrder(recurringOrder *SubscriptionRecurringOrder) {
	s.RecurringOrder = recurringOrder
	s.require(subscriptionFieldRecurringOrder)
}

// SetCurrentState sets the CurrentState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCurrentState(currentState *SubscriptionState) {
	s.CurrentState = currentState
	s.require(subscriptionFieldCurrentState)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetStartDate(startDate time.Time) {
	s.StartDate = startDate
	s.require(subscriptionFieldStartDate)
}

// SetEndDate sets the EndDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetEndDate(endDate *time.Time) {
	s.EndDate = endDate
	s.require(subscriptionFieldEndDate)
}

// SetLength sets the Length field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetLength(length *int) {
	s.Length = length
	s.require(subscriptionFieldLength)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetType(type_ SubscriptionType) {
	s.Type = type_
	s.require(subscriptionFieldType)
}

// SetFrequency sets the Frequency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetFrequency(frequency SubscriptionFrequency) {
	s.Frequency = frequency
	s.require(subscriptionFieldFrequency)
}

// SetPauseCollectionFor sets the PauseCollectionFor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetPauseCollectionFor(pauseCollectionFor *int) {
	s.PauseCollectionFor = pauseCollectionFor
	s.require(subscriptionFieldPauseCollectionFor)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCustomFields(customFields []*CustomField) {
	s.CustomFields = customFields
	s.require(subscriptionFieldCustomFields)
}

func (s *Subscription) UnmarshalJSON(data []byte) error {
	type embed Subscription
	var unmarshaler = struct {
		embed
		StartDate *internal.Date `json:"startDate"`
		EndDate   *internal.Date `json:"endDate,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Subscription(unmarshaler.embed)
	s.StartDate = unmarshaler.StartDate.Time()
	s.EndDate = unmarshaler.EndDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Subscription) MarshalJSON() ([]byte, error) {
	type embed Subscription
	var marshaler = struct {
		embed
		StartDate *internal.Date `json:"startDate"`
		EndDate   *internal.Date `json:"endDate,omitempty"`
	}{
		embed:     embed(*s),
		StartDate: internal.NewDate(s.StartDate),
		EndDate:   internal.NewOptionalDate(s.EndDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Subscription) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Indicates how often the merchant or the terminal collects a payment from the customer.
type SubscriptionFrequency string

const (
	SubscriptionFrequencyWeekly      SubscriptionFrequency = "weekly"
	SubscriptionFrequencyFortnightly SubscriptionFrequency = "fortnightly"
	SubscriptionFrequencyMonthly     SubscriptionFrequency = "monthly"
	SubscriptionFrequencyQuarterly   SubscriptionFrequency = "quarterly"
	SubscriptionFrequencyYearly      SubscriptionFrequency = "yearly"
)

func NewSubscriptionFrequencyFromString(s string) (SubscriptionFrequency, error) {
	switch s {
	case "weekly":
		return SubscriptionFrequencyWeekly, nil
	case "fortnightly":
		return SubscriptionFrequencyFortnightly, nil
	case "monthly":
		return SubscriptionFrequencyMonthly, nil
	case "quarterly":
		return SubscriptionFrequencyQuarterly, nil
	case "yearly":
		return SubscriptionFrequencyYearly, nil
	}
	var t SubscriptionFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionFrequency) Ptr() *SubscriptionFrequency {
	return &s
}

// Object that contains information about the surcharge and taxes that apply to the transaction.
var (
	subscriptionOrderBreakdownFieldSubtotal       = big.NewInt(1 << 0)
	subscriptionOrderBreakdownFieldConvenienceFee = big.NewInt(1 << 1)
	subscriptionOrderBreakdownFieldSurcharge      = big.NewInt(1 << 2)
	subscriptionOrderBreakdownFieldTaxes          = big.NewInt(1 << 3)
)

type SubscriptionOrderBreakdown struct {
	// Total amount for the transaction before tax. The value is in the currency's lowest denomination, for example, cents.
	Subtotal       int64           `json:"subtotal" url:"subtotal"`
	ConvenienceFee *ConvenienceFee `json:"convenienceFee,omitempty" url:"convenienceFee,omitempty"`
	// Object that contains information about the [surcharge](https://docs.payroc.com/knowledge/card-payments/credit-card-surcharging) that we applied to the transaction.
	Surcharge *Surcharge `json:"surcharge,omitempty" url:"surcharge,omitempty"`
	// Array of tax objects.
	Taxes []*RetrievedTax `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionOrderBreakdown) GetSubtotal() int64 {
	if s == nil {
		return 0
	}
	return s.Subtotal
}

func (s *SubscriptionOrderBreakdown) GetConvenienceFee() *ConvenienceFee {
	if s == nil {
		return nil
	}
	return s.ConvenienceFee
}

func (s *SubscriptionOrderBreakdown) GetSurcharge() *Surcharge {
	if s == nil {
		return nil
	}
	return s.Surcharge
}

func (s *SubscriptionOrderBreakdown) GetTaxes() []*RetrievedTax {
	if s == nil {
		return nil
	}
	return s.Taxes
}

func (s *SubscriptionOrderBreakdown) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionOrderBreakdown) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdown) SetSubtotal(subtotal int64) {
	s.Subtotal = subtotal
	s.require(subscriptionOrderBreakdownFieldSubtotal)
}

// SetConvenienceFee sets the ConvenienceFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdown) SetConvenienceFee(convenienceFee *ConvenienceFee) {
	s.ConvenienceFee = convenienceFee
	s.require(subscriptionOrderBreakdownFieldConvenienceFee)
}

// SetSurcharge sets the Surcharge field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdown) SetSurcharge(surcharge *Surcharge) {
	s.Surcharge = surcharge
	s.require(subscriptionOrderBreakdownFieldSurcharge)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdown) SetTaxes(taxes []*RetrievedTax) {
	s.Taxes = taxes
	s.require(subscriptionOrderBreakdownFieldTaxes)
}

func (s *SubscriptionOrderBreakdown) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionOrderBreakdown
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionOrderBreakdown(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionOrderBreakdown) MarshalJSON() ([]byte, error) {
	type embed SubscriptionOrderBreakdown
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionOrderBreakdown) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	subscriptionOrderBreakdownBaseFieldSubtotal       = big.NewInt(1 << 0)
	subscriptionOrderBreakdownBaseFieldConvenienceFee = big.NewInt(1 << 1)
)

type SubscriptionOrderBreakdownBase struct {
	// Total amount for the transaction before tax. The value is in the currency's lowest denomination, for example, cents.
	Subtotal       int64           `json:"subtotal" url:"subtotal"`
	ConvenienceFee *ConvenienceFee `json:"convenienceFee,omitempty" url:"convenienceFee,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionOrderBreakdownBase) GetSubtotal() int64 {
	if s == nil {
		return 0
	}
	return s.Subtotal
}

func (s *SubscriptionOrderBreakdownBase) GetConvenienceFee() *ConvenienceFee {
	if s == nil {
		return nil
	}
	return s.ConvenienceFee
}

func (s *SubscriptionOrderBreakdownBase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionOrderBreakdownBase) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdownBase) SetSubtotal(subtotal int64) {
	s.Subtotal = subtotal
	s.require(subscriptionOrderBreakdownBaseFieldSubtotal)
}

// SetConvenienceFee sets the ConvenienceFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdownBase) SetConvenienceFee(convenienceFee *ConvenienceFee) {
	s.ConvenienceFee = convenienceFee
	s.require(subscriptionOrderBreakdownBaseFieldConvenienceFee)
}

func (s *SubscriptionOrderBreakdownBase) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionOrderBreakdownBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionOrderBreakdownBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionOrderBreakdownBase) MarshalJSON() ([]byte, error) {
	type embed SubscriptionOrderBreakdownBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionOrderBreakdownBase) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the taxes to apply to the transaction.
var (
	subscriptionOrderBreakdownRequestFieldSubtotal       = big.NewInt(1 << 0)
	subscriptionOrderBreakdownRequestFieldConvenienceFee = big.NewInt(1 << 1)
	subscriptionOrderBreakdownRequestFieldTaxes          = big.NewInt(1 << 2)
)

type SubscriptionOrderBreakdownRequest struct {
	// Total amount for the transaction before tax. The value is in the currency's lowest denomination, for example, cents.
	Subtotal       int64           `json:"subtotal" url:"subtotal"`
	ConvenienceFee *ConvenienceFee `json:"convenienceFee,omitempty" url:"convenienceFee,omitempty"`
	// Array of tax objects.
	Taxes []*TaxRate `json:"taxes,omitempty" url:"taxes,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionOrderBreakdownRequest) GetSubtotal() int64 {
	if s == nil {
		return 0
	}
	return s.Subtotal
}

func (s *SubscriptionOrderBreakdownRequest) GetConvenienceFee() *ConvenienceFee {
	if s == nil {
		return nil
	}
	return s.ConvenienceFee
}

func (s *SubscriptionOrderBreakdownRequest) GetTaxes() []*TaxRate {
	if s == nil {
		return nil
	}
	return s.Taxes
}

func (s *SubscriptionOrderBreakdownRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionOrderBreakdownRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSubtotal sets the Subtotal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdownRequest) SetSubtotal(subtotal int64) {
	s.Subtotal = subtotal
	s.require(subscriptionOrderBreakdownRequestFieldSubtotal)
}

// SetConvenienceFee sets the ConvenienceFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdownRequest) SetConvenienceFee(convenienceFee *ConvenienceFee) {
	s.ConvenienceFee = convenienceFee
	s.require(subscriptionOrderBreakdownRequestFieldConvenienceFee)
}

// SetTaxes sets the Taxes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionOrderBreakdownRequest) SetTaxes(taxes []*TaxRate) {
	s.Taxes = taxes
	s.require(subscriptionOrderBreakdownRequestFieldTaxes)
}

func (s *SubscriptionOrderBreakdownRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionOrderBreakdownRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionOrderBreakdownRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionOrderBreakdownRequest) MarshalJSON() ([]byte, error) {
	type embed SubscriptionOrderBreakdownRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionOrderBreakdownRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	subscriptionPaginatedListFieldLimit   = big.NewInt(1 << 0)
	subscriptionPaginatedListFieldCount   = big.NewInt(1 << 1)
	subscriptionPaginatedListFieldHasMore = big.NewInt(1 << 2)
	subscriptionPaginatedListFieldLinks   = big.NewInt(1 << 3)
	subscriptionPaginatedListFieldData    = big.NewInt(1 << 4)
)

type SubscriptionPaginatedList struct {
	// Maximum number of results that we return for each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Number of results we returned on this page.
	//
	// **Note:** This might not be the total number of results that match your query.
	Count *int `json:"count,omitempty" url:"count,omitempty"`
	// Indicates whether there is another page of results available.
	HasMore *bool `json:"hasMore,omitempty" url:"hasMore,omitempty"`
	// Reference links to navigate to the previous page of results or to the next page of results.
	Links []*Link `json:"links,omitempty" url:"links,omitempty"`
	// Array of subscriptions.
	Data []*Subscription `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionPaginatedList) GetLimit() *int {
	if s == nil {
		return nil
	}
	return s.Limit
}

func (s *SubscriptionPaginatedList) GetCount() *int {
	if s == nil {
		return nil
	}
	return s.Count
}

func (s *SubscriptionPaginatedList) GetHasMore() *bool {
	if s == nil {
		return nil
	}
	return s.HasMore
}

func (s *SubscriptionPaginatedList) GetLinks() []*Link {
	if s == nil {
		return nil
	}
	return s.Links
}

func (s *SubscriptionPaginatedList) GetData() []*Subscription {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SubscriptionPaginatedList) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPaginatedList) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaginatedList) SetLimit(limit *int) {
	s.Limit = limit
	s.require(subscriptionPaginatedListFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaginatedList) SetCount(count *int) {
	s.Count = count
	s.require(subscriptionPaginatedListFieldCount)
}

// SetHasMore sets the HasMore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaginatedList) SetHasMore(hasMore *bool) {
	s.HasMore = hasMore
	s.require(subscriptionPaginatedListFieldHasMore)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaginatedList) SetLinks(links []*Link) {
	s.Links = links
	s.require(subscriptionPaginatedListFieldLinks)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaginatedList) SetData(data []*Subscription) {
	s.Data = data
	s.require(subscriptionPaginatedListFieldData)
}

func (s *SubscriptionPaginatedList) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPaginatedList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPaginatedList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPaginatedList) MarshalJSON() ([]byte, error) {
	type embed SubscriptionPaginatedList
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionPaginatedList) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	subscriptionPaymentFieldSubscriptionId       = big.NewInt(1 << 0)
	subscriptionPaymentFieldProcessingTerminalId = big.NewInt(1 << 1)
	subscriptionPaymentFieldPayment              = big.NewInt(1 << 2)
	subscriptionPaymentFieldSecureToken          = big.NewInt(1 << 3)
	subscriptionPaymentFieldCurrentState         = big.NewInt(1 << 4)
	subscriptionPaymentFieldCustomFields         = big.NewInt(1 << 5)
)

type SubscriptionPayment struct {
	// Unique identifier that the merchant assigned to the subscription.
	SubscriptionId string `json:"subscriptionId" url:"subscriptionId"`
	// Unique identifier of the terminal that the subscription is linked to.
	ProcessingTerminalId string              `json:"processingTerminalId" url:"processingTerminalId"`
	Payment              *PaymentSummary     `json:"payment" url:"payment"`
	SecureToken          *SecureTokenSummary `json:"secureToken" url:"secureToken"`
	CurrentState         *SubscriptionState  `json:"currentState" url:"currentState"`
	// Array of customField objects.
	CustomFields []*CustomField `json:"customFields,omitempty" url:"customFields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionPayment) GetSubscriptionId() string {
	if s == nil {
		return ""
	}
	return s.SubscriptionId
}

func (s *SubscriptionPayment) GetProcessingTerminalId() string {
	if s == nil {
		return ""
	}
	return s.ProcessingTerminalId
}

func (s *SubscriptionPayment) GetPayment() *PaymentSummary {
	if s == nil {
		return nil
	}
	return s.Payment
}

func (s *SubscriptionPayment) GetSecureToken() *SecureTokenSummary {
	if s == nil {
		return nil
	}
	return s.SecureToken
}

func (s *SubscriptionPayment) GetCurrentState() *SubscriptionState {
	if s == nil {
		return nil
	}
	return s.CurrentState
}

func (s *SubscriptionPayment) GetCustomFields() []*CustomField {
	if s == nil {
		return nil
	}
	return s.CustomFields
}

func (s *SubscriptionPayment) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPayment) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSubscriptionId sets the SubscriptionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPayment) SetSubscriptionId(subscriptionId string) {
	s.SubscriptionId = subscriptionId
	s.require(subscriptionPaymentFieldSubscriptionId)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPayment) SetProcessingTerminalId(processingTerminalId string) {
	s.ProcessingTerminalId = processingTerminalId
	s.require(subscriptionPaymentFieldProcessingTerminalId)
}

// SetPayment sets the Payment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPayment) SetPayment(payment *PaymentSummary) {
	s.Payment = payment
	s.require(subscriptionPaymentFieldPayment)
}

// SetSecureToken sets the SecureToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPayment) SetSecureToken(secureToken *SecureTokenSummary) {
	s.SecureToken = secureToken
	s.require(subscriptionPaymentFieldSecureToken)
}

// SetCurrentState sets the CurrentState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPayment) SetCurrentState(currentState *SubscriptionState) {
	s.CurrentState = currentState
	s.require(subscriptionPaymentFieldCurrentState)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPayment) SetCustomFields(customFields []*CustomField) {
	s.CustomFields = customFields
	s.require(subscriptionPaymentFieldCustomFields)
}

func (s *SubscriptionPayment) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPayment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPayment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPayment) MarshalJSON() ([]byte, error) {
	type embed SubscriptionPayment
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionPayment) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	subscriptionPaymentOrderFieldOrderId     = big.NewInt(1 << 0)
	subscriptionPaymentOrderFieldAmount      = big.NewInt(1 << 1)
	subscriptionPaymentOrderFieldDescription = big.NewInt(1 << 2)
	subscriptionPaymentOrderFieldBreakdown   = big.NewInt(1 << 3)
)

type SubscriptionPaymentOrder struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Total amount for the transaction. The value is in the currency's lowest denomination, for example, cents.<br/>
	// <br/>**Important:** Do not add the surcharge to the amount parameter in the request. If the transaction is eligible for surcharging, our gateway adds the surcharge to the amount in the request, and then returns the updated amount in the response.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string                     `json:"description,omitempty" url:"description,omitempty"`
	Breakdown   *SubscriptionOrderBreakdown `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionPaymentOrder) GetOrderId() *string {
	if s == nil {
		return nil
	}
	return s.OrderId
}

func (s *SubscriptionPaymentOrder) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *SubscriptionPaymentOrder) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SubscriptionPaymentOrder) GetBreakdown() *SubscriptionOrderBreakdown {
	if s == nil {
		return nil
	}
	return s.Breakdown
}

func (s *SubscriptionPaymentOrder) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPaymentOrder) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrder) SetOrderId(orderId *string) {
	s.OrderId = orderId
	s.require(subscriptionPaymentOrderFieldOrderId)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrder) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(subscriptionPaymentOrderFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrder) SetDescription(description *string) {
	s.Description = description
	s.require(subscriptionPaymentOrderFieldDescription)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrder) SetBreakdown(breakdown *SubscriptionOrderBreakdown) {
	s.Breakdown = breakdown
	s.require(subscriptionPaymentOrderFieldBreakdown)
}

func (s *SubscriptionPaymentOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPaymentOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPaymentOrder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPaymentOrder) MarshalJSON() ([]byte, error) {
	type embed SubscriptionPaymentOrder
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionPaymentOrder) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the initial cost that a customer pays to set up the subscription.
var (
	subscriptionPaymentOrderBaseFieldOrderId     = big.NewInt(1 << 0)
	subscriptionPaymentOrderBaseFieldAmount      = big.NewInt(1 << 1)
	subscriptionPaymentOrderBaseFieldDescription = big.NewInt(1 << 2)
)

type SubscriptionPaymentOrderBase struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Total amount for the transaction. The value is in the currency's lowest denomination, for example, cents.<br/>
	// <br/>**Important:** Do not add the surcharge to the amount parameter in the request. If the transaction is eligible for surcharging, our gateway adds the surcharge to the amount in the request, and then returns the updated amount in the response.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionPaymentOrderBase) GetOrderId() *string {
	if s == nil {
		return nil
	}
	return s.OrderId
}

func (s *SubscriptionPaymentOrderBase) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *SubscriptionPaymentOrderBase) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SubscriptionPaymentOrderBase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPaymentOrderBase) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrderBase) SetOrderId(orderId *string) {
	s.OrderId = orderId
	s.require(subscriptionPaymentOrderBaseFieldOrderId)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrderBase) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(subscriptionPaymentOrderBaseFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrderBase) SetDescription(description *string) {
	s.Description = description
	s.require(subscriptionPaymentOrderBaseFieldDescription)
}

func (s *SubscriptionPaymentOrderBase) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPaymentOrderBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPaymentOrderBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPaymentOrderBase) MarshalJSON() ([]byte, error) {
	type embed SubscriptionPaymentOrderBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionPaymentOrderBase) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	subscriptionPaymentOrderRequestFieldOrderId     = big.NewInt(1 << 0)
	subscriptionPaymentOrderRequestFieldAmount      = big.NewInt(1 << 1)
	subscriptionPaymentOrderRequestFieldDescription = big.NewInt(1 << 2)
	subscriptionPaymentOrderRequestFieldBreakdown   = big.NewInt(1 << 3)
)

type SubscriptionPaymentOrderRequest struct {
	// A unique identifier assigned by the merchant.
	OrderId *string `json:"orderId,omitempty" url:"orderId,omitempty"`
	// Total amount for the transaction. The value is in the currency's lowest denomination, for example, cents.<br/>
	// <br/>**Important:** Do not add the surcharge to the amount parameter in the request. If the transaction is eligible for surcharging, our gateway adds the surcharge to the amount in the request, and then returns the updated amount in the response.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string                            `json:"description,omitempty" url:"description,omitempty"`
	Breakdown   *SubscriptionOrderBreakdownRequest `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionPaymentOrderRequest) GetOrderId() *string {
	if s == nil {
		return nil
	}
	return s.OrderId
}

func (s *SubscriptionPaymentOrderRequest) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *SubscriptionPaymentOrderRequest) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SubscriptionPaymentOrderRequest) GetBreakdown() *SubscriptionOrderBreakdownRequest {
	if s == nil {
		return nil
	}
	return s.Breakdown
}

func (s *SubscriptionPaymentOrderRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPaymentOrderRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrderRequest) SetOrderId(orderId *string) {
	s.OrderId = orderId
	s.require(subscriptionPaymentOrderRequestFieldOrderId)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrderRequest) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(subscriptionPaymentOrderRequestFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrderRequest) SetDescription(description *string) {
	s.Description = description
	s.require(subscriptionPaymentOrderRequestFieldDescription)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionPaymentOrderRequest) SetBreakdown(breakdown *SubscriptionOrderBreakdownRequest) {
	s.Breakdown = breakdown
	s.require(subscriptionPaymentOrderRequestFieldBreakdown)
}

func (s *SubscriptionPaymentOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPaymentOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPaymentOrderRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPaymentOrderRequest) MarshalJSON() ([]byte, error) {
	type embed SubscriptionPaymentOrderRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionPaymentOrderRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the cost of each payment.
var (
	subscriptionRecurringOrderFieldAmount      = big.NewInt(1 << 0)
	subscriptionRecurringOrderFieldDescription = big.NewInt(1 << 1)
	subscriptionRecurringOrderFieldBreakdown   = big.NewInt(1 << 2)
)

type SubscriptionRecurringOrder struct {
	// Total amount for the transaction. The value is in the currency's lowest denomination, for example, cents.<br/>
	// <br/>**Important:** Do not add the surcharge to the amount parameter in the request. If the transaction is eligible for surcharging, our gateway adds the surcharge to the amount in the request, and then returns the updated amount in the response.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string                     `json:"description,omitempty" url:"description,omitempty"`
	Breakdown   *SubscriptionOrderBreakdown `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionRecurringOrder) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *SubscriptionRecurringOrder) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SubscriptionRecurringOrder) GetBreakdown() *SubscriptionOrderBreakdown {
	if s == nil {
		return nil
	}
	return s.Breakdown
}

func (s *SubscriptionRecurringOrder) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionRecurringOrder) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrder) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(subscriptionRecurringOrderFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrder) SetDescription(description *string) {
	s.Description = description
	s.require(subscriptionRecurringOrderFieldDescription)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrder) SetBreakdown(breakdown *SubscriptionOrderBreakdown) {
	s.Breakdown = breakdown
	s.require(subscriptionRecurringOrderFieldBreakdown)
}

func (s *SubscriptionRecurringOrder) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionRecurringOrder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionRecurringOrder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionRecurringOrder) MarshalJSON() ([]byte, error) {
	type embed SubscriptionRecurringOrder
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionRecurringOrder) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	subscriptionRecurringOrderBaseFieldAmount      = big.NewInt(1 << 0)
	subscriptionRecurringOrderBaseFieldDescription = big.NewInt(1 << 1)
)

type SubscriptionRecurringOrderBase struct {
	// Total amount for the transaction. The value is in the currency's lowest denomination, for example, cents.<br/>
	// <br/>**Important:** Do not add the surcharge to the amount parameter in the request. If the transaction is eligible for surcharging, our gateway adds the surcharge to the amount in the request, and then returns the updated amount in the response.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionRecurringOrderBase) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *SubscriptionRecurringOrderBase) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SubscriptionRecurringOrderBase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionRecurringOrderBase) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrderBase) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(subscriptionRecurringOrderBaseFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrderBase) SetDescription(description *string) {
	s.Description = description
	s.require(subscriptionRecurringOrderBaseFieldDescription)
}

func (s *SubscriptionRecurringOrderBase) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionRecurringOrderBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionRecurringOrderBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionRecurringOrderBase) MarshalJSON() ([]byte, error) {
	type embed SubscriptionRecurringOrderBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionRecurringOrderBase) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the cost of each payment.
// **Note:** Send this object only if the value for **type** is `automatic`.
var (
	subscriptionRecurringOrderRequestFieldAmount      = big.NewInt(1 << 0)
	subscriptionRecurringOrderRequestFieldDescription = big.NewInt(1 << 1)
	subscriptionRecurringOrderRequestFieldBreakdown   = big.NewInt(1 << 2)
)

type SubscriptionRecurringOrderRequest struct {
	// Total amount for the transaction. The value is in the currency's lowest denomination, for example, cents.<br/>
	// <br/>**Important:** Do not add the surcharge to the amount parameter in the request. If the transaction is eligible for surcharging, our gateway adds the surcharge to the amount in the request, and then returns the updated amount in the response.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Description of the transaction.
	Description *string                            `json:"description,omitempty" url:"description,omitempty"`
	Breakdown   *SubscriptionOrderBreakdownRequest `json:"breakdown,omitempty" url:"breakdown,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionRecurringOrderRequest) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *SubscriptionRecurringOrderRequest) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SubscriptionRecurringOrderRequest) GetBreakdown() *SubscriptionOrderBreakdownRequest {
	if s == nil {
		return nil
	}
	return s.Breakdown
}

func (s *SubscriptionRecurringOrderRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionRecurringOrderRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrderRequest) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(subscriptionRecurringOrderRequestFieldAmount)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrderRequest) SetDescription(description *string) {
	s.Description = description
	s.require(subscriptionRecurringOrderRequestFieldDescription)
}

// SetBreakdown sets the Breakdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionRecurringOrderRequest) SetBreakdown(breakdown *SubscriptionOrderBreakdownRequest) {
	s.Breakdown = breakdown
	s.require(subscriptionRecurringOrderRequestFieldBreakdown)
}

func (s *SubscriptionRecurringOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionRecurringOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionRecurringOrderRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionRecurringOrderRequest) MarshalJSON() ([]byte, error) {
	type embed SubscriptionRecurringOrderRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionRecurringOrderRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A snapshot of the subscription's current state.
var (
	subscriptionStateFieldStatus              = big.NewInt(1 << 0)
	subscriptionStateFieldNextDueDate         = big.NewInt(1 << 1)
	subscriptionStateFieldPaidInvoices        = big.NewInt(1 << 2)
	subscriptionStateFieldOutstandingInvoices = big.NewInt(1 << 3)
)

type SubscriptionState struct {
	// Status of the Subscription.
	//
	// - 'active' - Subscription is active.
	// - 'completed' - Subscription has reached the end date or the total number of billing cycles.
	// - 'cancelled' - Merchant deactivated the subscription.
	// - 'suspended' - Subscription is suspended. For example, if the customer misses payments.
	Status SubscriptionStateStatus `json:"status" url:"status"`
	// Date that the merchant collects the next payment.
	NextDueDate *time.Time `json:"nextDueDate,omitempty" url:"nextDueDate,omitempty" format:"date"`
	// Number of payments that the merchant has collected.
	PaidInvoices int `json:"paidInvoices" url:"paidInvoices"`
	// Number of payments until the end of the subscription.
	// Our gateway returns a value for **outstandingInvoices** only if the subscription
	// has an end date or a fixed number of billing cycles.
	OutstandingInvoices *int `json:"outstandingInvoices,omitempty" url:"outstandingInvoices,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionState) GetStatus() SubscriptionStateStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SubscriptionState) GetNextDueDate() *time.Time {
	if s == nil {
		return nil
	}
	return s.NextDueDate
}

func (s *SubscriptionState) GetPaidInvoices() int {
	if s == nil {
		return 0
	}
	return s.PaidInvoices
}

func (s *SubscriptionState) GetOutstandingInvoices() *int {
	if s == nil {
		return nil
	}
	return s.OutstandingInvoices
}

func (s *SubscriptionState) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionState) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionState) SetStatus(status SubscriptionStateStatus) {
	s.Status = status
	s.require(subscriptionStateFieldStatus)
}

// SetNextDueDate sets the NextDueDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionState) SetNextDueDate(nextDueDate *time.Time) {
	s.NextDueDate = nextDueDate
	s.require(subscriptionStateFieldNextDueDate)
}

// SetPaidInvoices sets the PaidInvoices field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionState) SetPaidInvoices(paidInvoices int) {
	s.PaidInvoices = paidInvoices
	s.require(subscriptionStateFieldPaidInvoices)
}

// SetOutstandingInvoices sets the OutstandingInvoices field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionState) SetOutstandingInvoices(outstandingInvoices *int) {
	s.OutstandingInvoices = outstandingInvoices
	s.require(subscriptionStateFieldOutstandingInvoices)
}

func (s *SubscriptionState) UnmarshalJSON(data []byte) error {
	type embed SubscriptionState
	var unmarshaler = struct {
		embed
		NextDueDate *internal.Date `json:"nextDueDate,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SubscriptionState(unmarshaler.embed)
	s.NextDueDate = unmarshaler.NextDueDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionState) MarshalJSON() ([]byte, error) {
	type embed SubscriptionState
	var marshaler = struct {
		embed
		NextDueDate *internal.Date `json:"nextDueDate,omitempty"`
	}{
		embed:       embed(*s),
		NextDueDate: internal.NewOptionalDate(s.NextDueDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionState) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Status of the Subscription.
//
// - 'active' - Subscription is active.
// - 'completed' - Subscription has reached the end date or the total number of billing cycles.
// - 'cancelled' - Merchant deactivated the subscription.
// - 'suspended' - Subscription is suspended. For example, if the customer misses payments.
type SubscriptionStateStatus string

const (
	SubscriptionStateStatusActive    SubscriptionStateStatus = "active"
	SubscriptionStateStatusCompleted SubscriptionStateStatus = "completed"
	SubscriptionStateStatusSuspended SubscriptionStateStatus = "suspended"
	SubscriptionStateStatusCancelled SubscriptionStateStatus = "cancelled"
)

func NewSubscriptionStateStatusFromString(s string) (SubscriptionStateStatus, error) {
	switch s {
	case "active":
		return SubscriptionStateStatusActive, nil
	case "completed":
		return SubscriptionStateStatusCompleted, nil
	case "suspended":
		return SubscriptionStateStatusSuspended, nil
	case "cancelled":
		return SubscriptionStateStatusCancelled, nil
	}
	var t SubscriptionStateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStateStatus) Ptr() *SubscriptionStateStatus {
	return &s
}

// How the merchant takes the payment from the customer’s account.
// - `manual` – The merchant manually collects payments from the customer.
// - `automatic` – The terminal automatically collects payments from the customer.
type SubscriptionType string

const (
	SubscriptionTypeManual    SubscriptionType = "manual"
	SubscriptionTypeAutomatic SubscriptionType = "automatic"
)

func NewSubscriptionTypeFromString(s string) (SubscriptionType, error) {
	switch s {
	case "manual":
		return SubscriptionTypeManual, nil
	case "automatic":
		return SubscriptionTypeAutomatic, nil
	}
	var t SubscriptionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionType) Ptr() *SubscriptionType {
	return &s
}

// Array of operations that you can perform on the transaction.
// - `capture`                - Capture the payment.
// - `refund`                 - Refund the payment.
// - `fullyReverse`           - Fully reverse the transaction.
// - `partiallyReverse`       - Partially reverse the payment.
// - `incrementAuthorization` - Increase the amount of the authorization.
// - `adjustTip`              - Adjust the tip post-payment.
// - `addSignature`           - Add a signature to the payment.
// - `setAsReady`             - Set the transaction’s status to `ready`.
// - `setAsPending`           - Set the transaction’s status to `pending`.
type SupportedOperations = []SupportedOperationsItem

type SupportedOperationsItem string

const (
	SupportedOperationsItemCapture                SupportedOperationsItem = "capture"
	SupportedOperationsItemRefund                 SupportedOperationsItem = "refund"
	SupportedOperationsItemFullyReverse           SupportedOperationsItem = "fullyReverse"
	SupportedOperationsItemPartiallyReverse       SupportedOperationsItem = "partiallyReverse"
	SupportedOperationsItemIncrementAuthorization SupportedOperationsItem = "incrementAuthorization"
	SupportedOperationsItemAdjustTip              SupportedOperationsItem = "adjustTip"
	SupportedOperationsItemAddSignature           SupportedOperationsItem = "addSignature"
	SupportedOperationsItemSetAsReady             SupportedOperationsItem = "setAsReady"
	SupportedOperationsItemSetAsPending           SupportedOperationsItem = "setAsPending"
)

func NewSupportedOperationsItemFromString(s string) (SupportedOperationsItem, error) {
	switch s {
	case "capture":
		return SupportedOperationsItemCapture, nil
	case "refund":
		return SupportedOperationsItemRefund, nil
	case "fullyReverse":
		return SupportedOperationsItemFullyReverse, nil
	case "partiallyReverse":
		return SupportedOperationsItemPartiallyReverse, nil
	case "incrementAuthorization":
		return SupportedOperationsItemIncrementAuthorization, nil
	case "adjustTip":
		return SupportedOperationsItemAdjustTip, nil
	case "addSignature":
		return SupportedOperationsItemAddSignature, nil
	case "setAsReady":
		return SupportedOperationsItemSetAsReady, nil
	case "setAsPending":
		return SupportedOperationsItemSetAsPending, nil
	}
	var t SupportedOperationsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SupportedOperationsItem) Ptr() *SupportedOperationsItem {
	return &s
}

// Object that contains information about the surcharge.
var (
	surchargeFieldBypass     = big.NewInt(1 << 0)
	surchargeFieldAmount     = big.NewInt(1 << 1)
	surchargeFieldPercentage = big.NewInt(1 << 2)
)

type Surcharge struct {
	// Indicates if the merchant wants to remove the surcharge fee from the transaction.
	// - `true` - Gateway removes the surcharge fee from the transaction.
	// - `false` - Gateway adds the fee to the transaction.
	Bypass *bool `json:"bypass,omitempty" url:"bypass,omitempty"`
	// If the merchant added a surcharge fee, this value indicates the amount of the surcharge fee
	// in the currency’s lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// If the merchant added a surcharge fee, this value indicates the surcharge percentage.
	Percentage *float64 `json:"percentage,omitempty" url:"percentage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Surcharge) GetBypass() *bool {
	if s == nil {
		return nil
	}
	return s.Bypass
}

func (s *Surcharge) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *Surcharge) GetPercentage() *float64 {
	if s == nil {
		return nil
	}
	return s.Percentage
}

func (s *Surcharge) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Surcharge) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetBypass sets the Bypass field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Surcharge) SetBypass(bypass *bool) {
	s.Bypass = bypass
	s.require(surchargeFieldBypass)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Surcharge) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(surchargeFieldAmount)
}

// SetPercentage sets the Percentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Surcharge) SetPercentage(percentage *float64) {
	s.Percentage = percentage
	s.require(surchargeFieldPercentage)
}

func (s *Surcharge) UnmarshalJSON(data []byte) error {
	type unmarshaler Surcharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Surcharge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Surcharge) MarshalJSON() ([]byte, error) {
	type embed Surcharge
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Surcharge) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains surcharge information. Our gateway returns this object only if the merchant adds a surcharge to transactions.
var (
	surchargingFieldAllowed    = big.NewInt(1 << 0)
	surchargingFieldAmount     = big.NewInt(1 << 1)
	surchargingFieldPercentage = big.NewInt(1 << 2)
	surchargingFieldDisclosure = big.NewInt(1 << 3)
)

type Surcharging struct {
	// Indicates if the merchant can add a surcharge when the customer uses this card.
	Allowed bool `json:"allowed" url:"allowed"`
	// Surcharge amount to add to the transaction.
	// **Note:** Our gateway returns the surcharge amount only if you include a transaction amount in the request.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// Surcharge rate that the merchant configures on their account.
	Percentage *float64 `json:"percentage,omitempty" url:"percentage,omitempty"`
	// Statement that informs the customer about the surcharge fee.
	Disclosure *string `json:"disclosure,omitempty" url:"disclosure,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Surcharging) GetAllowed() bool {
	if s == nil {
		return false
	}
	return s.Allowed
}

func (s *Surcharging) GetAmount() *int64 {
	if s == nil {
		return nil
	}
	return s.Amount
}

func (s *Surcharging) GetPercentage() *float64 {
	if s == nil {
		return nil
	}
	return s.Percentage
}

func (s *Surcharging) GetDisclosure() *string {
	if s == nil {
		return nil
	}
	return s.Disclosure
}

func (s *Surcharging) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Surcharging) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAllowed sets the Allowed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Surcharging) SetAllowed(allowed bool) {
	s.Allowed = allowed
	s.require(surchargingFieldAllowed)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Surcharging) SetAmount(amount *int64) {
	s.Amount = amount
	s.require(surchargingFieldAmount)
}

// SetPercentage sets the Percentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Surcharging) SetPercentage(percentage *float64) {
	s.Percentage = percentage
	s.require(surchargingFieldPercentage)
}

// SetDisclosure sets the Disclosure field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Surcharging) SetDisclosure(disclosure *string) {
	s.Disclosure = disclosure
	s.require(surchargingFieldDisclosure)
}

func (s *Surcharging) UnmarshalJSON(data []byte) error {
	type unmarshaler Surcharging
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Surcharging(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Surcharging) MarshalJSON() ([]byte, error) {
	type embed Surcharging
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Surcharging) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Object that contains information about the customer’s card details for swiped transactions.
var (
	swipedCardDetailsFieldDowngradeTo         = big.NewInt(1 << 0)
	swipedCardDetailsFieldSwipedData          = big.NewInt(1 << 1)
	swipedCardDetailsFieldCardholderName      = big.NewInt(1 << 2)
	swipedCardDetailsFieldCardholderSignature = big.NewInt(1 << 3)
	swipedCardDetailsFieldPinDetails          = big.NewInt(1 << 4)
	swipedCardDetailsFieldEbtDetails          = big.NewInt(1 << 5)
)

type SwipedCardDetails struct {
	// If an offline transaction is not approved using the initial entry method, reprocess the transaction using a downgraded entry method.
	// For example, a swiped transaction can be downgraded to a keyed transaction.
	DowngradeTo *SwipedCardDetailsDowngradeTo `json:"downgradeTo,omitempty" url:"downgradeTo,omitempty"`
	// Polymorphic object that contains payment card details that a device captured from the magnetic strip.
	//
	// The value of the dataFormat parameter determines which variant you should use:
	// -	`encrypted` - Payment card details are encrypted.
	// -	`plainText` - Payment card details are in plain text.
	SwipedData *SwipedCardDetailsSwipedData `json:"swipedData" url:"swipedData"`
	// Cardholder’s name.
	CardholderName *string `json:"cardholderName,omitempty" url:"cardholderName,omitempty"`
	// Cardholder's signature. For more information about how to format the signature, go to [How to send a signature to our gateway](https://docs.payroc.com/knowledge/basic-concepts/signature-capture).
	CardholderSignature *string `json:"cardholderSignature,omitempty" url:"cardholderSignature,omitempty"`
	// Polymorphic object that contains information about the customer's PIN.
	PinDetails *SwipedCardDetailsPinDetails `json:"pinDetails,omitempty" url:"pinDetails,omitempty"`
	EbtDetails *EbtDetailsWithVoucher       `json:"ebtDetails,omitempty" url:"ebtDetails,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SwipedCardDetails) GetDowngradeTo() *SwipedCardDetailsDowngradeTo {
	if s == nil {
		return nil
	}
	return s.DowngradeTo
}

func (s *SwipedCardDetails) GetSwipedData() *SwipedCardDetailsSwipedData {
	if s == nil {
		return nil
	}
	return s.SwipedData
}

func (s *SwipedCardDetails) GetCardholderName() *string {
	if s == nil {
		return nil
	}
	return s.CardholderName
}

func (s *SwipedCardDetails) GetCardholderSignature() *string {
	if s == nil {
		return nil
	}
	return s.CardholderSignature
}

func (s *SwipedCardDetails) GetPinDetails() *SwipedCardDetailsPinDetails {
	if s == nil {
		return nil
	}
	return s.PinDetails
}

func (s *SwipedCardDetails) GetEbtDetails() *EbtDetailsWithVoucher {
	if s == nil {
		return nil
	}
	return s.EbtDetails
}

func (s *SwipedCardDetails) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SwipedCardDetails) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDowngradeTo sets the DowngradeTo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwipedCardDetails) SetDowngradeTo(downgradeTo *SwipedCardDetailsDowngradeTo) {
	s.DowngradeTo = downgradeTo
	s.require(swipedCardDetailsFieldDowngradeTo)
}

// SetSwipedData sets the SwipedData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwipedCardDetails) SetSwipedData(swipedData *SwipedCardDetailsSwipedData) {
	s.SwipedData = swipedData
	s.require(swipedCardDetailsFieldSwipedData)
}

// SetCardholderName sets the CardholderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwipedCardDetails) SetCardholderName(cardholderName *string) {
	s.CardholderName = cardholderName
	s.require(swipedCardDetailsFieldCardholderName)
}

// SetCardholderSignature sets the CardholderSignature field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwipedCardDetails) SetCardholderSignature(cardholderSignature *string) {
	s.CardholderSignature = cardholderSignature
	s.require(swipedCardDetailsFieldCardholderSignature)
}

// SetPinDetails sets the PinDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwipedCardDetails) SetPinDetails(pinDetails *SwipedCardDetailsPinDetails) {
	s.PinDetails = pinDetails
	s.require(swipedCardDetailsFieldPinDetails)
}

// SetEbtDetails sets the EbtDetails field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwipedCardDetails) SetEbtDetails(ebtDetails *EbtDetailsWithVoucher) {
	s.EbtDetails = ebtDetails
	s.require(swipedCardDetailsFieldEbtDetails)
}

func (s *SwipedCardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler SwipedCardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SwipedCardDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SwipedCardDetails) MarshalJSON() ([]byte, error) {
	type embed SwipedCardDetails
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SwipedCardDetails) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// If an offline transaction is not approved using the initial entry method, reprocess the transaction using a downgraded entry method.
// For example, a swiped transaction can be downgraded to a keyed transaction.
type SwipedCardDetailsDowngradeTo string

const (
	SwipedCardDetailsDowngradeToKeyed  SwipedCardDetailsDowngradeTo = "keyed"
	SwipedCardDetailsDowngradeToSwiped SwipedCardDetailsDowngradeTo = "swiped"
)

func NewSwipedCardDetailsDowngradeToFromString(s string) (SwipedCardDetailsDowngradeTo, error) {
	switch s {
	case "keyed":
		return SwipedCardDetailsDowngradeToKeyed, nil
	case "swiped":
		return SwipedCardDetailsDowngradeToSwiped, nil
	}
	var t SwipedCardDetailsDowngradeTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SwipedCardDetailsDowngradeTo) Ptr() *SwipedCardDetailsDowngradeTo {
	return &s
}

// Polymorphic object that contains information about the customer's PIN.
type SwipedCardDetailsPinDetails struct {
	DataFormat string
	Dukpt      *DukptPinDetails
}

func (s *SwipedCardDetailsPinDetails) GetDataFormat() string {
	if s == nil {
		return ""
	}
	return s.DataFormat
}

func (s *SwipedCardDetailsPinDetails) GetDukpt() *DukptPinDetails {
	if s == nil {
		return nil
	}
	return s.Dukpt
}

func (s *SwipedCardDetailsPinDetails) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		DataFormat string `json:"dataFormat"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.DataFormat = unmarshaler.DataFormat
	if unmarshaler.DataFormat == "" {
		return fmt.Errorf("%T did not include discriminant dataFormat", s)
	}
	switch unmarshaler.DataFormat {
	case "dukpt":
		value := new(DukptPinDetails)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Dukpt = value
	}
	return nil
}

func (s SwipedCardDetailsPinDetails) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Dukpt != nil {
		return internal.MarshalJSONWithExtraProperty(s.Dukpt, "dataFormat", "dukpt")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SwipedCardDetailsPinDetailsVisitor interface {
	VisitDukpt(*DukptPinDetails) error
}

func (s *SwipedCardDetailsPinDetails) Accept(visitor SwipedCardDetailsPinDetailsVisitor) error {
	if s.Dukpt != nil {
		return visitor.VisitDukpt(s.Dukpt)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SwipedCardDetailsPinDetails) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Dukpt != nil {
		fields = append(fields, "dukpt")
	}
	if len(fields) == 0 {
		if s.DataFormat != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.DataFormat)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.DataFormat != "" {
		field := fields[0]
		if s.DataFormat != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.DataFormat,
				s,
			)
		}
	}
	return nil
}

// Polymorphic object that contains payment card details that a device captured from the magnetic strip.
//
// The value of the dataFormat parameter determines which variant you should use:
// -	`encrypted` - Payment card details are encrypted.
// -	`plainText` - Payment card details are in plain text.
type SwipedCardDetailsSwipedData struct {
	DataFormat string
	Encrypted  *EncryptedSwipedDataFormat
	PlainText  *PlainTextSwipedDataFormat
}

func (s *SwipedCardDetailsSwipedData) GetDataFormat() string {
	if s == nil {
		return ""
	}
	return s.DataFormat
}

func (s *SwipedCardDetailsSwipedData) GetEncrypted() *EncryptedSwipedDataFormat {
	if s == nil {
		return nil
	}
	return s.Encrypted
}

func (s *SwipedCardDetailsSwipedData) GetPlainText() *PlainTextSwipedDataFormat {
	if s == nil {
		return nil
	}
	return s.PlainText
}

func (s *SwipedCardDetailsSwipedData) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		DataFormat string `json:"dataFormat"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.DataFormat = unmarshaler.DataFormat
	if unmarshaler.DataFormat == "" {
		return fmt.Errorf("%T did not include discriminant dataFormat", s)
	}
	switch unmarshaler.DataFormat {
	case "encrypted":
		value := new(EncryptedSwipedDataFormat)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Encrypted = value
	case "plainText":
		value := new(PlainTextSwipedDataFormat)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.PlainText = value
	}
	return nil
}

func (s SwipedCardDetailsSwipedData) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Encrypted != nil {
		return internal.MarshalJSONWithExtraProperty(s.Encrypted, "dataFormat", "encrypted")
	}
	if s.PlainText != nil {
		return internal.MarshalJSONWithExtraProperty(s.PlainText, "dataFormat", "plainText")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SwipedCardDetailsSwipedDataVisitor interface {
	VisitEncrypted(*EncryptedSwipedDataFormat) error
	VisitPlainText(*PlainTextSwipedDataFormat) error
}

func (s *SwipedCardDetailsSwipedData) Accept(visitor SwipedCardDetailsSwipedDataVisitor) error {
	if s.Encrypted != nil {
		return visitor.VisitEncrypted(s.Encrypted)
	}
	if s.PlainText != nil {
		return visitor.VisitPlainText(s.PlainText)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SwipedCardDetailsSwipedData) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Encrypted != nil {
		fields = append(fields, "encrypted")
	}
	if s.PlainText != nil {
		fields = append(fields, "plainText")
	}
	if len(fields) == 0 {
		if s.DataFormat != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.DataFormat)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.DataFormat != "" {
		field := fields[0]
		if s.DataFormat != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.DataFormat,
				s,
			)
		}
	}
	return nil
}

// Polymorphic object that contains tax details.
//
// The value of the type parameter determines which variant you should use:
// -	`amount` - Tax is a fixed amount.
// -	`rate` - Tax is a percentage.
type Tax struct {
	Type   string
	Amount *TaxAmount
	Rate   *TaxRate
}

func (t *Tax) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Tax) GetAmount() *TaxAmount {
	if t == nil {
		return nil
	}
	return t.Amount
}

func (t *Tax) GetRate() *TaxRate {
	if t == nil {
		return nil
	}
	return t.Rate
}

func (t *Tax) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "amount":
		value := new(TaxAmount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Amount = value
	case "rate":
		value := new(TaxRate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Rate = value
	}
	return nil
}

func (t Tax) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.Amount != nil {
		return internal.MarshalJSONWithExtraProperty(t.Amount, "type", "amount")
	}
	if t.Rate != nil {
		return internal.MarshalJSONWithExtraProperty(t.Rate, "type", "rate")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type TaxVisitor interface {
	VisitAmount(*TaxAmount) error
	VisitRate(*TaxRate) error
}

func (t *Tax) Accept(visitor TaxVisitor) error {
	if t.Amount != nil {
		return visitor.VisitAmount(t.Amount)
	}
	if t.Rate != nil {
		return visitor.VisitRate(t.Rate)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *Tax) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.Amount != nil {
		fields = append(fields, "amount")
	}
	if t.Rate != nil {
		fields = append(fields, "rate")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

var (
	taxAmountFieldAmount = big.NewInt(1 << 0)
	taxAmountFieldName   = big.NewInt(1 << 1)
)

type TaxAmount struct {
	// Tax amount for the transaction. The value is in the currency's lowest denomination, for example, cents.
	Amount int64 `json:"amount" url:"amount"`
	// Name of the tax.
	Name string `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaxAmount) GetAmount() int64 {
	if t == nil {
		return 0
	}
	return t.Amount
}

func (t *TaxAmount) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *TaxAmount) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxAmount) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TaxAmount) SetAmount(amount int64) {
	t.Amount = amount
	t.require(taxAmountFieldAmount)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TaxAmount) SetName(name string) {
	t.Name = name
	t.require(taxAmountFieldName)
}

func (t *TaxAmount) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxAmount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxAmount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxAmount) MarshalJSON() ([]byte, error) {
	type embed TaxAmount
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TaxAmount) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	taxRateFieldType = big.NewInt(1 << 0)
	taxRateFieldRate = big.NewInt(1 << 1)
	taxRateFieldName = big.NewInt(1 << 2)
)

type TaxRate struct {
	// Indicates that the tax is a rate.
	Type TaxRateType `json:"type" url:"type"`
	// Tax percentage for the transaction.
	Rate float64 `json:"rate" url:"rate"`
	// Name of the tax. A tax validation on the stored rate for the tax name is performed.
	Name string `json:"name" url:"name"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaxRate) GetType() TaxRateType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TaxRate) GetRate() float64 {
	if t == nil {
		return 0
	}
	return t.Rate
}

func (t *TaxRate) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *TaxRate) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxRate) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TaxRate) SetType(type_ TaxRateType) {
	t.Type = type_
	t.require(taxRateFieldType)
}

// SetRate sets the Rate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TaxRate) SetRate(rate float64) {
	t.Rate = rate
	t.require(taxRateFieldRate)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TaxRate) SetName(name string) {
	t.Name = name
	t.require(taxRateFieldName)
}

func (t *TaxRate) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxRate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxRate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxRate) MarshalJSON() ([]byte, error) {
	type embed TaxRate
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TaxRate) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates that the tax is a rate.
type TaxRateType string

const (
	TaxRateTypeRate TaxRateType = "rate"
)

func NewTaxRateTypeFromString(s string) (TaxRateType, error) {
	switch s {
	case "rate":
		return TaxRateTypeRate, nil
	}
	var t TaxRateType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxRateType) Ptr() *TaxRateType {
	return &t
}

var (
	terminalOrderFieldTerminalOrderId  = big.NewInt(1 << 0)
	terminalOrderFieldStatus           = big.NewInt(1 << 1)
	terminalOrderFieldTrainingProvider = big.NewInt(1 << 2)
	terminalOrderFieldShipping         = big.NewInt(1 << 3)
	terminalOrderFieldOrderItems       = big.NewInt(1 << 4)
	terminalOrderFieldCreatedDate      = big.NewInt(1 << 5)
	terminalOrderFieldLastModifiedDate = big.NewInt(1 << 6)
)

type TerminalOrder struct {
	// Unique identifier that we assigned to the terminal order.
	TerminalOrderId string `json:"terminalOrderId" url:"terminalOrderId"`
	// Status of the terminal order.
	//
	// **Note**: You can subscribe to our terminalOrder.status.changed event to get notifications when we update the status of a terminal order. For more information about how to subscribe to events, go to [Event Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).
	Status TerminalOrderStatus `json:"status" url:"status"`
	// Indicates who provides training to the merchant for the solution.
	TrainingProvider *TerminalOrderTrainingProvider `json:"trainingProvider,omitempty" url:"trainingProvider,omitempty"`
	// Object that contains the shipping details for the terminal order. If you don't provide a shipping address, we use the Doing Business As (DBA) address of the processing account.
	Shipping *TerminalOrderShipping `json:"shipping,omitempty" url:"shipping,omitempty"`
	// Array of orderItem objects. Provide a minimum of 1 order item and a maximum of 20 order items.
	OrderItems []*TerminalOrderOrderItemsItem `json:"orderItems" url:"orderItems"`
	// Date that we received the terminal order. We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Date that the terminal order was last changed.  We return this value in the [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html) format.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalOrder) GetTerminalOrderId() string {
	if t == nil {
		return ""
	}
	return t.TerminalOrderId
}

func (t *TerminalOrder) GetStatus() TerminalOrderStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TerminalOrder) GetTrainingProvider() *TerminalOrderTrainingProvider {
	if t == nil {
		return nil
	}
	return t.TrainingProvider
}

func (t *TerminalOrder) GetShipping() *TerminalOrderShipping {
	if t == nil {
		return nil
	}
	return t.Shipping
}

func (t *TerminalOrder) GetOrderItems() []*TerminalOrderOrderItemsItem {
	if t == nil {
		return nil
	}
	return t.OrderItems
}

func (t *TerminalOrder) GetCreatedDate() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedDate
}

func (t *TerminalOrder) GetLastModifiedDate() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastModifiedDate
}

func (t *TerminalOrder) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalOrder) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTerminalOrderId sets the TerminalOrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrder) SetTerminalOrderId(terminalOrderId string) {
	t.TerminalOrderId = terminalOrderId
	t.require(terminalOrderFieldTerminalOrderId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrder) SetStatus(status TerminalOrderStatus) {
	t.Status = status
	t.require(terminalOrderFieldStatus)
}

// SetTrainingProvider sets the TrainingProvider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrder) SetTrainingProvider(trainingProvider *TerminalOrderTrainingProvider) {
	t.TrainingProvider = trainingProvider
	t.require(terminalOrderFieldTrainingProvider)
}

// SetShipping sets the Shipping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrder) SetShipping(shipping *TerminalOrderShipping) {
	t.Shipping = shipping
	t.require(terminalOrderFieldShipping)
}

// SetOrderItems sets the OrderItems field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrder) SetOrderItems(orderItems []*TerminalOrderOrderItemsItem) {
	t.OrderItems = orderItems
	t.require(terminalOrderFieldOrderItems)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrder) SetCreatedDate(createdDate *time.Time) {
	t.CreatedDate = createdDate
	t.require(terminalOrderFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrder) SetLastModifiedDate(lastModifiedDate *time.Time) {
	t.LastModifiedDate = lastModifiedDate
	t.require(terminalOrderFieldLastModifiedDate)
}

func (t *TerminalOrder) UnmarshalJSON(data []byte) error {
	type embed TerminalOrder
	var unmarshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TerminalOrder(unmarshaler.embed)
	t.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	t.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalOrder) MarshalJSON() ([]byte, error) {
	type embed TerminalOrder
	var marshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*t),
		CreatedDate:      internal.NewOptionalDateTime(t.CreatedDate),
		LastModifiedDate: internal.NewOptionalDateTime(t.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TerminalOrder) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	terminalOrderOrderItemsItemFieldType               = big.NewInt(1 << 0)
	terminalOrderOrderItemsItemFieldSolutionTemplateId = big.NewInt(1 << 1)
	terminalOrderOrderItemsItemFieldSolutionQuantity   = big.NewInt(1 << 2)
	terminalOrderOrderItemsItemFieldDeviceCondition    = big.NewInt(1 << 3)
	terminalOrderOrderItemsItemFieldSolutionSetup      = big.NewInt(1 << 4)
	terminalOrderOrderItemsItemFieldLinks              = big.NewInt(1 << 5)
)

type TerminalOrderOrderItemsItem struct {
	// Type of item.
	Type OrderItemType `json:"type" url:"type"`
	// Unique identifier of the solution. Send one of the following values:
	// - `Roc Services_DX8000`
	// - `Roc Services_DX4000`
	// - `Roc Services_Web`
	// - `Roc Services_Mobile`
	// - `Payroc DX8000`
	// - `Payroc DX4000`
	// - `Payroc RX7000_Cloud`
	// - `Payroc DX8000_Cloud`
	// - `Payroc DX4000_Cloud`
	// - `Payroc A920Pro`
	// - `Payroc A80`
	// - `Payroc A920Pro_Cloud`
	// - `Payroc A80_Cloud`
	// - `Roc Terminal Plus_N950`
	// - `Roc Terminal Plus_N950-S`
	// - `Roc Terminal Plus_X800`
	// - `Gateway_Payroc`
	// - `VAR_Only_TSYS`
	// - `ROC Services Chipper3X`
	// - `BBPOS Chipper 3X`
	// - `Augusta EMV`
	// - `Ingenico - AXIUM Full Functional Base`
	// - `Pax A920 Charging Base`
	// - `Pax A920 Comms Base`
	// - `A920 Pro Ethernet`
	// - `Axium Bundle`
	SolutionTemplateId string `json:"solutionTemplateId" url:"solutionTemplateId"`
	// Quantity of the solution.
	SolutionQuantity *int `json:"solutionQuantity,omitempty" url:"solutionQuantity,omitempty"`
	// Indicates if the order contains a new item or a refurbished item.
	DeviceCondition *OrderItemDeviceCondition `json:"deviceCondition,omitempty" url:"deviceCondition,omitempty"`
	// Object that contains the settings for the solution, including gateway settings, device settings, and application settings.
	SolutionSetup *OrderItemSolutionSetup `json:"solutionSetup,omitempty" url:"solutionSetup,omitempty"`
	// Polymorphic object that contains information about the processing terminal that the order is linked to.
	Links []*ProcessingTerminalSummary `json:"links,omitempty" url:"links,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalOrderOrderItemsItem) GetType() OrderItemType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *TerminalOrderOrderItemsItem) GetSolutionTemplateId() string {
	if t == nil {
		return ""
	}
	return t.SolutionTemplateId
}

func (t *TerminalOrderOrderItemsItem) GetSolutionQuantity() *int {
	if t == nil {
		return nil
	}
	return t.SolutionQuantity
}

func (t *TerminalOrderOrderItemsItem) GetDeviceCondition() *OrderItemDeviceCondition {
	if t == nil {
		return nil
	}
	return t.DeviceCondition
}

func (t *TerminalOrderOrderItemsItem) GetSolutionSetup() *OrderItemSolutionSetup {
	if t == nil {
		return nil
	}
	return t.SolutionSetup
}

func (t *TerminalOrderOrderItemsItem) GetLinks() []*ProcessingTerminalSummary {
	if t == nil {
		return nil
	}
	return t.Links
}

func (t *TerminalOrderOrderItemsItem) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalOrderOrderItemsItem) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderOrderItemsItem) SetType(type_ OrderItemType) {
	t.Type = type_
	t.require(terminalOrderOrderItemsItemFieldType)
}

// SetSolutionTemplateId sets the SolutionTemplateId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderOrderItemsItem) SetSolutionTemplateId(solutionTemplateId string) {
	t.SolutionTemplateId = solutionTemplateId
	t.require(terminalOrderOrderItemsItemFieldSolutionTemplateId)
}

// SetSolutionQuantity sets the SolutionQuantity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderOrderItemsItem) SetSolutionQuantity(solutionQuantity *int) {
	t.SolutionQuantity = solutionQuantity
	t.require(terminalOrderOrderItemsItemFieldSolutionQuantity)
}

// SetDeviceCondition sets the DeviceCondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderOrderItemsItem) SetDeviceCondition(deviceCondition *OrderItemDeviceCondition) {
	t.DeviceCondition = deviceCondition
	t.require(terminalOrderOrderItemsItemFieldDeviceCondition)
}

// SetSolutionSetup sets the SolutionSetup field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderOrderItemsItem) SetSolutionSetup(solutionSetup *OrderItemSolutionSetup) {
	t.SolutionSetup = solutionSetup
	t.require(terminalOrderOrderItemsItemFieldSolutionSetup)
}

// SetLinks sets the Links field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderOrderItemsItem) SetLinks(links []*ProcessingTerminalSummary) {
	t.Links = links
	t.require(terminalOrderOrderItemsItemFieldLinks)
}

func (t *TerminalOrderOrderItemsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalOrderOrderItemsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalOrderOrderItemsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalOrderOrderItemsItem) MarshalJSON() ([]byte, error) {
	type embed TerminalOrderOrderItemsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TerminalOrderOrderItemsItem) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains the shipping details for the terminal order. If you don't provide a shipping address, we use the Doing Business As (DBA) address of the processing account.
var (
	terminalOrderShippingFieldPreferences = big.NewInt(1 << 0)
	terminalOrderShippingFieldAddress     = big.NewInt(1 << 1)
)

type TerminalOrderShipping struct {
	// Object that contains the shipping preferences for the terminal order.
	Preferences *TerminalOrderShippingPreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// Object that contains the shipping address for the terminal order.
	Address *TerminalOrderShippingAddress `json:"address,omitempty" url:"address,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalOrderShipping) GetPreferences() *TerminalOrderShippingPreferences {
	if t == nil {
		return nil
	}
	return t.Preferences
}

func (t *TerminalOrderShipping) GetAddress() *TerminalOrderShippingAddress {
	if t == nil {
		return nil
	}
	return t.Address
}

func (t *TerminalOrderShipping) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalOrderShipping) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetPreferences sets the Preferences field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShipping) SetPreferences(preferences *TerminalOrderShippingPreferences) {
	t.Preferences = preferences
	t.require(terminalOrderShippingFieldPreferences)
}

// SetAddress sets the Address field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShipping) SetAddress(address *TerminalOrderShippingAddress) {
	t.Address = address
	t.require(terminalOrderShippingFieldAddress)
}

func (t *TerminalOrderShipping) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalOrderShipping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalOrderShipping(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalOrderShipping) MarshalJSON() ([]byte, error) {
	type embed TerminalOrderShipping
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TerminalOrderShipping) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains the shipping address for the terminal order.
var (
	terminalOrderShippingAddressFieldRecipientName = big.NewInt(1 << 0)
	terminalOrderShippingAddressFieldBusinessName  = big.NewInt(1 << 1)
	terminalOrderShippingAddressFieldAddressLine1  = big.NewInt(1 << 2)
	terminalOrderShippingAddressFieldAddressLine2  = big.NewInt(1 << 3)
	terminalOrderShippingAddressFieldCity          = big.NewInt(1 << 4)
	terminalOrderShippingAddressFieldState         = big.NewInt(1 << 5)
	terminalOrderShippingAddressFieldPostalCode    = big.NewInt(1 << 6)
	terminalOrderShippingAddressFieldEmail         = big.NewInt(1 << 7)
	terminalOrderShippingAddressFieldPhone         = big.NewInt(1 << 8)
)

type TerminalOrderShippingAddress struct {
	// Name of the person receiving the shipment.
	RecipientName string `json:"recipientName" url:"recipientName"`
	// Name of the business receiving the shipment.
	BusinessName *string `json:"businessName,omitempty" url:"businessName,omitempty"`
	// First line of the shipment address.
	AddressLine1 string `json:"addressLine1" url:"addressLine1"`
	// Second line of the shipment address.
	AddressLine2 *string `json:"addressLine2,omitempty" url:"addressLine2,omitempty"`
	// City of the shipment address.
	City string `json:"city" url:"city"`
	// State of the shipment address.
	State string `json:"state" url:"state"`
	// Postal code of the shipment address.
	PostalCode string `json:"postalCode" url:"postalCode"`
	// Contact email address for the shipment.
	Email string `json:"email" url:"email"`
	// Contact number for the shipment.
	Phone *string `json:"phone,omitempty" url:"phone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalOrderShippingAddress) GetRecipientName() string {
	if t == nil {
		return ""
	}
	return t.RecipientName
}

func (t *TerminalOrderShippingAddress) GetBusinessName() *string {
	if t == nil {
		return nil
	}
	return t.BusinessName
}

func (t *TerminalOrderShippingAddress) GetAddressLine1() string {
	if t == nil {
		return ""
	}
	return t.AddressLine1
}

func (t *TerminalOrderShippingAddress) GetAddressLine2() *string {
	if t == nil {
		return nil
	}
	return t.AddressLine2
}

func (t *TerminalOrderShippingAddress) GetCity() string {
	if t == nil {
		return ""
	}
	return t.City
}

func (t *TerminalOrderShippingAddress) GetState() string {
	if t == nil {
		return ""
	}
	return t.State
}

func (t *TerminalOrderShippingAddress) GetPostalCode() string {
	if t == nil {
		return ""
	}
	return t.PostalCode
}

func (t *TerminalOrderShippingAddress) GetEmail() string {
	if t == nil {
		return ""
	}
	return t.Email
}

func (t *TerminalOrderShippingAddress) GetPhone() *string {
	if t == nil {
		return nil
	}
	return t.Phone
}

func (t *TerminalOrderShippingAddress) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalOrderShippingAddress) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetRecipientName sets the RecipientName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetRecipientName(recipientName string) {
	t.RecipientName = recipientName
	t.require(terminalOrderShippingAddressFieldRecipientName)
}

// SetBusinessName sets the BusinessName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetBusinessName(businessName *string) {
	t.BusinessName = businessName
	t.require(terminalOrderShippingAddressFieldBusinessName)
}

// SetAddressLine1 sets the AddressLine1 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetAddressLine1(addressLine1 string) {
	t.AddressLine1 = addressLine1
	t.require(terminalOrderShippingAddressFieldAddressLine1)
}

// SetAddressLine2 sets the AddressLine2 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetAddressLine2(addressLine2 *string) {
	t.AddressLine2 = addressLine2
	t.require(terminalOrderShippingAddressFieldAddressLine2)
}

// SetCity sets the City field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetCity(city string) {
	t.City = city
	t.require(terminalOrderShippingAddressFieldCity)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetState(state string) {
	t.State = state
	t.require(terminalOrderShippingAddressFieldState)
}

// SetPostalCode sets the PostalCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetPostalCode(postalCode string) {
	t.PostalCode = postalCode
	t.require(terminalOrderShippingAddressFieldPostalCode)
}

// SetEmail sets the Email field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetEmail(email string) {
	t.Email = email
	t.require(terminalOrderShippingAddressFieldEmail)
}

// SetPhone sets the Phone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingAddress) SetPhone(phone *string) {
	t.Phone = phone
	t.require(terminalOrderShippingAddressFieldPhone)
}

func (t *TerminalOrderShippingAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalOrderShippingAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalOrderShippingAddress(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalOrderShippingAddress) MarshalJSON() ([]byte, error) {
	type embed TerminalOrderShippingAddress
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TerminalOrderShippingAddress) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains the shipping preferences for the terminal order.
var (
	terminalOrderShippingPreferencesFieldMethod           = big.NewInt(1 << 0)
	terminalOrderShippingPreferencesFieldSaturdayDelivery = big.NewInt(1 << 1)
)

type TerminalOrderShippingPreferences struct {
	// Shipping method for the terminal order. Send one of the following values:
	//   - `nextDay` - We schedule the order to be delivered the next day.
	//   - `ground` - We ship the order with ground shipping.
	Method *TerminalOrderShippingPreferencesMethod `json:"method,omitempty" url:"method,omitempty"`
	// Indicates if we can schedule the terminal order to be delivered on a Saturday.
	SaturdayDelivery *bool `json:"saturdayDelivery,omitempty" url:"saturdayDelivery,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalOrderShippingPreferences) GetMethod() *TerminalOrderShippingPreferencesMethod {
	if t == nil {
		return nil
	}
	return t.Method
}

func (t *TerminalOrderShippingPreferences) GetSaturdayDelivery() *bool {
	if t == nil {
		return nil
	}
	return t.SaturdayDelivery
}

func (t *TerminalOrderShippingPreferences) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalOrderShippingPreferences) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMethod sets the Method field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingPreferences) SetMethod(method *TerminalOrderShippingPreferencesMethod) {
	t.Method = method
	t.require(terminalOrderShippingPreferencesFieldMethod)
}

// SetSaturdayDelivery sets the SaturdayDelivery field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TerminalOrderShippingPreferences) SetSaturdayDelivery(saturdayDelivery *bool) {
	t.SaturdayDelivery = saturdayDelivery
	t.require(terminalOrderShippingPreferencesFieldSaturdayDelivery)
}

func (t *TerminalOrderShippingPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalOrderShippingPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalOrderShippingPreferences(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalOrderShippingPreferences) MarshalJSON() ([]byte, error) {
	type embed TerminalOrderShippingPreferences
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TerminalOrderShippingPreferences) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Shipping method for the terminal order. Send one of the following values:
//   - `nextDay` - We schedule the order to be delivered the next day.
//   - `ground` - We ship the order with ground shipping.
type TerminalOrderShippingPreferencesMethod string

const (
	TerminalOrderShippingPreferencesMethodNextDay TerminalOrderShippingPreferencesMethod = "nextDay"
	TerminalOrderShippingPreferencesMethodGround  TerminalOrderShippingPreferencesMethod = "ground"
)

func NewTerminalOrderShippingPreferencesMethodFromString(s string) (TerminalOrderShippingPreferencesMethod, error) {
	switch s {
	case "nextDay":
		return TerminalOrderShippingPreferencesMethodNextDay, nil
	case "ground":
		return TerminalOrderShippingPreferencesMethodGround, nil
	}
	var t TerminalOrderShippingPreferencesMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TerminalOrderShippingPreferencesMethod) Ptr() *TerminalOrderShippingPreferencesMethod {
	return &t
}

// Status of the terminal order.
//
// **Note**: You can subscribe to our terminalOrder.status.changed event to get notifications when we update the status of a terminal order. For more information about how to subscribe to events, go to [Event Subscriptions](https://docs.payroc.com/guides/board-merchants/event-subscriptions).
type TerminalOrderStatus string

const (
	TerminalOrderStatusOpen       TerminalOrderStatus = "open"
	TerminalOrderStatusHeld       TerminalOrderStatus = "held"
	TerminalOrderStatusDispatched TerminalOrderStatus = "dispatched"
	TerminalOrderStatusFulfilled  TerminalOrderStatus = "fulfilled"
	TerminalOrderStatusCancelled  TerminalOrderStatus = "cancelled"
)

func NewTerminalOrderStatusFromString(s string) (TerminalOrderStatus, error) {
	switch s {
	case "open":
		return TerminalOrderStatusOpen, nil
	case "held":
		return TerminalOrderStatusHeld, nil
	case "dispatched":
		return TerminalOrderStatusDispatched, nil
	case "fulfilled":
		return TerminalOrderStatusFulfilled, nil
	case "cancelled":
		return TerminalOrderStatusCancelled, nil
	}
	var t TerminalOrderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TerminalOrderStatus) Ptr() *TerminalOrderStatus {
	return &t
}

// Indicates who provides training to the merchant for the solution.
type TerminalOrderTrainingProvider string

const (
	TerminalOrderTrainingProviderPartner TerminalOrderTrainingProvider = "partner"
	TerminalOrderTrainingProviderPayroc  TerminalOrderTrainingProvider = "payroc"
)

func NewTerminalOrderTrainingProviderFromString(s string) (TerminalOrderTrainingProvider, error) {
	switch s {
	case "partner":
		return TerminalOrderTrainingProviderPartner, nil
	case "payroc":
		return TerminalOrderTrainingProviderPayroc, nil
	}
	var t TerminalOrderTrainingProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TerminalOrderTrainingProvider) Ptr() *TerminalOrderTrainingProvider {
	return &t
}

// Object that contains the 3-D Secure information from a third party.
var (
	thirdPartyThreeDSecureFieldEci             = big.NewInt(1 << 0)
	thirdPartyThreeDSecureFieldXid             = big.NewInt(1 << 1)
	thirdPartyThreeDSecureFieldCavv            = big.NewInt(1 << 2)
	thirdPartyThreeDSecureFieldDsTransactionId = big.NewInt(1 << 3)
)

type ThirdPartyThreeDSecure struct {
	// E-commerce indicator (ECI) result of a the 3-D Secure check.
	Eci ThirdPartyThreeDSecureEci `json:"eci" url:"eci"`
	// Unique transaction identifier that the merchant assigned to the transaction and sent in the authentication request.
	Xid *string `json:"xid,omitempty" url:"xid,omitempty"`
	// Cardholder Authentication Verification Value (CAVV) that the card issuer provided to prove that they authorized the online payment.
	Cavv *string `json:"cavv,omitempty" url:"cavv,omitempty"`
	// Directory Server Transaction ID that the processor assigned to the request.
	DsTransactionId *string `json:"dsTransactionId,omitempty" url:"dsTransactionId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *ThirdPartyThreeDSecure) GetEci() ThirdPartyThreeDSecureEci {
	if t == nil {
		return ""
	}
	return t.Eci
}

func (t *ThirdPartyThreeDSecure) GetXid() *string {
	if t == nil {
		return nil
	}
	return t.Xid
}

func (t *ThirdPartyThreeDSecure) GetCavv() *string {
	if t == nil {
		return nil
	}
	return t.Cavv
}

func (t *ThirdPartyThreeDSecure) GetDsTransactionId() *string {
	if t == nil {
		return nil
	}
	return t.DsTransactionId
}

func (t *ThirdPartyThreeDSecure) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *ThirdPartyThreeDSecure) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetEci sets the Eci field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ThirdPartyThreeDSecure) SetEci(eci ThirdPartyThreeDSecureEci) {
	t.Eci = eci
	t.require(thirdPartyThreeDSecureFieldEci)
}

// SetXid sets the Xid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ThirdPartyThreeDSecure) SetXid(xid *string) {
	t.Xid = xid
	t.require(thirdPartyThreeDSecureFieldXid)
}

// SetCavv sets the Cavv field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ThirdPartyThreeDSecure) SetCavv(cavv *string) {
	t.Cavv = cavv
	t.require(thirdPartyThreeDSecureFieldCavv)
}

// SetDsTransactionId sets the DsTransactionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *ThirdPartyThreeDSecure) SetDsTransactionId(dsTransactionId *string) {
	t.DsTransactionId = dsTransactionId
	t.require(thirdPartyThreeDSecureFieldDsTransactionId)
}

func (t *ThirdPartyThreeDSecure) UnmarshalJSON(data []byte) error {
	type unmarshaler ThirdPartyThreeDSecure
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ThirdPartyThreeDSecure(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *ThirdPartyThreeDSecure) MarshalJSON() ([]byte, error) {
	type embed ThirdPartyThreeDSecure
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *ThirdPartyThreeDSecure) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// E-commerce indicator (ECI) result of a the 3-D Secure check.
type ThirdPartyThreeDSecureEci string

const (
	ThirdPartyThreeDSecureEciFullyAuthenticated      ThirdPartyThreeDSecureEci = "fullyAuthenticated"
	ThirdPartyThreeDSecureEciAttemptedAuthentication ThirdPartyThreeDSecureEci = "attemptedAuthentication"
)

func NewThirdPartyThreeDSecureEciFromString(s string) (ThirdPartyThreeDSecureEci, error) {
	switch s {
	case "fullyAuthenticated":
		return ThirdPartyThreeDSecureEciFullyAuthenticated, nil
	case "attemptedAuthentication":
		return ThirdPartyThreeDSecureEciAttemptedAuthentication, nil
	}
	var t ThirdPartyThreeDSecureEci
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t ThirdPartyThreeDSecureEci) Ptr() *ThirdPartyThreeDSecureEci {
	return &t
}

// Object that contains information about tiered pricing with three tiers.
var (
	tiered3FieldFees = big.NewInt(1 << 0)
)

type Tiered3 struct {
	// Object that contains information about the fees.
	Fees *Tiered3Fees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered3) GetFees() *Tiered3Fees {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *Tiered3) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered3) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3) SetFees(fees *Tiered3Fees) {
	t.Fees = fees
	t.require(tiered3FieldFees)
}

func (t *Tiered3) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered3
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered3(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered3) MarshalJSON() ([]byte, error) {
	type embed Tiered3
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered3) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	tiered3AmexDirectFieldTransaction = big.NewInt(1 << 0)
)

type Tiered3AmexDirect struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered3AmexDirect) GetTransaction() Amount {
	if t == nil {
		return 0
	}
	return t.Transaction
}

func (t *Tiered3AmexDirect) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered3AmexDirect) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3AmexDirect) SetTransaction(transaction Amount) {
	t.Transaction = transaction
	t.require(tiered3AmexDirectFieldTransaction)
}

func (t *Tiered3AmexDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered3AmexDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered3AmexDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered3AmexDirect) MarshalJSON() ([]byte, error) {
	type embed Tiered3AmexDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered3AmexDirect) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	tiered3AmexOptBlueFieldQualifiedRate = big.NewInt(1 << 0)
	tiered3AmexOptBlueFieldMidQualRate   = big.NewInt(1 << 1)
	tiered3AmexOptBlueFieldNonQualRate   = big.NewInt(1 << 2)
)

type Tiered3AmexOptBlue struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered3AmexOptBlue) GetQualifiedRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.QualifiedRate
}

func (t *Tiered3AmexOptBlue) GetMidQualRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.MidQualRate
}

func (t *Tiered3AmexOptBlue) GetNonQualRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.NonQualRate
}

func (t *Tiered3AmexOptBlue) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered3AmexOptBlue) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3AmexOptBlue) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	t.QualifiedRate = qualifiedRate
	t.require(tiered3AmexOptBlueFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3AmexOptBlue) SetMidQualRate(midQualRate *ProcessorFee) {
	t.MidQualRate = midQualRate
	t.require(tiered3AmexOptBlueFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3AmexOptBlue) SetNonQualRate(nonQualRate *ProcessorFee) {
	t.NonQualRate = nonQualRate
	t.require(tiered3AmexOptBlueFieldNonQualRate)
}

func (t *Tiered3AmexOptBlue) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered3AmexOptBlue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered3AmexOptBlue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered3AmexOptBlue) MarshalJSON() ([]byte, error) {
	type embed Tiered3AmexOptBlue
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered3AmexOptBlue) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains information about the fees.
var (
	tiered3FeesFieldMastercardVisaDiscover     = big.NewInt(1 << 0)
	tiered3FeesFieldAmex                       = big.NewInt(1 << 1)
	tiered3FeesFieldPinDebit                   = big.NewInt(1 << 2)
	tiered3FeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	tiered3FeesFieldSpecialityCards            = big.NewInt(1 << 4)
)

type Tiered3Fees struct {
	// Object that contains the fees for Mastercard, Visa, and Discover transactions.
	MastercardVisaDiscover *QualRates `json:"mastercardVisaDiscover" url:"mastercardVisaDiscover"`
	// Polymorphic object that contains fees for American Express transactions.
	//
	// The value of the type field determines which variant you should use:
	// -	`optBlue` - Amex OptBlue pricing program.
	// -	`direct` - Amex Direct pricing program.
	Amex                       *Tiered3FeesAmex            `json:"amex,omitempty" url:"amex,omitempty"`
	PinDebit                   *PinDebit                   `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	SpecialityCards            *SpecialityCards            `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered3Fees) GetMastercardVisaDiscover() *QualRates {
	if t == nil {
		return nil
	}
	return t.MastercardVisaDiscover
}

func (t *Tiered3Fees) GetAmex() *Tiered3FeesAmex {
	if t == nil {
		return nil
	}
	return t.Amex
}

func (t *Tiered3Fees) GetPinDebit() *PinDebit {
	if t == nil {
		return nil
	}
	return t.PinDebit
}

func (t *Tiered3Fees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if t == nil {
		return nil
	}
	return t.ElectronicBenefitsTransfer
}

func (t *Tiered3Fees) GetSpecialityCards() *SpecialityCards {
	if t == nil {
		return nil
	}
	return t.SpecialityCards
}

func (t *Tiered3Fees) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered3Fees) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMastercardVisaDiscover sets the MastercardVisaDiscover field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3Fees) SetMastercardVisaDiscover(mastercardVisaDiscover *QualRates) {
	t.MastercardVisaDiscover = mastercardVisaDiscover
	t.require(tiered3FeesFieldMastercardVisaDiscover)
}

// SetAmex sets the Amex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3Fees) SetAmex(amex *Tiered3FeesAmex) {
	t.Amex = amex
	t.require(tiered3FeesFieldAmex)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3Fees) SetPinDebit(pinDebit *PinDebit) {
	t.PinDebit = pinDebit
	t.require(tiered3FeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3Fees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	t.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	t.require(tiered3FeesFieldElectronicBenefitsTransfer)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered3Fees) SetSpecialityCards(specialityCards *SpecialityCards) {
	t.SpecialityCards = specialityCards
	t.require(tiered3FeesFieldSpecialityCards)
}

func (t *Tiered3Fees) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered3Fees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered3Fees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered3Fees) MarshalJSON() ([]byte, error) {
	type embed Tiered3Fees
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered3Fees) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Polymorphic object that contains fees for American Express transactions.
//
// The value of the type field determines which variant you should use:
// -	`optBlue` - Amex OptBlue pricing program.
// -	`direct` - Amex Direct pricing program.
type Tiered3FeesAmex struct {
	Type    string
	OptBlue *Tiered3AmexOptBlue
	Direct  *Tiered3AmexDirect
}

func (t *Tiered3FeesAmex) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Tiered3FeesAmex) GetOptBlue() *Tiered3AmexOptBlue {
	if t == nil {
		return nil
	}
	return t.OptBlue
}

func (t *Tiered3FeesAmex) GetDirect() *Tiered3AmexDirect {
	if t == nil {
		return nil
	}
	return t.Direct
}

func (t *Tiered3FeesAmex) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "optBlue":
		value := new(Tiered3AmexOptBlue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OptBlue = value
	case "direct":
		value := new(Tiered3AmexDirect)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Direct = value
	}
	return nil
}

func (t Tiered3FeesAmex) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.OptBlue != nil {
		return internal.MarshalJSONWithExtraProperty(t.OptBlue, "type", "optBlue")
	}
	if t.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(t.Direct, "type", "direct")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type Tiered3FeesAmexVisitor interface {
	VisitOptBlue(*Tiered3AmexOptBlue) error
	VisitDirect(*Tiered3AmexDirect) error
}

func (t *Tiered3FeesAmex) Accept(visitor Tiered3FeesAmexVisitor) error {
	if t.OptBlue != nil {
		return visitor.VisitOptBlue(t.OptBlue)
	}
	if t.Direct != nil {
		return visitor.VisitDirect(t.Direct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *Tiered3FeesAmex) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.OptBlue != nil {
		fields = append(fields, "optBlue")
	}
	if t.Direct != nil {
		fields = append(fields, "direct")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// Object that contains information about tiered pricing with four tiers.
var (
	tiered4FieldFees = big.NewInt(1 << 0)
)

type Tiered4 struct {
	// Object that contains information about the fees.
	Fees *Tiered4Fees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered4) GetFees() *Tiered4Fees {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *Tiered4) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered4) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4) SetFees(fees *Tiered4Fees) {
	t.Fees = fees
	t.require(tiered4FieldFees)
}

func (t *Tiered4) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered4
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered4(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered4) MarshalJSON() ([]byte, error) {
	type embed Tiered4
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered4) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	tiered4AmexDirectFieldTransaction = big.NewInt(1 << 0)
)

type Tiered4AmexDirect struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered4AmexDirect) GetTransaction() Amount {
	if t == nil {
		return 0
	}
	return t.Transaction
}

func (t *Tiered4AmexDirect) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered4AmexDirect) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4AmexDirect) SetTransaction(transaction Amount) {
	t.Transaction = transaction
	t.require(tiered4AmexDirectFieldTransaction)
}

func (t *Tiered4AmexDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered4AmexDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered4AmexDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered4AmexDirect) MarshalJSON() ([]byte, error) {
	type embed Tiered4AmexDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered4AmexDirect) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	tiered4AmexOptBlueFieldQualifiedRate = big.NewInt(1 << 0)
	tiered4AmexOptBlueFieldMidQualRate   = big.NewInt(1 << 1)
	tiered4AmexOptBlueFieldNonQualRate   = big.NewInt(1 << 2)
)

type Tiered4AmexOptBlue struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered4AmexOptBlue) GetQualifiedRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.QualifiedRate
}

func (t *Tiered4AmexOptBlue) GetMidQualRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.MidQualRate
}

func (t *Tiered4AmexOptBlue) GetNonQualRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.NonQualRate
}

func (t *Tiered4AmexOptBlue) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered4AmexOptBlue) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4AmexOptBlue) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	t.QualifiedRate = qualifiedRate
	t.require(tiered4AmexOptBlueFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4AmexOptBlue) SetMidQualRate(midQualRate *ProcessorFee) {
	t.MidQualRate = midQualRate
	t.require(tiered4AmexOptBlueFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4AmexOptBlue) SetNonQualRate(nonQualRate *ProcessorFee) {
	t.NonQualRate = nonQualRate
	t.require(tiered4AmexOptBlueFieldNonQualRate)
}

func (t *Tiered4AmexOptBlue) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered4AmexOptBlue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered4AmexOptBlue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered4AmexOptBlue) MarshalJSON() ([]byte, error) {
	type embed Tiered4AmexOptBlue
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered4AmexOptBlue) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains information about the fees.
var (
	tiered4FeesFieldMastercardVisaDiscover     = big.NewInt(1 << 0)
	tiered4FeesFieldAmex                       = big.NewInt(1 << 1)
	tiered4FeesFieldPinDebit                   = big.NewInt(1 << 2)
	tiered4FeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	tiered4FeesFieldSpecialityCards            = big.NewInt(1 << 4)
)

type Tiered4Fees struct {
	// Object that contains the fees for Mastercard, Visa, and Discover transactions.
	MastercardVisaDiscover *QualRatesWithPremium `json:"mastercardVisaDiscover" url:"mastercardVisaDiscover"`
	// Polymorphic object that contains fees for American Express transactions.
	//
	// The value of the type field determines which variant you should use:
	// -	`optBlue` - Amex OptBlue pricing program.
	// -	`direct` - Amex Direct pricing program.
	Amex                       *Tiered4FeesAmex            `json:"amex,omitempty" url:"amex,omitempty"`
	PinDebit                   *PinDebit                   `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	SpecialityCards            *SpecialityCards            `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered4Fees) GetMastercardVisaDiscover() *QualRatesWithPremium {
	if t == nil {
		return nil
	}
	return t.MastercardVisaDiscover
}

func (t *Tiered4Fees) GetAmex() *Tiered4FeesAmex {
	if t == nil {
		return nil
	}
	return t.Amex
}

func (t *Tiered4Fees) GetPinDebit() *PinDebit {
	if t == nil {
		return nil
	}
	return t.PinDebit
}

func (t *Tiered4Fees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if t == nil {
		return nil
	}
	return t.ElectronicBenefitsTransfer
}

func (t *Tiered4Fees) GetSpecialityCards() *SpecialityCards {
	if t == nil {
		return nil
	}
	return t.SpecialityCards
}

func (t *Tiered4Fees) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered4Fees) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMastercardVisaDiscover sets the MastercardVisaDiscover field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4Fees) SetMastercardVisaDiscover(mastercardVisaDiscover *QualRatesWithPremium) {
	t.MastercardVisaDiscover = mastercardVisaDiscover
	t.require(tiered4FeesFieldMastercardVisaDiscover)
}

// SetAmex sets the Amex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4Fees) SetAmex(amex *Tiered4FeesAmex) {
	t.Amex = amex
	t.require(tiered4FeesFieldAmex)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4Fees) SetPinDebit(pinDebit *PinDebit) {
	t.PinDebit = pinDebit
	t.require(tiered4FeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4Fees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	t.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	t.require(tiered4FeesFieldElectronicBenefitsTransfer)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered4Fees) SetSpecialityCards(specialityCards *SpecialityCards) {
	t.SpecialityCards = specialityCards
	t.require(tiered4FeesFieldSpecialityCards)
}

func (t *Tiered4Fees) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered4Fees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered4Fees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered4Fees) MarshalJSON() ([]byte, error) {
	type embed Tiered4Fees
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered4Fees) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Polymorphic object that contains fees for American Express transactions.
//
// The value of the type field determines which variant you should use:
// -	`optBlue` - Amex OptBlue pricing program.
// -	`direct` - Amex Direct pricing program.
type Tiered4FeesAmex struct {
	Type    string
	OptBlue *Tiered4AmexOptBlue
	Direct  *Tiered4AmexDirect
}

func (t *Tiered4FeesAmex) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Tiered4FeesAmex) GetOptBlue() *Tiered4AmexOptBlue {
	if t == nil {
		return nil
	}
	return t.OptBlue
}

func (t *Tiered4FeesAmex) GetDirect() *Tiered4AmexDirect {
	if t == nil {
		return nil
	}
	return t.Direct
}

func (t *Tiered4FeesAmex) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "optBlue":
		value := new(Tiered4AmexOptBlue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OptBlue = value
	case "direct":
		value := new(Tiered4AmexDirect)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Direct = value
	}
	return nil
}

func (t Tiered4FeesAmex) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.OptBlue != nil {
		return internal.MarshalJSONWithExtraProperty(t.OptBlue, "type", "optBlue")
	}
	if t.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(t.Direct, "type", "direct")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type Tiered4FeesAmexVisitor interface {
	VisitOptBlue(*Tiered4AmexOptBlue) error
	VisitDirect(*Tiered4AmexDirect) error
}

func (t *Tiered4FeesAmex) Accept(visitor Tiered4FeesAmexVisitor) error {
	if t.OptBlue != nil {
		return visitor.VisitOptBlue(t.OptBlue)
	}
	if t.Direct != nil {
		return visitor.VisitDirect(t.Direct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *Tiered4FeesAmex) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.OptBlue != nil {
		fields = append(fields, "optBlue")
	}
	if t.Direct != nil {
		fields = append(fields, "direct")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// Object that contains information about tiered pricing with six tiers.
var (
	tiered6FieldFees = big.NewInt(1 << 0)
)

type Tiered6 struct {
	// Object that contains information about the fees.
	Fees *Tiered6Fees `json:"fees" url:"fees"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered6) GetFees() *Tiered6Fees {
	if t == nil {
		return nil
	}
	return t.Fees
}

func (t *Tiered6) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered6) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetFees sets the Fees field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6) SetFees(fees *Tiered6Fees) {
	t.Fees = fees
	t.require(tiered6FieldFees)
}

func (t *Tiered6) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered6
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered6(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered6) MarshalJSON() ([]byte, error) {
	type embed Tiered6
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered6) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	tiered6AmexDirectFieldTransaction = big.NewInt(1 << 0)
)

type Tiered6AmexDirect struct {
	// Fee for each transaction. The value is in the currency's lowest denomination, for example, cents.
	Transaction Amount `json:"transaction" url:"transaction"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered6AmexDirect) GetTransaction() Amount {
	if t == nil {
		return 0
	}
	return t.Transaction
}

func (t *Tiered6AmexDirect) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered6AmexDirect) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTransaction sets the Transaction field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6AmexDirect) SetTransaction(transaction Amount) {
	t.Transaction = transaction
	t.require(tiered6AmexDirectFieldTransaction)
}

func (t *Tiered6AmexDirect) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered6AmexDirect
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered6AmexDirect(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered6AmexDirect) MarshalJSON() ([]byte, error) {
	type embed Tiered6AmexDirect
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered6AmexDirect) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	tiered6AmexOptBlueFieldQualifiedRate = big.NewInt(1 << 0)
	tiered6AmexOptBlueFieldMidQualRate   = big.NewInt(1 << 1)
	tiered6AmexOptBlueFieldNonQualRate   = big.NewInt(1 << 2)
)

type Tiered6AmexOptBlue struct {
	// Object that contains the fees for a qualified transaction.
	QualifiedRate *ProcessorFee `json:"qualifiedRate" url:"qualifiedRate"`
	// Object that contains the fees for a mid-qualified transaction.
	MidQualRate *ProcessorFee `json:"midQualRate" url:"midQualRate"`
	// Object that contains the fees for a non-qualified transaction.
	NonQualRate *ProcessorFee `json:"nonQualRate" url:"nonQualRate"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered6AmexOptBlue) GetQualifiedRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.QualifiedRate
}

func (t *Tiered6AmexOptBlue) GetMidQualRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.MidQualRate
}

func (t *Tiered6AmexOptBlue) GetNonQualRate() *ProcessorFee {
	if t == nil {
		return nil
	}
	return t.NonQualRate
}

func (t *Tiered6AmexOptBlue) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered6AmexOptBlue) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetQualifiedRate sets the QualifiedRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6AmexOptBlue) SetQualifiedRate(qualifiedRate *ProcessorFee) {
	t.QualifiedRate = qualifiedRate
	t.require(tiered6AmexOptBlueFieldQualifiedRate)
}

// SetMidQualRate sets the MidQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6AmexOptBlue) SetMidQualRate(midQualRate *ProcessorFee) {
	t.MidQualRate = midQualRate
	t.require(tiered6AmexOptBlueFieldMidQualRate)
}

// SetNonQualRate sets the NonQualRate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6AmexOptBlue) SetNonQualRate(nonQualRate *ProcessorFee) {
	t.NonQualRate = nonQualRate
	t.require(tiered6AmexOptBlueFieldNonQualRate)
}

func (t *Tiered6AmexOptBlue) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered6AmexOptBlue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered6AmexOptBlue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered6AmexOptBlue) MarshalJSON() ([]byte, error) {
	type embed Tiered6AmexOptBlue
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered6AmexOptBlue) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains information about the fees.
var (
	tiered6FeesFieldMastercardVisaDiscover     = big.NewInt(1 << 0)
	tiered6FeesFieldAmex                       = big.NewInt(1 << 1)
	tiered6FeesFieldPinDebit                   = big.NewInt(1 << 2)
	tiered6FeesFieldElectronicBenefitsTransfer = big.NewInt(1 << 3)
	tiered6FeesFieldSpecialityCards            = big.NewInt(1 << 4)
)

type Tiered6Fees struct {
	// Object that contains the fees for Mastercard, Visa, and Discover transactions.
	MastercardVisaDiscover *QualRatesWithPremiumAndRegulated `json:"mastercardVisaDiscover" url:"mastercardVisaDiscover"`
	// Polymorphic object that contains fees for American Express transactions.
	//
	// The value of the type field determines which variant you should use:
	// -	`optBlue` - Amex OptBlue pricing program.
	// -	`direct` - Amex Direct pricing program.
	Amex                       *Tiered6FeesAmex            `json:"amex,omitempty" url:"amex,omitempty"`
	PinDebit                   *PinDebit                   `json:"pinDebit,omitempty" url:"pinDebit,omitempty"`
	ElectronicBenefitsTransfer *ElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty" url:"electronicBenefitsTransfer,omitempty"`
	SpecialityCards            *SpecialityCards            `json:"specialityCards,omitempty" url:"specialityCards,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tiered6Fees) GetMastercardVisaDiscover() *QualRatesWithPremiumAndRegulated {
	if t == nil {
		return nil
	}
	return t.MastercardVisaDiscover
}

func (t *Tiered6Fees) GetAmex() *Tiered6FeesAmex {
	if t == nil {
		return nil
	}
	return t.Amex
}

func (t *Tiered6Fees) GetPinDebit() *PinDebit {
	if t == nil {
		return nil
	}
	return t.PinDebit
}

func (t *Tiered6Fees) GetElectronicBenefitsTransfer() *ElectronicBenefitsTransfer {
	if t == nil {
		return nil
	}
	return t.ElectronicBenefitsTransfer
}

func (t *Tiered6Fees) GetSpecialityCards() *SpecialityCards {
	if t == nil {
		return nil
	}
	return t.SpecialityCards
}

func (t *Tiered6Fees) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tiered6Fees) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMastercardVisaDiscover sets the MastercardVisaDiscover field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6Fees) SetMastercardVisaDiscover(mastercardVisaDiscover *QualRatesWithPremiumAndRegulated) {
	t.MastercardVisaDiscover = mastercardVisaDiscover
	t.require(tiered6FeesFieldMastercardVisaDiscover)
}

// SetAmex sets the Amex field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6Fees) SetAmex(amex *Tiered6FeesAmex) {
	t.Amex = amex
	t.require(tiered6FeesFieldAmex)
}

// SetPinDebit sets the PinDebit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6Fees) SetPinDebit(pinDebit *PinDebit) {
	t.PinDebit = pinDebit
	t.require(tiered6FeesFieldPinDebit)
}

// SetElectronicBenefitsTransfer sets the ElectronicBenefitsTransfer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6Fees) SetElectronicBenefitsTransfer(electronicBenefitsTransfer *ElectronicBenefitsTransfer) {
	t.ElectronicBenefitsTransfer = electronicBenefitsTransfer
	t.require(tiered6FeesFieldElectronicBenefitsTransfer)
}

// SetSpecialityCards sets the SpecialityCards field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tiered6Fees) SetSpecialityCards(specialityCards *SpecialityCards) {
	t.SpecialityCards = specialityCards
	t.require(tiered6FeesFieldSpecialityCards)
}

func (t *Tiered6Fees) UnmarshalJSON(data []byte) error {
	type unmarshaler Tiered6Fees
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tiered6Fees(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tiered6Fees) MarshalJSON() ([]byte, error) {
	type embed Tiered6Fees
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tiered6Fees) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Polymorphic object that contains fees for American Express transactions.
//
// The value of the type field determines which variant you should use:
// -	`optBlue` - Amex OptBlue pricing program.
// -	`direct` - Amex Direct pricing program.
type Tiered6FeesAmex struct {
	Type    string
	OptBlue *Tiered6AmexOptBlue
	Direct  *Tiered6AmexDirect
}

func (t *Tiered6FeesAmex) GetType() string {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Tiered6FeesAmex) GetOptBlue() *Tiered6AmexOptBlue {
	if t == nil {
		return nil
	}
	return t.OptBlue
}

func (t *Tiered6FeesAmex) GetDirect() *Tiered6AmexDirect {
	if t == nil {
		return nil
	}
	return t.Direct
}

func (t *Tiered6FeesAmex) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	t.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", t)
	}
	switch unmarshaler.Type {
	case "optBlue":
		value := new(Tiered6AmexOptBlue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.OptBlue = value
	case "direct":
		value := new(Tiered6AmexDirect)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		t.Direct = value
	}
	return nil
}

func (t Tiered6FeesAmex) MarshalJSON() ([]byte, error) {
	if err := t.validate(); err != nil {
		return nil, err
	}
	if t.OptBlue != nil {
		return internal.MarshalJSONWithExtraProperty(t.OptBlue, "type", "optBlue")
	}
	if t.Direct != nil {
		return internal.MarshalJSONWithExtraProperty(t.Direct, "type", "direct")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", t)
}

type Tiered6FeesAmexVisitor interface {
	VisitOptBlue(*Tiered6AmexOptBlue) error
	VisitDirect(*Tiered6AmexDirect) error
}

func (t *Tiered6FeesAmex) Accept(visitor Tiered6FeesAmexVisitor) error {
	if t.OptBlue != nil {
		return visitor.VisitOptBlue(t.OptBlue)
	}
	if t.Direct != nil {
		return visitor.VisitDirect(t.Direct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", t)
}

func (t *Tiered6FeesAmex) validate() error {
	if t == nil {
		return fmt.Errorf("type %T is nil", t)
	}
	var fields []string
	if t.OptBlue != nil {
		fields = append(fields, "optBlue")
	}
	if t.Direct != nil {
		fields = append(fields, "direct")
	}
	if len(fields) == 0 {
		if t.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", t, t.Type)
		}
		return fmt.Errorf("type %T is empty", t)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", t, fields)
	}
	if t.Type != "" {
		field := fields[0]
		if t.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				t,
				t.Type,
				t,
			)
		}
	}
	return nil
}

// Time zone for the processing account.
type Timezone string

const (
	TimezonePacificMidway              Timezone = "Pacific/Midway"
	TimezonePacificHonolulu            Timezone = "Pacific/Honolulu"
	TimezoneAmericaAnchorage           Timezone = "America/Anchorage"
	TimezoneAmericaLosAngeles          Timezone = "America/Los_Angeles"
	TimezoneAmericaDenver              Timezone = "America/Denver"
	TimezoneAmericaPhoenix             Timezone = "America/Phoenix"
	TimezoneAmericaChicago             Timezone = "America/Chicago"
	TimezoneAmericaIndianaIndianapolis Timezone = "America/Indiana/Indianapolis"
	TimezoneAmericaNewYork             Timezone = "America/New_York"
)

func NewTimezoneFromString(s string) (Timezone, error) {
	switch s {
	case "Pacific/Midway":
		return TimezonePacificMidway, nil
	case "Pacific/Honolulu":
		return TimezonePacificHonolulu, nil
	case "America/Anchorage":
		return TimezoneAmericaAnchorage, nil
	case "America/Los_Angeles":
		return TimezoneAmericaLosAngeles, nil
	case "America/Denver":
		return TimezoneAmericaDenver, nil
	case "America/Phoenix":
		return TimezoneAmericaPhoenix, nil
	case "America/Chicago":
		return TimezoneAmericaChicago, nil
	case "America/Indiana/Indianapolis":
		return TimezoneAmericaIndianaIndianapolis, nil
	case "America/New_York":
		return TimezoneAmericaNewYork, nil
	}
	var t Timezone
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t Timezone) Ptr() *Timezone {
	return &t
}

// Object that contains information about the tip.
var (
	tipFieldType       = big.NewInt(1 << 0)
	tipFieldMode       = big.NewInt(1 << 1)
	tipFieldAmount     = big.NewInt(1 << 2)
	tipFieldPercentage = big.NewInt(1 << 3)
)

type Tip struct {
	// Indicates if the tip is a fixed amount or a percentage.
	// **Note:** Our gateway applies the percentage tip to the total amount of the transaction after tax.
	Type TipType `json:"type" url:"type"`
	// Indicates how the tip was added to the transaction.
	// - `prompted` – The customer was prompted to add a tip during payment.
	// - `adjusted` – The customer added a tip on the receipt for the merchant to adjust post-transaction.
	Mode *TipMode `json:"mode,omitempty" url:"mode,omitempty"`
	// If the value for type is `fixedAmount`, this value is the tip amount in the currency's lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// If the value for type is `percentage`, this value is the tip as a percentage.
	Percentage *float64 `json:"percentage,omitempty" url:"percentage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tip) GetType() TipType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Tip) GetMode() *TipMode {
	if t == nil {
		return nil
	}
	return t.Mode
}

func (t *Tip) GetAmount() *int64 {
	if t == nil {
		return nil
	}
	return t.Amount
}

func (t *Tip) GetPercentage() *float64 {
	if t == nil {
		return nil
	}
	return t.Percentage
}

func (t *Tip) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tip) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tip) SetType(type_ TipType) {
	t.Type = type_
	t.require(tipFieldType)
}

// SetMode sets the Mode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tip) SetMode(mode *TipMode) {
	t.Mode = mode
	t.require(tipFieldMode)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tip) SetAmount(amount *int64) {
	t.Amount = amount
	t.require(tipFieldAmount)
}

// SetPercentage sets the Percentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tip) SetPercentage(percentage *float64) {
	t.Percentage = percentage
	t.require(tipFieldPercentage)
}

func (t *Tip) UnmarshalJSON(data []byte) error {
	type unmarshaler Tip
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tip(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tip) MarshalJSON() ([]byte, error) {
	type embed Tip
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tip) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates how the tip was added to the transaction.
// - `prompted` – The customer was prompted to add a tip during payment.
// - `adjusted` – The customer added a tip on the receipt for the merchant to adjust post-transaction.
type TipMode string

const (
	TipModePrompted TipMode = "prompted"
	TipModeAdjusted TipMode = "adjusted"
)

func NewTipModeFromString(s string) (TipMode, error) {
	switch s {
	case "prompted":
		return TipModePrompted, nil
	case "adjusted":
		return TipModeAdjusted, nil
	}
	var t TipMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TipMode) Ptr() *TipMode {
	return &t
}

// Tip settings
var (
	tipProcessingDisabledFieldEnabled = big.NewInt(1 << 0)
)

type TipProcessingDisabled struct {
	// Indicates if the terminal can accept tips.
	Enabled bool `json:"enabled" url:"enabled"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TipProcessingDisabled) GetEnabled() bool {
	if t == nil {
		return false
	}
	return t.Enabled
}

func (t *TipProcessingDisabled) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TipProcessingDisabled) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TipProcessingDisabled) SetEnabled(enabled bool) {
	t.Enabled = enabled
	t.require(tipProcessingDisabledFieldEnabled)
}

func (t *TipProcessingDisabled) UnmarshalJSON(data []byte) error {
	type unmarshaler TipProcessingDisabled
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TipProcessingDisabled(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TipProcessingDisabled) MarshalJSON() ([]byte, error) {
	type embed TipProcessingDisabled
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TipProcessingDisabled) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Tip settings
var (
	tipProcessingEnabledFieldEnabled       = big.NewInt(1 << 0)
	tipProcessingEnabledFieldTipPrompt     = big.NewInt(1 << 1)
	tipProcessingEnabledFieldTipAdjust     = big.NewInt(1 << 2)
	tipProcessingEnabledFieldSuggestedTips = big.NewInt(1 << 3)
)

type TipProcessingEnabled struct {
	// Indicates if the terminal can accept tips.
	Enabled bool `json:"enabled" url:"enabled"`
	// Indicates if the terminal prompts for tips.
	TipPrompt *bool `json:"tipPrompt,omitempty" url:"tipPrompt,omitempty"`
	// Indicates if a clerk can adjust a tip after the customer completes the sale.
	TipAdjust *bool `json:"tipAdjust,omitempty" url:"tipAdjust,omitempty"`
	// Object that contains up to three tip amounts that the terminal displays during a sale.
	SuggestedTips *TipProcessingEnabledSuggestedTips `json:"suggestedTips,omitempty" url:"suggestedTips,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TipProcessingEnabled) GetEnabled() bool {
	if t == nil {
		return false
	}
	return t.Enabled
}

func (t *TipProcessingEnabled) GetTipPrompt() *bool {
	if t == nil {
		return nil
	}
	return t.TipPrompt
}

func (t *TipProcessingEnabled) GetTipAdjust() *bool {
	if t == nil {
		return nil
	}
	return t.TipAdjust
}

func (t *TipProcessingEnabled) GetSuggestedTips() *TipProcessingEnabledSuggestedTips {
	if t == nil {
		return nil
	}
	return t.SuggestedTips
}

func (t *TipProcessingEnabled) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TipProcessingEnabled) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TipProcessingEnabled) SetEnabled(enabled bool) {
	t.Enabled = enabled
	t.require(tipProcessingEnabledFieldEnabled)
}

// SetTipPrompt sets the TipPrompt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TipProcessingEnabled) SetTipPrompt(tipPrompt *bool) {
	t.TipPrompt = tipPrompt
	t.require(tipProcessingEnabledFieldTipPrompt)
}

// SetTipAdjust sets the TipAdjust field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TipProcessingEnabled) SetTipAdjust(tipAdjust *bool) {
	t.TipAdjust = tipAdjust
	t.require(tipProcessingEnabledFieldTipAdjust)
}

// SetSuggestedTips sets the SuggestedTips field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TipProcessingEnabled) SetSuggestedTips(suggestedTips *TipProcessingEnabledSuggestedTips) {
	t.SuggestedTips = suggestedTips
	t.require(tipProcessingEnabledFieldSuggestedTips)
}

func (t *TipProcessingEnabled) UnmarshalJSON(data []byte) error {
	type unmarshaler TipProcessingEnabled
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TipProcessingEnabled(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TipProcessingEnabled) MarshalJSON() ([]byte, error) {
	type embed TipProcessingEnabled
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TipProcessingEnabled) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains up to three tip amounts that the terminal displays during a sale.
var (
	tipProcessingEnabledSuggestedTipsFieldEnabled        = big.NewInt(1 << 0)
	tipProcessingEnabledSuggestedTipsFieldTipPercentages = big.NewInt(1 << 1)
)

type TipProcessingEnabledSuggestedTips struct {
	// Indicates if the terminal displays tip amounts during a sale.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// Array of the tip amounts that the terminal displays during a sale.
	TipPercentages []string `json:"tipPercentages,omitempty" url:"tipPercentages,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TipProcessingEnabledSuggestedTips) GetEnabled() *bool {
	if t == nil {
		return nil
	}
	return t.Enabled
}

func (t *TipProcessingEnabledSuggestedTips) GetTipPercentages() []string {
	if t == nil {
		return nil
	}
	return t.TipPercentages
}

func (t *TipProcessingEnabledSuggestedTips) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TipProcessingEnabledSuggestedTips) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetEnabled sets the Enabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TipProcessingEnabledSuggestedTips) SetEnabled(enabled *bool) {
	t.Enabled = enabled
	t.require(tipProcessingEnabledSuggestedTipsFieldEnabled)
}

// SetTipPercentages sets the TipPercentages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TipProcessingEnabledSuggestedTips) SetTipPercentages(tipPercentages []string) {
	t.TipPercentages = tipPercentages
	t.require(tipProcessingEnabledSuggestedTipsFieldTipPercentages)
}

func (t *TipProcessingEnabledSuggestedTips) UnmarshalJSON(data []byte) error {
	type unmarshaler TipProcessingEnabledSuggestedTips
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TipProcessingEnabledSuggestedTips(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TipProcessingEnabledSuggestedTips) MarshalJSON() ([]byte, error) {
	type embed TipProcessingEnabledSuggestedTips
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TipProcessingEnabledSuggestedTips) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates if the tip is a fixed amount or a percentage.
// **Note:** Our gateway applies the percentage tip to the total amount of the transaction after tax.
type TipType string

const (
	TipTypePercentage  TipType = "percentage"
	TipTypeFixedAmount TipType = "fixedAmount"
)

func NewTipTypeFromString(s string) (TipType, error) {
	switch s {
	case "percentage":
		return TipTypePercentage, nil
	case "fixedAmount":
		return TipTypeFixedAmount, nil
	}
	var t TipType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TipType) Ptr() *TipType {
	return &t
}

// Indicates who provides training to the merchant for the solution.
type TrainingProvider string

const (
	TrainingProviderPartner TrainingProvider = "partner"
	TrainingProviderPayroc  TrainingProvider = "payroc"
)

func NewTrainingProviderFromString(s string) (TrainingProvider, error) {
	switch s {
	case "partner":
		return TrainingProviderPartner, nil
	case "payroc":
		return TrainingProviderPayroc, nil
	}
	var t TrainingProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TrainingProvider) Ptr() *TrainingProvider {
	return &t
}

// Object that contains information about the transaction.
var (
	transactionFieldTransactionId    = big.NewInt(1 << 0)
	transactionFieldType             = big.NewInt(1 << 1)
	transactionFieldDate             = big.NewInt(1 << 2)
	transactionFieldAmount           = big.NewInt(1 << 3)
	transactionFieldEntryMethod      = big.NewInt(1 << 4)
	transactionFieldCreatedDate      = big.NewInt(1 << 5)
	transactionFieldLastModifiedDate = big.NewInt(1 << 6)
	transactionFieldStatus           = big.NewInt(1 << 7)
	transactionFieldCashbackAmount   = big.NewInt(1 << 8)
	transactionFieldInterchange      = big.NewInt(1 << 9)
	transactionFieldCurrency         = big.NewInt(1 << 10)
	transactionFieldMerchant         = big.NewInt(1 << 11)
	transactionFieldSettled          = big.NewInt(1 << 12)
	transactionFieldBatch            = big.NewInt(1 << 13)
	transactionFieldCard             = big.NewInt(1 << 14)
	transactionFieldAuthorization    = big.NewInt(1 << 15)
)

type Transaction struct {
	// Unique identifier that we assigned to the transaction.
	TransactionId *int `json:"transactionId,omitempty" url:"transactionId,omitempty"`
	// Indicates the type of transaction. The value is one of the following:
	//
	// - `capture` - Transaction is a sale.
	// - `return` - Transaction is a refund.
	Type *TransactionType `json:"type,omitempty" url:"type,omitempty"`
	// Date of the transaction. The format of this value is **YYYY-MM-DD**.
	Date *time.Time `json:"date,omitempty" url:"date,omitempty" format:"date"`
	// Transaction amount. We return the value in the currency's lowest denomination, for example, cents.
	Amount *int `json:"amount,omitempty" url:"amount,omitempty"`
	// Indicates how the merchant received the payment details.
	EntryMethod *TransactionEntryMethod `json:"entryMethod,omitempty" url:"entryMethod,omitempty"`
	// Date that we received the transaction.  The format of this value is **YYYY-MM-DD**.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty" format:"date"`
	// Date that the transaction was last changed.  The format of this value is **YYYY-MM-DD**.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty" format:"date"`
	// Indicates the status of the transaction. The value is one of the following:
	//
	// -	`fullSuspense` – Merchant ran the transaction while their account was in full suspense.
	// -	`heldAudited` – We have moved a transaction from fullSuspense and placed it on hold.
	// -	`heldReleasedAudited` – We audited and released the transaction that we had previously held.
	// -	`holdForSettlement30Days` - We are holding the transaction for a maximum of 30 days.
	// -	`holdForSettlementDuplicate` - We held the transaction because the transaction may be a duplicate.
	// -	`holdLongTerm` - We are holding the transaction for an extended period.
	// -	`paid` – We have paid the transaction funds to the merchant.
	// -	`paidByThirdParty` - A third party has paid the transaction funds to the merchant.
	// -	`partialRelease` – We partially released the transaction funds.
	// -	`pull` - We pulled the transaction, and the merchant does not receive funds for the transaction.
	// -	`release` - We released the transaction that we previously held.
	// -	`new` – We have prepared the funds from the transaction to send to the merchant.
	// -	`held` – We held the transaction.
	// -	`unknown` – No transaction status available.
	Status *TransactionStatus `json:"status,omitempty" url:"status,omitempty"`
	// Cashback amount. We return the value in the currency's lowest denomination, for example, cents.
	CashbackAmount *int `json:"cashbackAmount,omitempty" url:"cashbackAmount,omitempty"`
	// Object that contains information about the interchange fees for the transaction.
	Interchange *TransactionInterchange `json:"interchange,omitempty" url:"interchange,omitempty"`
	// Currency of the transaction. The value for the currency follows the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) standard.
	Currency      *string               `json:"currency,omitempty" url:"currency,omitempty"`
	Merchant      *MerchantSummary      `json:"merchant,omitempty" url:"merchant,omitempty"`
	Settled       *SettledSummary       `json:"settled,omitempty" url:"settled,omitempty"`
	Batch         *BatchSummary         `json:"batch,omitempty" url:"batch,omitempty"`
	Card          *CardSummary          `json:"card,omitempty" url:"card,omitempty"`
	Authorization *AuthorizationSummary `json:"authorization,omitempty" url:"authorization,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Transaction) GetTransactionId() *int {
	if t == nil {
		return nil
	}
	return t.TransactionId
}

func (t *Transaction) GetType() *TransactionType {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *Transaction) GetDate() *time.Time {
	if t == nil {
		return nil
	}
	return t.Date
}

func (t *Transaction) GetAmount() *int {
	if t == nil {
		return nil
	}
	return t.Amount
}

func (t *Transaction) GetEntryMethod() *TransactionEntryMethod {
	if t == nil {
		return nil
	}
	return t.EntryMethod
}

func (t *Transaction) GetCreatedDate() *time.Time {
	if t == nil {
		return nil
	}
	return t.CreatedDate
}

func (t *Transaction) GetLastModifiedDate() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastModifiedDate
}

func (t *Transaction) GetStatus() *TransactionStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *Transaction) GetCashbackAmount() *int {
	if t == nil {
		return nil
	}
	return t.CashbackAmount
}

func (t *Transaction) GetInterchange() *TransactionInterchange {
	if t == nil {
		return nil
	}
	return t.Interchange
}

func (t *Transaction) GetCurrency() *string {
	if t == nil {
		return nil
	}
	return t.Currency
}

func (t *Transaction) GetMerchant() *MerchantSummary {
	if t == nil {
		return nil
	}
	return t.Merchant
}

func (t *Transaction) GetSettled() *SettledSummary {
	if t == nil {
		return nil
	}
	return t.Settled
}

func (t *Transaction) GetBatch() *BatchSummary {
	if t == nil {
		return nil
	}
	return t.Batch
}

func (t *Transaction) GetCard() *CardSummary {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *Transaction) GetAuthorization() *AuthorizationSummary {
	if t == nil {
		return nil
	}
	return t.Authorization
}

func (t *Transaction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Transaction) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTransactionId sets the TransactionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetTransactionId(transactionId *int) {
	t.TransactionId = transactionId
	t.require(transactionFieldTransactionId)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetType(type_ *TransactionType) {
	t.Type = type_
	t.require(transactionFieldType)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetDate(date *time.Time) {
	t.Date = date
	t.require(transactionFieldDate)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetAmount(amount *int) {
	t.Amount = amount
	t.require(transactionFieldAmount)
}

// SetEntryMethod sets the EntryMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetEntryMethod(entryMethod *TransactionEntryMethod) {
	t.EntryMethod = entryMethod
	t.require(transactionFieldEntryMethod)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetCreatedDate(createdDate *time.Time) {
	t.CreatedDate = createdDate
	t.require(transactionFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetLastModifiedDate(lastModifiedDate *time.Time) {
	t.LastModifiedDate = lastModifiedDate
	t.require(transactionFieldLastModifiedDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetStatus(status *TransactionStatus) {
	t.Status = status
	t.require(transactionFieldStatus)
}

// SetCashbackAmount sets the CashbackAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetCashbackAmount(cashbackAmount *int) {
	t.CashbackAmount = cashbackAmount
	t.require(transactionFieldCashbackAmount)
}

// SetInterchange sets the Interchange field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetInterchange(interchange *TransactionInterchange) {
	t.Interchange = interchange
	t.require(transactionFieldInterchange)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetCurrency(currency *string) {
	t.Currency = currency
	t.require(transactionFieldCurrency)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetMerchant(merchant *MerchantSummary) {
	t.Merchant = merchant
	t.require(transactionFieldMerchant)
}

// SetSettled sets the Settled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetSettled(settled *SettledSummary) {
	t.Settled = settled
	t.require(transactionFieldSettled)
}

// SetBatch sets the Batch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetBatch(batch *BatchSummary) {
	t.Batch = batch
	t.require(transactionFieldBatch)
}

// SetCard sets the Card field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetCard(card *CardSummary) {
	t.Card = card
	t.require(transactionFieldCard)
}

// SetAuthorization sets the Authorization field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Transaction) SetAuthorization(authorization *AuthorizationSummary) {
	t.Authorization = authorization
	t.require(transactionFieldAuthorization)
}

func (t *Transaction) UnmarshalJSON(data []byte) error {
	type embed Transaction
	var unmarshaler = struct {
		embed
		Date             *internal.Date `json:"date,omitempty"`
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Transaction(unmarshaler.embed)
	t.Date = unmarshaler.Date.TimePtr()
	t.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	t.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transaction) MarshalJSON() ([]byte, error) {
	type embed Transaction
	var marshaler = struct {
		embed
		Date             *internal.Date `json:"date,omitempty"`
		CreatedDate      *internal.Date `json:"createdDate,omitempty"`
		LastModifiedDate *internal.Date `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*t),
		Date:             internal.NewOptionalDate(t.Date),
		CreatedDate:      internal.NewOptionalDate(t.CreatedDate),
		LastModifiedDate: internal.NewOptionalDate(t.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Transaction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates how the merchant received the payment details.
type TransactionEntryMethod string

const (
	TransactionEntryMethodBarcodeRead             TransactionEntryMethod = "barcodeRead"
	TransactionEntryMethodSmartChipRead           TransactionEntryMethod = "smartChipRead"
	TransactionEntryMethodSwipedOriginUnknown     TransactionEntryMethod = "swipedOriginUnknown"
	TransactionEntryMethodContactlessChip         TransactionEntryMethod = "contactlessChip"
	TransactionEntryMethodEcommerce               TransactionEntryMethod = "ecommerce"
	TransactionEntryMethodManuallyEntered         TransactionEntryMethod = "manuallyEntered"
	TransactionEntryMethodManuallyEnteredFallback TransactionEntryMethod = "manuallyEnteredFallback"
	TransactionEntryMethodSwiped                  TransactionEntryMethod = "swiped"
	TransactionEntryMethodSwipedFallback          TransactionEntryMethod = "swipedFallback"
	TransactionEntryMethodSwipedError             TransactionEntryMethod = "swipedError"
	TransactionEntryMethodScannedCheckReader      TransactionEntryMethod = "scannedCheckReader"
	TransactionEntryMethodCredentialOnFile        TransactionEntryMethod = "credentialOnFile"
	TransactionEntryMethodUnknown                 TransactionEntryMethod = "unknown"
)

func NewTransactionEntryMethodFromString(s string) (TransactionEntryMethod, error) {
	switch s {
	case "barcodeRead":
		return TransactionEntryMethodBarcodeRead, nil
	case "smartChipRead":
		return TransactionEntryMethodSmartChipRead, nil
	case "swipedOriginUnknown":
		return TransactionEntryMethodSwipedOriginUnknown, nil
	case "contactlessChip":
		return TransactionEntryMethodContactlessChip, nil
	case "ecommerce":
		return TransactionEntryMethodEcommerce, nil
	case "manuallyEntered":
		return TransactionEntryMethodManuallyEntered, nil
	case "manuallyEnteredFallback":
		return TransactionEntryMethodManuallyEnteredFallback, nil
	case "swiped":
		return TransactionEntryMethodSwiped, nil
	case "swipedFallback":
		return TransactionEntryMethodSwipedFallback, nil
	case "swipedError":
		return TransactionEntryMethodSwipedError, nil
	case "scannedCheckReader":
		return TransactionEntryMethodScannedCheckReader, nil
	case "credentialOnFile":
		return TransactionEntryMethodCredentialOnFile, nil
	case "unknown":
		return TransactionEntryMethodUnknown, nil
	}
	var t TransactionEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionEntryMethod) Ptr() *TransactionEntryMethod {
	return &t
}

// Object that contains information about the interchange fees for the transaction.
var (
	transactionInterchangeFieldBasisPoint     = big.NewInt(1 << 0)
	transactionInterchangeFieldTransactionFee = big.NewInt(1 << 1)
)

type TransactionInterchange struct {
	// Interchange basis points that we apply to the transaction.
	BasisPoint *int `json:"basisPoint,omitempty" url:"basisPoint,omitempty"`
	// Interchange fee for the transaction. We return the value in the currency's lowest denomination, for example, cents.
	TransactionFee *int `json:"transactionFee,omitempty" url:"transactionFee,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionInterchange) GetBasisPoint() *int {
	if t == nil {
		return nil
	}
	return t.BasisPoint
}

func (t *TransactionInterchange) GetTransactionFee() *int {
	if t == nil {
		return nil
	}
	return t.TransactionFee
}

func (t *TransactionInterchange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionInterchange) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetBasisPoint sets the BasisPoint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionInterchange) SetBasisPoint(basisPoint *int) {
	t.BasisPoint = basisPoint
	t.require(transactionInterchangeFieldBasisPoint)
}

// SetTransactionFee sets the TransactionFee field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionInterchange) SetTransactionFee(transactionFee *int) {
	t.TransactionFee = transactionFee
	t.require(transactionInterchangeFieldTransactionFee)
}

func (t *TransactionInterchange) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionInterchange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionInterchange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionInterchange) MarshalJSON() ([]byte, error) {
	type embed TransactionInterchange
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TransactionInterchange) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains information about the transaction response details.
var (
	transactionResultFieldType                  = big.NewInt(1 << 0)
	transactionResultFieldEbtType               = big.NewInt(1 << 1)
	transactionResultFieldStatus                = big.NewInt(1 << 2)
	transactionResultFieldApprovalCode          = big.NewInt(1 << 3)
	transactionResultFieldAuthorizedAmount      = big.NewInt(1 << 4)
	transactionResultFieldCurrency              = big.NewInt(1 << 5)
	transactionResultFieldResponseCode          = big.NewInt(1 << 6)
	transactionResultFieldResponseMessage       = big.NewInt(1 << 7)
	transactionResultFieldProcessorResponseCode = big.NewInt(1 << 8)
	transactionResultFieldCardSchemeReferenceId = big.NewInt(1 << 9)
)

type TransactionResult struct {
	// Transaction type.
	Type *TransactionResultType `json:"type,omitempty" url:"type,omitempty"`
	// Indicates the subtype of EBT in the transaction.
	EbtType *TransactionResultEbtType `json:"ebtType,omitempty" url:"ebtType,omitempty"`
	// Current status of the transaction.
	Status TransactionResultStatus `json:"status" url:"status"`
	// Authorization code that the processor assigned to the transaction.
	ApprovalCode *string `json:"approvalCode,omitempty" url:"approvalCode,omitempty"`
	// Amount that the processor authorized for the transaction. This value is in the currency’s lowest denomination, for example, cents.
	//
	// **Notes:**
	// - For partial authorizations, this amount is lower than the amount in the request.
	// - If the value for **authorizedAmount** is negative, this indicates that the merchant sent funds to the customer.
	AuthorizedAmount *int64    `json:"authorizedAmount,omitempty" url:"authorizedAmount,omitempty"`
	Currency         *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	// Response from the processor.
	// - `A` - The processor approved the transaction.
	// - `D` - The processor declined the transaction.
	// - `E` - The processor received the transaction but will process the transaction later.
	// - `P` - The processor authorized a portion of the original amount of the transaction.
	// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
	// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
	ResponseCode TransactionResultResponseCode `json:"responseCode" url:"responseCode"`
	// Response description from the processor.
	ResponseMessage *string `json:"responseMessage,omitempty" url:"responseMessage,omitempty"`
	// Original response code that the processor sent.
	ProcessorResponseCode *string `json:"processorResponseCode,omitempty" url:"processorResponseCode,omitempty"`
	// Identifier that the card brand assigns to the payment instruction.
	CardSchemeReferenceId *string `json:"cardSchemeReferenceId,omitempty" url:"cardSchemeReferenceId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionResult) GetType() *TransactionResultType {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TransactionResult) GetEbtType() *TransactionResultEbtType {
	if t == nil {
		return nil
	}
	return t.EbtType
}

func (t *TransactionResult) GetStatus() TransactionResultStatus {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TransactionResult) GetApprovalCode() *string {
	if t == nil {
		return nil
	}
	return t.ApprovalCode
}

func (t *TransactionResult) GetAuthorizedAmount() *int64 {
	if t == nil {
		return nil
	}
	return t.AuthorizedAmount
}

func (t *TransactionResult) GetCurrency() *Currency {
	if t == nil {
		return nil
	}
	return t.Currency
}

func (t *TransactionResult) GetResponseCode() TransactionResultResponseCode {
	if t == nil {
		return ""
	}
	return t.ResponseCode
}

func (t *TransactionResult) GetResponseMessage() *string {
	if t == nil {
		return nil
	}
	return t.ResponseMessage
}

func (t *TransactionResult) GetProcessorResponseCode() *string {
	if t == nil {
		return nil
	}
	return t.ProcessorResponseCode
}

func (t *TransactionResult) GetCardSchemeReferenceId() *string {
	if t == nil {
		return nil
	}
	return t.CardSchemeReferenceId
}

func (t *TransactionResult) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionResult) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetType(type_ *TransactionResultType) {
	t.Type = type_
	t.require(transactionResultFieldType)
}

// SetEbtType sets the EbtType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetEbtType(ebtType *TransactionResultEbtType) {
	t.EbtType = ebtType
	t.require(transactionResultFieldEbtType)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetStatus(status TransactionResultStatus) {
	t.Status = status
	t.require(transactionResultFieldStatus)
}

// SetApprovalCode sets the ApprovalCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetApprovalCode(approvalCode *string) {
	t.ApprovalCode = approvalCode
	t.require(transactionResultFieldApprovalCode)
}

// SetAuthorizedAmount sets the AuthorizedAmount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetAuthorizedAmount(authorizedAmount *int64) {
	t.AuthorizedAmount = authorizedAmount
	t.require(transactionResultFieldAuthorizedAmount)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetCurrency(currency *Currency) {
	t.Currency = currency
	t.require(transactionResultFieldCurrency)
}

// SetResponseCode sets the ResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetResponseCode(responseCode TransactionResultResponseCode) {
	t.ResponseCode = responseCode
	t.require(transactionResultFieldResponseCode)
}

// SetResponseMessage sets the ResponseMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetResponseMessage(responseMessage *string) {
	t.ResponseMessage = responseMessage
	t.require(transactionResultFieldResponseMessage)
}

// SetProcessorResponseCode sets the ProcessorResponseCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetProcessorResponseCode(processorResponseCode *string) {
	t.ProcessorResponseCode = processorResponseCode
	t.require(transactionResultFieldProcessorResponseCode)
}

// SetCardSchemeReferenceId sets the CardSchemeReferenceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionResult) SetCardSchemeReferenceId(cardSchemeReferenceId *string) {
	t.CardSchemeReferenceId = cardSchemeReferenceId
	t.require(transactionResultFieldCardSchemeReferenceId)
}

func (t *TransactionResult) UnmarshalJSON(data []byte) error {
	type unmarshaler TransactionResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransactionResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionResult) MarshalJSON() ([]byte, error) {
	type embed TransactionResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TransactionResult) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the subtype of EBT in the transaction.
type TransactionResultEbtType string

const (
	TransactionResultEbtTypeCashPurchase             TransactionResultEbtType = "cashPurchase"
	TransactionResultEbtTypeCashPurchaseWithCashback TransactionResultEbtType = "cashPurchaseWithCashback"
	TransactionResultEbtTypeFoodStampPurchase        TransactionResultEbtType = "foodStampPurchase"
	TransactionResultEbtTypeFoodStampVoucherPurchase TransactionResultEbtType = "foodStampVoucherPurchase"
	TransactionResultEbtTypeFoodStampReturn          TransactionResultEbtType = "foodStampReturn"
	TransactionResultEbtTypeFoodStampVoucherReturn   TransactionResultEbtType = "foodStampVoucherReturn"
	TransactionResultEbtTypeCashBalanceInquiry       TransactionResultEbtType = "cashBalanceInquiry"
	TransactionResultEbtTypeFoodStampBalanceInquiry  TransactionResultEbtType = "foodStampBalanceInquiry"
	TransactionResultEbtTypeCashWithdrawal           TransactionResultEbtType = "cashWithdrawal"
)

func NewTransactionResultEbtTypeFromString(s string) (TransactionResultEbtType, error) {
	switch s {
	case "cashPurchase":
		return TransactionResultEbtTypeCashPurchase, nil
	case "cashPurchaseWithCashback":
		return TransactionResultEbtTypeCashPurchaseWithCashback, nil
	case "foodStampPurchase":
		return TransactionResultEbtTypeFoodStampPurchase, nil
	case "foodStampVoucherPurchase":
		return TransactionResultEbtTypeFoodStampVoucherPurchase, nil
	case "foodStampReturn":
		return TransactionResultEbtTypeFoodStampReturn, nil
	case "foodStampVoucherReturn":
		return TransactionResultEbtTypeFoodStampVoucherReturn, nil
	case "cashBalanceInquiry":
		return TransactionResultEbtTypeCashBalanceInquiry, nil
	case "foodStampBalanceInquiry":
		return TransactionResultEbtTypeFoodStampBalanceInquiry, nil
	case "cashWithdrawal":
		return TransactionResultEbtTypeCashWithdrawal, nil
	}
	var t TransactionResultEbtType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionResultEbtType) Ptr() *TransactionResultEbtType {
	return &t
}

// Response from the processor.
// - `A` - The processor approved the transaction.
// - `D` - The processor declined the transaction.
// - `E` - The processor received the transaction but will process the transaction later.
// - `P` - The processor authorized a portion of the original amount of the transaction.
// - `R` - The issuer declined the transaction and indicated that the customer should contact their bank.
// - `C` - The issuer declined the transaction and indicated that the merchant should keep the card as it was reported lost or stolen.
type TransactionResultResponseCode string

const (
	TransactionResultResponseCodeA TransactionResultResponseCode = "A"
	TransactionResultResponseCodeD TransactionResultResponseCode = "D"
	TransactionResultResponseCodeE TransactionResultResponseCode = "E"
	TransactionResultResponseCodeP TransactionResultResponseCode = "P"
	TransactionResultResponseCodeR TransactionResultResponseCode = "R"
	TransactionResultResponseCodeC TransactionResultResponseCode = "C"
)

func NewTransactionResultResponseCodeFromString(s string) (TransactionResultResponseCode, error) {
	switch s {
	case "A":
		return TransactionResultResponseCodeA, nil
	case "D":
		return TransactionResultResponseCodeD, nil
	case "E":
		return TransactionResultResponseCodeE, nil
	case "P":
		return TransactionResultResponseCodeP, nil
	case "R":
		return TransactionResultResponseCodeR, nil
	case "C":
		return TransactionResultResponseCodeC, nil
	}
	var t TransactionResultResponseCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionResultResponseCode) Ptr() *TransactionResultResponseCode {
	return &t
}

// Current status of the transaction.
type TransactionResultStatus string

const (
	TransactionResultStatusReady    TransactionResultStatus = "ready"
	TransactionResultStatusPending  TransactionResultStatus = "pending"
	TransactionResultStatusDeclined TransactionResultStatus = "declined"
	TransactionResultStatusComplete TransactionResultStatus = "complete"
	TransactionResultStatusReferral TransactionResultStatus = "referral"
	TransactionResultStatusPickup   TransactionResultStatus = "pickup"
	TransactionResultStatusReversal TransactionResultStatus = "reversal"
	TransactionResultStatusAdmin    TransactionResultStatus = "admin"
	TransactionResultStatusExpired  TransactionResultStatus = "expired"
	TransactionResultStatusAccepted TransactionResultStatus = "accepted"
)

func NewTransactionResultStatusFromString(s string) (TransactionResultStatus, error) {
	switch s {
	case "ready":
		return TransactionResultStatusReady, nil
	case "pending":
		return TransactionResultStatusPending, nil
	case "declined":
		return TransactionResultStatusDeclined, nil
	case "complete":
		return TransactionResultStatusComplete, nil
	case "referral":
		return TransactionResultStatusReferral, nil
	case "pickup":
		return TransactionResultStatusPickup, nil
	case "reversal":
		return TransactionResultStatusReversal, nil
	case "admin":
		return TransactionResultStatusAdmin, nil
	case "expired":
		return TransactionResultStatusExpired, nil
	case "accepted":
		return TransactionResultStatusAccepted, nil
	}
	var t TransactionResultStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionResultStatus) Ptr() *TransactionResultStatus {
	return &t
}

// Transaction type.
type TransactionResultType string

const (
	TransactionResultTypeSale                       TransactionResultType = "sale"
	TransactionResultTypeRefund                     TransactionResultType = "refund"
	TransactionResultTypePreAuthorization           TransactionResultType = "preAuthorization"
	TransactionResultTypePreAuthorizationCompletion TransactionResultType = "preAuthorizationCompletion"
)

func NewTransactionResultTypeFromString(s string) (TransactionResultType, error) {
	switch s {
	case "sale":
		return TransactionResultTypeSale, nil
	case "refund":
		return TransactionResultTypeRefund, nil
	case "preAuthorization":
		return TransactionResultTypePreAuthorization, nil
	case "preAuthorizationCompletion":
		return TransactionResultTypePreAuthorizationCompletion, nil
	}
	var t TransactionResultType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionResultType) Ptr() *TransactionResultType {
	return &t
}

// Indicates the status of the transaction. The value is one of the following:
//
// -	`fullSuspense` – Merchant ran the transaction while their account was in full suspense.
// -	`heldAudited` – We have moved a transaction from fullSuspense and placed it on hold.
// -	`heldReleasedAudited` – We audited and released the transaction that we had previously held.
// -	`holdForSettlement30Days` - We are holding the transaction for a maximum of 30 days.
// -	`holdForSettlementDuplicate` - We held the transaction because the transaction may be a duplicate.
// -	`holdLongTerm` - We are holding the transaction for an extended period.
// -	`paid` – We have paid the transaction funds to the merchant.
// -	`paidByThirdParty` - A third party has paid the transaction funds to the merchant.
// -	`partialRelease` – We partially released the transaction funds.
// -	`pull` - We pulled the transaction, and the merchant does not receive funds for the transaction.
// -	`release` - We released the transaction that we previously held.
// -	`new` – We have prepared the funds from the transaction to send to the merchant.
// -	`held` – We held the transaction.
// -	`unknown` – No transaction status available.
type TransactionStatus string

const (
	TransactionStatusFullSuspense               TransactionStatus = "fullSuspense"
	TransactionStatusHeldAudited                TransactionStatus = "heldAudited"
	TransactionStatusHeldReleasedAudited        TransactionStatus = "heldReleasedAudited"
	TransactionStatusHoldForSettlement30Days    TransactionStatus = "holdForSettlement30Days"
	TransactionStatusHoldForSettlementDuplicate TransactionStatus = "holdForSettlementDuplicate"
	TransactionStatusHoldLongTerm               TransactionStatus = "holdLongTerm"
	TransactionStatusPaid                       TransactionStatus = "paid"
	TransactionStatusPaidByThirdParty           TransactionStatus = "paidByThirdParty"
	TransactionStatusPartialRelease             TransactionStatus = "partialRelease"
	TransactionStatusPull                       TransactionStatus = "pull"
	TransactionStatusRelease                    TransactionStatus = "release"
	TransactionStatusNew                        TransactionStatus = "new"
	TransactionStatusHeld                       TransactionStatus = "held"
	TransactionStatusUnknown                    TransactionStatus = "unknown"
)

func NewTransactionStatusFromString(s string) (TransactionStatus, error) {
	switch s {
	case "fullSuspense":
		return TransactionStatusFullSuspense, nil
	case "heldAudited":
		return TransactionStatusHeldAudited, nil
	case "heldReleasedAudited":
		return TransactionStatusHeldReleasedAudited, nil
	case "holdForSettlement30Days":
		return TransactionStatusHoldForSettlement30Days, nil
	case "holdForSettlementDuplicate":
		return TransactionStatusHoldForSettlementDuplicate, nil
	case "holdLongTerm":
		return TransactionStatusHoldLongTerm, nil
	case "paid":
		return TransactionStatusPaid, nil
	case "paidByThirdParty":
		return TransactionStatusPaidByThirdParty, nil
	case "partialRelease":
		return TransactionStatusPartialRelease, nil
	case "pull":
		return TransactionStatusPull, nil
	case "release":
		return TransactionStatusRelease, nil
	case "new":
		return TransactionStatusNew, nil
	case "held":
		return TransactionStatusHeld, nil
	case "unknown":
		return TransactionStatusUnknown, nil
	}
	var t TransactionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionStatus) Ptr() *TransactionStatus {
	return &t
}

// Object that contains summary information about the transaction that the dispute is linked to.
var (
	transactionSummaryFieldTransactionId = big.NewInt(1 << 0)
	transactionSummaryFieldType          = big.NewInt(1 << 1)
	transactionSummaryFieldDate          = big.NewInt(1 << 2)
	transactionSummaryFieldEntryMethod   = big.NewInt(1 << 3)
	transactionSummaryFieldAmount        = big.NewInt(1 << 4)
	transactionSummaryFieldLink          = big.NewInt(1 << 5)
)

type TransactionSummary struct {
	// Unique identifier of the transaction. If we can't match a dispute to a transaction, we don't return the transactionId or link object.
	TransactionId *int `json:"transactionId,omitempty" url:"transactionId,omitempty"`
	// Indicates the type of transaction.
	Type *TransactionSummaryType `json:"type,omitempty" url:"type,omitempty"`
	// Date of the transaction. The format of this value is **YYYY-MM-DD**.
	Date *time.Time `json:"date,omitempty" url:"date,omitempty" format:"date"`
	// Describes how the merchant received the payment details. If we can't match a dispute to a transaction, we don't return an entryMethod object.
	EntryMethod *TransactionSummaryEntryMethod `json:"entryMethod,omitempty" url:"entryMethod,omitempty"`
	// Total amount of the transaction. The value is in the currency's lowest denomination, for example, cents.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	Link   *Link  `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TransactionSummary) GetTransactionId() *int {
	if t == nil {
		return nil
	}
	return t.TransactionId
}

func (t *TransactionSummary) GetType() *TransactionSummaryType {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TransactionSummary) GetDate() *time.Time {
	if t == nil {
		return nil
	}
	return t.Date
}

func (t *TransactionSummary) GetEntryMethod() *TransactionSummaryEntryMethod {
	if t == nil {
		return nil
	}
	return t.EntryMethod
}

func (t *TransactionSummary) GetAmount() *int64 {
	if t == nil {
		return nil
	}
	return t.Amount
}

func (t *TransactionSummary) GetLink() *Link {
	if t == nil {
		return nil
	}
	return t.Link
}

func (t *TransactionSummary) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TransactionSummary) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTransactionId sets the TransactionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionSummary) SetTransactionId(transactionId *int) {
	t.TransactionId = transactionId
	t.require(transactionSummaryFieldTransactionId)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionSummary) SetType(type_ *TransactionSummaryType) {
	t.Type = type_
	t.require(transactionSummaryFieldType)
}

// SetDate sets the Date field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionSummary) SetDate(date *time.Time) {
	t.Date = date
	t.require(transactionSummaryFieldDate)
}

// SetEntryMethod sets the EntryMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionSummary) SetEntryMethod(entryMethod *TransactionSummaryEntryMethod) {
	t.EntryMethod = entryMethod
	t.require(transactionSummaryFieldEntryMethod)
}

// SetAmount sets the Amount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionSummary) SetAmount(amount *int64) {
	t.Amount = amount
	t.require(transactionSummaryFieldAmount)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TransactionSummary) SetLink(link *Link) {
	t.Link = link
	t.require(transactionSummaryFieldLink)
}

func (t *TransactionSummary) UnmarshalJSON(data []byte) error {
	type embed TransactionSummary
	var unmarshaler = struct {
		embed
		Date *internal.Date `json:"date,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TransactionSummary(unmarshaler.embed)
	t.Date = unmarshaler.Date.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TransactionSummary) MarshalJSON() ([]byte, error) {
	type embed TransactionSummary
	var marshaler = struct {
		embed
		Date *internal.Date `json:"date,omitempty"`
	}{
		embed: embed(*t),
		Date:  internal.NewOptionalDate(t.Date),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TransactionSummary) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Describes how the merchant received the payment details. If we can't match a dispute to a transaction, we don't return an entryMethod object.
type TransactionSummaryEntryMethod string

const (
	TransactionSummaryEntryMethodBarcodeRead             TransactionSummaryEntryMethod = "barcodeRead"
	TransactionSummaryEntryMethodSmartChipRead           TransactionSummaryEntryMethod = "smartChipRead"
	TransactionSummaryEntryMethodSwipedOriginUnknown     TransactionSummaryEntryMethod = "swipedOriginUnknown"
	TransactionSummaryEntryMethodContactlessChip         TransactionSummaryEntryMethod = "contactlessChip"
	TransactionSummaryEntryMethodEcommerce               TransactionSummaryEntryMethod = "ecommerce"
	TransactionSummaryEntryMethodManuallyEntered         TransactionSummaryEntryMethod = "manuallyEntered"
	TransactionSummaryEntryMethodManuallyEnteredFallback TransactionSummaryEntryMethod = "manuallyEnteredFallback"
	TransactionSummaryEntryMethodSwiped                  TransactionSummaryEntryMethod = "swiped"
	TransactionSummaryEntryMethodSwipedFallback          TransactionSummaryEntryMethod = "swipedFallback"
	TransactionSummaryEntryMethodSwipedError             TransactionSummaryEntryMethod = "swipedError"
	TransactionSummaryEntryMethodScannedCheckReader      TransactionSummaryEntryMethod = "scannedCheckReader"
	TransactionSummaryEntryMethodCredentialOnFile        TransactionSummaryEntryMethod = "credentialOnFile"
	TransactionSummaryEntryMethodUnknown                 TransactionSummaryEntryMethod = "unknown"
)

func NewTransactionSummaryEntryMethodFromString(s string) (TransactionSummaryEntryMethod, error) {
	switch s {
	case "barcodeRead":
		return TransactionSummaryEntryMethodBarcodeRead, nil
	case "smartChipRead":
		return TransactionSummaryEntryMethodSmartChipRead, nil
	case "swipedOriginUnknown":
		return TransactionSummaryEntryMethodSwipedOriginUnknown, nil
	case "contactlessChip":
		return TransactionSummaryEntryMethodContactlessChip, nil
	case "ecommerce":
		return TransactionSummaryEntryMethodEcommerce, nil
	case "manuallyEntered":
		return TransactionSummaryEntryMethodManuallyEntered, nil
	case "manuallyEnteredFallback":
		return TransactionSummaryEntryMethodManuallyEnteredFallback, nil
	case "swiped":
		return TransactionSummaryEntryMethodSwiped, nil
	case "swipedFallback":
		return TransactionSummaryEntryMethodSwipedFallback, nil
	case "swipedError":
		return TransactionSummaryEntryMethodSwipedError, nil
	case "scannedCheckReader":
		return TransactionSummaryEntryMethodScannedCheckReader, nil
	case "credentialOnFile":
		return TransactionSummaryEntryMethodCredentialOnFile, nil
	case "unknown":
		return TransactionSummaryEntryMethodUnknown, nil
	}
	var t TransactionSummaryEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionSummaryEntryMethod) Ptr() *TransactionSummaryEntryMethod {
	return &t
}

// Indicates the type of transaction.
type TransactionSummaryType string

const (
	TransactionSummaryTypeCapture TransactionSummaryType = "capture"
	TransactionSummaryTypeReturn  TransactionSummaryType = "return"
)

func NewTransactionSummaryTypeFromString(s string) (TransactionSummaryType, error) {
	switch s {
	case "capture":
		return TransactionSummaryTypeCapture, nil
	case "return":
		return TransactionSummaryTypeReturn, nil
	}
	var t TransactionSummaryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionSummaryType) Ptr() *TransactionSummaryType {
	return &t
}

// Indicates the type of transaction. The value is one of the following:
//
// - `capture` - Transaction is a sale.
// - `return` - Transaction is a refund.
type TransactionType string

const (
	TransactionTypeCapture TransactionType = "capture"
	TransactionTypeReturn  TransactionType = "return"
)

func NewTransactionTypeFromString(s string) (TransactionType, error) {
	switch s {
	case "capture":
		return TransactionTypeCapture, nil
	case "return":
		return TransactionTypeReturn, nil
	}
	var t TransactionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionType) Ptr() *TransactionType {
	return &t
}

var (
	tsysFieldMerchant = big.NewInt(1 << 0)
	tsysFieldTerminal = big.NewInt(1 << 1)
)

type Tsys struct {
	// Object that contains the configuration settings for the merchant.
	Merchant *TsysMerchant `json:"merchant" url:"merchant"`
	// Object that contains the configuration settings for the terminal.
	Terminal *TsysTerminal `json:"terminal" url:"terminal"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tsys) GetMerchant() *TsysMerchant {
	if t == nil {
		return nil
	}
	return t.Merchant
}

func (t *Tsys) GetTerminal() *TsysTerminal {
	if t == nil {
		return nil
	}
	return t.Terminal
}

func (t *Tsys) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tsys) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetMerchant sets the Merchant field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tsys) SetMerchant(merchant *TsysMerchant) {
	t.Merchant = merchant
	t.require(tsysFieldMerchant)
}

// SetTerminal sets the Terminal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Tsys) SetTerminal(terminal *TsysTerminal) {
	t.Terminal = terminal
	t.require(tsysFieldTerminal)
}

func (t *Tsys) UnmarshalJSON(data []byte) error {
	type unmarshaler Tsys
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tsys(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tsys) MarshalJSON() ([]byte, error) {
	type embed Tsys
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Tsys) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains the configuration settings for the merchant.
var (
	tsysMerchantFieldPosMid                 = big.NewInt(1 << 0)
	tsysMerchantFieldChainNumber            = big.NewInt(1 << 1)
	tsysMerchantFieldSettlementAgent        = big.NewInt(1 << 2)
	tsysMerchantFieldAbaNumber              = big.NewInt(1 << 3)
	tsysMerchantFieldBinNumber              = big.NewInt(1 << 4)
	tsysMerchantFieldAgentBankNumber        = big.NewInt(1 << 5)
	tsysMerchantFieldReimbursementAttribute = big.NewInt(1 << 6)
	tsysMerchantFieldLocationNumber         = big.NewInt(1 << 7)
)

type TsysMerchant struct {
	// Unique identifier that the host processor assigned to the merchant.
	PosMid string `json:"posMid" url:"posMid"`
	// Number that represents the merchant's chain of locations or stores.
	ChainNumber string `json:"chainNumber" url:"chainNumber"`
	// Unique identifier of the merchant's settlement agent.
	SettlementAgent *string `json:"settlementAgent,omitempty" url:"settlementAgent,omitempty"`
	// Number that identifies the merchant in direct debit requests.
	AbaNumber *string `json:"abaNumber,omitempty" url:"abaNumber,omitempty"`
	// Unique identifier of the merchant's bank.
	BinNumber string `json:"binNumber" url:"binNumber"`
	// Number of the merchant's bank if it processes transactions on behalf of another entity.
	AgentBankNumber *string `json:"agentBankNumber,omitempty" url:"agentBankNumber,omitempty"`
	// Indicates if the merchant can accept interlink debit cards.
	ReimbursementAttribute *string `json:"reimbursementAttribute,omitempty" url:"reimbursementAttribute,omitempty"`
	// Location of the merchant's information.
	LocationNumber *string `json:"locationNumber,omitempty" url:"locationNumber,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TsysMerchant) GetPosMid() string {
	if t == nil {
		return ""
	}
	return t.PosMid
}

func (t *TsysMerchant) GetChainNumber() string {
	if t == nil {
		return ""
	}
	return t.ChainNumber
}

func (t *TsysMerchant) GetSettlementAgent() *string {
	if t == nil {
		return nil
	}
	return t.SettlementAgent
}

func (t *TsysMerchant) GetAbaNumber() *string {
	if t == nil {
		return nil
	}
	return t.AbaNumber
}

func (t *TsysMerchant) GetBinNumber() string {
	if t == nil {
		return ""
	}
	return t.BinNumber
}

func (t *TsysMerchant) GetAgentBankNumber() *string {
	if t == nil {
		return nil
	}
	return t.AgentBankNumber
}

func (t *TsysMerchant) GetReimbursementAttribute() *string {
	if t == nil {
		return nil
	}
	return t.ReimbursementAttribute
}

func (t *TsysMerchant) GetLocationNumber() *string {
	if t == nil {
		return nil
	}
	return t.LocationNumber
}

func (t *TsysMerchant) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TsysMerchant) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetPosMid sets the PosMid field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetPosMid(posMid string) {
	t.PosMid = posMid
	t.require(tsysMerchantFieldPosMid)
}

// SetChainNumber sets the ChainNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetChainNumber(chainNumber string) {
	t.ChainNumber = chainNumber
	t.require(tsysMerchantFieldChainNumber)
}

// SetSettlementAgent sets the SettlementAgent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetSettlementAgent(settlementAgent *string) {
	t.SettlementAgent = settlementAgent
	t.require(tsysMerchantFieldSettlementAgent)
}

// SetAbaNumber sets the AbaNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetAbaNumber(abaNumber *string) {
	t.AbaNumber = abaNumber
	t.require(tsysMerchantFieldAbaNumber)
}

// SetBinNumber sets the BinNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetBinNumber(binNumber string) {
	t.BinNumber = binNumber
	t.require(tsysMerchantFieldBinNumber)
}

// SetAgentBankNumber sets the AgentBankNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetAgentBankNumber(agentBankNumber *string) {
	t.AgentBankNumber = agentBankNumber
	t.require(tsysMerchantFieldAgentBankNumber)
}

// SetReimbursementAttribute sets the ReimbursementAttribute field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetReimbursementAttribute(reimbursementAttribute *string) {
	t.ReimbursementAttribute = reimbursementAttribute
	t.require(tsysMerchantFieldReimbursementAttribute)
}

// SetLocationNumber sets the LocationNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysMerchant) SetLocationNumber(locationNumber *string) {
	t.LocationNumber = locationNumber
	t.require(tsysMerchantFieldLocationNumber)
}

func (t *TsysMerchant) UnmarshalJSON(data []byte) error {
	type unmarshaler TsysMerchant
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TsysMerchant(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TsysMerchant) MarshalJSON() ([]byte, error) {
	type embed TsysMerchant
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TsysMerchant) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Object that contains the configuration settings for the terminal.
var (
	tsysTerminalFieldTerminalId         = big.NewInt(1 << 0)
	tsysTerminalFieldTerminalNumber     = big.NewInt(1 << 1)
	tsysTerminalFieldAuthenticationCode = big.NewInt(1 << 2)
	tsysTerminalFieldSharingGroups      = big.NewInt(1 << 3)
	tsysTerminalFieldMotoAllowed        = big.NewInt(1 << 4)
	tsysTerminalFieldInternetAllowed    = big.NewInt(1 << 5)
	tsysTerminalFieldCardPresentAllowed = big.NewInt(1 << 6)
)

type TsysTerminal struct {
	// Unique identifier that the host processor assigned to the terminal.
	TerminalId string `json:"terminalId" url:"terminalId"`
	// Unique identifier of the terminal at the merchant's site.
	TerminalNumber string `json:"terminalNumber" url:"terminalNumber"`
	// Authenticates the terminal's identity with the host processor.
	AuthenticationCode *string `json:"authenticationCode,omitempty" url:"authenticationCode,omitempty"`
	// Indicates the direct debit networks and EBT networks that the terminal can use.
	SharingGroups *string `json:"sharingGroups,omitempty" url:"sharingGroups,omitempty"`
	// Indicates if the terminal can run Mail Order/Telephone Order (MOTO) transactions.
	MotoAllowed *bool `json:"motoAllowed,omitempty" url:"motoAllowed,omitempty"`
	// Indicates if the terminal can run e-Commerce transactions.
	InternetAllowed *bool `json:"internetAllowed,omitempty" url:"internetAllowed,omitempty"`
	// Indicates if the terminal can run card present transactions.
	CardPresentAllowed *bool `json:"cardPresentAllowed,omitempty" url:"cardPresentAllowed,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TsysTerminal) GetTerminalId() string {
	if t == nil {
		return ""
	}
	return t.TerminalId
}

func (t *TsysTerminal) GetTerminalNumber() string {
	if t == nil {
		return ""
	}
	return t.TerminalNumber
}

func (t *TsysTerminal) GetAuthenticationCode() *string {
	if t == nil {
		return nil
	}
	return t.AuthenticationCode
}

func (t *TsysTerminal) GetSharingGroups() *string {
	if t == nil {
		return nil
	}
	return t.SharingGroups
}

func (t *TsysTerminal) GetMotoAllowed() *bool {
	if t == nil {
		return nil
	}
	return t.MotoAllowed
}

func (t *TsysTerminal) GetInternetAllowed() *bool {
	if t == nil {
		return nil
	}
	return t.InternetAllowed
}

func (t *TsysTerminal) GetCardPresentAllowed() *bool {
	if t == nil {
		return nil
	}
	return t.CardPresentAllowed
}

func (t *TsysTerminal) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TsysTerminal) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTerminalId sets the TerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysTerminal) SetTerminalId(terminalId string) {
	t.TerminalId = terminalId
	t.require(tsysTerminalFieldTerminalId)
}

// SetTerminalNumber sets the TerminalNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysTerminal) SetTerminalNumber(terminalNumber string) {
	t.TerminalNumber = terminalNumber
	t.require(tsysTerminalFieldTerminalNumber)
}

// SetAuthenticationCode sets the AuthenticationCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysTerminal) SetAuthenticationCode(authenticationCode *string) {
	t.AuthenticationCode = authenticationCode
	t.require(tsysTerminalFieldAuthenticationCode)
}

// SetSharingGroups sets the SharingGroups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysTerminal) SetSharingGroups(sharingGroups *string) {
	t.SharingGroups = sharingGroups
	t.require(tsysTerminalFieldSharingGroups)
}

// SetMotoAllowed sets the MotoAllowed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysTerminal) SetMotoAllowed(motoAllowed *bool) {
	t.MotoAllowed = motoAllowed
	t.require(tsysTerminalFieldMotoAllowed)
}

// SetInternetAllowed sets the InternetAllowed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysTerminal) SetInternetAllowed(internetAllowed *bool) {
	t.InternetAllowed = internetAllowed
	t.require(tsysTerminalFieldInternetAllowed)
}

// SetCardPresentAllowed sets the CardPresentAllowed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TsysTerminal) SetCardPresentAllowed(cardPresentAllowed *bool) {
	t.CardPresentAllowed = cardPresentAllowed
	t.require(tsysTerminalFieldCardPresentAllowed)
}

func (t *TsysTerminal) UnmarshalJSON(data []byte) error {
	type unmarshaler TsysTerminal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TsysTerminal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TsysTerminal) MarshalJSON() ([]byte, error) {
	type embed TsysTerminal
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TsysTerminal) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Unit of measurement for the item. For more information about units of measurement, go to [Units of measurement](https://docs.payroc.com/knowledge/basic-concepts/units-of-measurement).
type UnitOfMeasure string

const (
	UnitOfMeasureAcr UnitOfMeasure = "ACR"
	UnitOfMeasureAmh UnitOfMeasure = "AMH"
	UnitOfMeasureAmp UnitOfMeasure = "AMP"
	UnitOfMeasureApz UnitOfMeasure = "APZ"
	UnitOfMeasureAre UnitOfMeasure = "ARE"
	UnitOfMeasureAsm UnitOfMeasure = "ASM"
	UnitOfMeasureAsv UnitOfMeasure = "ASV"
	UnitOfMeasureAtm UnitOfMeasure = "ATM"
	UnitOfMeasureAtt UnitOfMeasure = "ATT"
	UnitOfMeasureBar UnitOfMeasure = "BAR"
	UnitOfMeasureBft UnitOfMeasure = "BFT"
	UnitOfMeasureBhp UnitOfMeasure = "BHP"
	UnitOfMeasureBhx UnitOfMeasure = "BHX"
	UnitOfMeasureBil UnitOfMeasure = "BIL"
	UnitOfMeasureBld UnitOfMeasure = "BLD"
	UnitOfMeasureBll UnitOfMeasure = "BLL"
	UnitOfMeasureBql UnitOfMeasure = "BQL"
	UnitOfMeasureBtu UnitOfMeasure = "BTU"
	UnitOfMeasureBua UnitOfMeasure = "BUA"
	UnitOfMeasureBui UnitOfMeasure = "BUI"
	UnitOfMeasureBx  UnitOfMeasure = "BX"
	UnitOfMeasureCct UnitOfMeasure = "CCT"
	UnitOfMeasureCdl UnitOfMeasure = "CDL"
	UnitOfMeasureCel UnitOfMeasure = "CEL"
	UnitOfMeasureCen UnitOfMeasure = "CEN"
	UnitOfMeasureCgm UnitOfMeasure = "CGM"
	UnitOfMeasureCkg UnitOfMeasure = "CKG"
	UnitOfMeasureClf UnitOfMeasure = "CLF"
	UnitOfMeasureClt UnitOfMeasure = "CLT"
	UnitOfMeasureCmk UnitOfMeasure = "CMK"
	UnitOfMeasureCmt UnitOfMeasure = "CMT"
	UnitOfMeasureCnp UnitOfMeasure = "CNP"
	UnitOfMeasureCnt UnitOfMeasure = "CNT"
	UnitOfMeasureCou UnitOfMeasure = "COU"
	UnitOfMeasureCs  UnitOfMeasure = "CS"
	UnitOfMeasureCtm UnitOfMeasure = "CTM"
	UnitOfMeasureCur UnitOfMeasure = "CUR"
	UnitOfMeasureCwa UnitOfMeasure = "CWA"
	UnitOfMeasureDaa UnitOfMeasure = "DAA"
	UnitOfMeasureDad UnitOfMeasure = "DAD"
	UnitOfMeasureDay UnitOfMeasure = "DAY"
	UnitOfMeasureDec UnitOfMeasure = "DEC"
	UnitOfMeasureDlt UnitOfMeasure = "DLT"
	UnitOfMeasureDmk UnitOfMeasure = "DMK"
	UnitOfMeasureDmq UnitOfMeasure = "DMQ"
	UnitOfMeasureDmt UnitOfMeasure = "DMT"
	UnitOfMeasureDpc UnitOfMeasure = "DPC"
	UnitOfMeasureDpt UnitOfMeasure = "DPT"
	UnitOfMeasureDra UnitOfMeasure = "DRA"
	UnitOfMeasureDri UnitOfMeasure = "DRI"
	UnitOfMeasureDrl UnitOfMeasure = "DRL"
	UnitOfMeasureDrm UnitOfMeasure = "DRM"
	UnitOfMeasureDth UnitOfMeasure = "DTH"
	UnitOfMeasureDtn UnitOfMeasure = "DTN"
	UnitOfMeasureDwt UnitOfMeasure = "DWT"
	UnitOfMeasureDzn UnitOfMeasure = "DZN"
	UnitOfMeasureDzp UnitOfMeasure = "DZP"
	UnitOfMeasureDzr UnitOfMeasure = "DZR"
	UnitOfMeasureEa  UnitOfMeasure = "EA"
	UnitOfMeasureEac UnitOfMeasure = "EAC"
	UnitOfMeasureFah UnitOfMeasure = "FAH"
	UnitOfMeasureFar UnitOfMeasure = "FAR"
	UnitOfMeasureFot UnitOfMeasure = "FOT"
	UnitOfMeasureFtk UnitOfMeasure = "FTK"
	UnitOfMeasureFtq UnitOfMeasure = "FTQ"
	UnitOfMeasureGbq UnitOfMeasure = "GBQ"
	UnitOfMeasureGfi UnitOfMeasure = "GFI"
	UnitOfMeasureGgr UnitOfMeasure = "GGR"
	UnitOfMeasureGii UnitOfMeasure = "GII"
	UnitOfMeasureGld UnitOfMeasure = "GLD"
	UnitOfMeasureGli UnitOfMeasure = "GLI"
	UnitOfMeasureGll UnitOfMeasure = "GLL"
	UnitOfMeasureGrm UnitOfMeasure = "GRM"
	UnitOfMeasureGrn UnitOfMeasure = "GRN"
	UnitOfMeasureGro UnitOfMeasure = "GRO"
	UnitOfMeasureGrt UnitOfMeasure = "GRT"
	UnitOfMeasureGwh UnitOfMeasure = "GWH"
	UnitOfMeasureHar UnitOfMeasure = "HAR"
	UnitOfMeasureHba UnitOfMeasure = "HBA"
	UnitOfMeasureHgm UnitOfMeasure = "HGM"
	UnitOfMeasureHiu UnitOfMeasure = "HIU"
	UnitOfMeasureHlt UnitOfMeasure = "HLT"
	UnitOfMeasureHmq UnitOfMeasure = "HMQ"
	UnitOfMeasureHmt UnitOfMeasure = "HMT"
	UnitOfMeasureHpa UnitOfMeasure = "HPA"
	UnitOfMeasureHtz UnitOfMeasure = "HTZ"
	UnitOfMeasureHur UnitOfMeasure = "HUR"
	UnitOfMeasureInh UnitOfMeasure = "INH"
	UnitOfMeasureInk UnitOfMeasure = "INK"
	UnitOfMeasureInq UnitOfMeasure = "INQ"
	UnitOfMeasureItm UnitOfMeasure = "ITM"
	UnitOfMeasureJou UnitOfMeasure = "JOU"
	UnitOfMeasureKba UnitOfMeasure = "KBA"
	UnitOfMeasureKel UnitOfMeasure = "KEL"
	UnitOfMeasureKgm UnitOfMeasure = "KGM"
	UnitOfMeasureKgs UnitOfMeasure = "KGS"
	UnitOfMeasureKhz UnitOfMeasure = "KHZ"
	UnitOfMeasureKjo UnitOfMeasure = "KJO"
	UnitOfMeasureKmh UnitOfMeasure = "KMH"
	UnitOfMeasureKmk UnitOfMeasure = "KMK"
	UnitOfMeasureKmq UnitOfMeasure = "KMQ"
	UnitOfMeasureKmt UnitOfMeasure = "KMT"
	UnitOfMeasureKni UnitOfMeasure = "KNI"
	UnitOfMeasureKns UnitOfMeasure = "KNS"
	UnitOfMeasureKnt UnitOfMeasure = "KNT"
	UnitOfMeasureKpa UnitOfMeasure = "KPA"
	UnitOfMeasureKph UnitOfMeasure = "KPH"
	UnitOfMeasureKpo UnitOfMeasure = "KPO"
	UnitOfMeasureKpp UnitOfMeasure = "KPP"
	UnitOfMeasureKsd UnitOfMeasure = "KSD"
	UnitOfMeasureKsh UnitOfMeasure = "KSH"
	UnitOfMeasureKtn UnitOfMeasure = "KTN"
	UnitOfMeasureKur UnitOfMeasure = "KUR"
	UnitOfMeasureKva UnitOfMeasure = "KVA"
	UnitOfMeasureKvr UnitOfMeasure = "KVR"
	UnitOfMeasureKvt UnitOfMeasure = "KVT"
	UnitOfMeasureKwh UnitOfMeasure = "KWH"
	UnitOfMeasureKwt UnitOfMeasure = "KWT"
	UnitOfMeasureLbr UnitOfMeasure = "LBR"
	UnitOfMeasureLbs UnitOfMeasure = "LBS"
	UnitOfMeasureLef UnitOfMeasure = "LEF"
	UnitOfMeasureLpa UnitOfMeasure = "LPA"
	UnitOfMeasureLtn UnitOfMeasure = "LTN"
	UnitOfMeasureLtr UnitOfMeasure = "LTR"
	UnitOfMeasureLum UnitOfMeasure = "LUM"
	UnitOfMeasureLux UnitOfMeasure = "LUX"
	UnitOfMeasureMal UnitOfMeasure = "MAL"
	UnitOfMeasureMam UnitOfMeasure = "MAM"
	UnitOfMeasureMaw UnitOfMeasure = "MAW"
	UnitOfMeasureMbe UnitOfMeasure = "MBE"
	UnitOfMeasureMbf UnitOfMeasure = "MBF"
	UnitOfMeasureMbr UnitOfMeasure = "MBR"
	UnitOfMeasureMcu UnitOfMeasure = "MCU"
	UnitOfMeasureMgm UnitOfMeasure = "MGM"
	UnitOfMeasureMhz UnitOfMeasure = "MHZ"
	UnitOfMeasureMik UnitOfMeasure = "MIK"
	UnitOfMeasureMil UnitOfMeasure = "MIL"
	UnitOfMeasureMin UnitOfMeasure = "MIN"
	UnitOfMeasureMio UnitOfMeasure = "MIO"
	UnitOfMeasureMiu UnitOfMeasure = "MIU"
	UnitOfMeasureMld UnitOfMeasure = "MLD"
	UnitOfMeasureMlt UnitOfMeasure = "MLT"
	UnitOfMeasureMmk UnitOfMeasure = "MMK"
	UnitOfMeasureMmq UnitOfMeasure = "MMQ"
	UnitOfMeasureMmt UnitOfMeasure = "MMT"
	UnitOfMeasureMon UnitOfMeasure = "MON"
	UnitOfMeasureMpa UnitOfMeasure = "MPA"
	UnitOfMeasureMqh UnitOfMeasure = "MQH"
	UnitOfMeasureMqs UnitOfMeasure = "MQS"
	UnitOfMeasureMsk UnitOfMeasure = "MSK"
	UnitOfMeasureMtk UnitOfMeasure = "MTK"
	UnitOfMeasureMtq UnitOfMeasure = "MTQ"
	UnitOfMeasureMtr UnitOfMeasure = "MTR"
	UnitOfMeasureMts UnitOfMeasure = "MTS"
	UnitOfMeasureMva UnitOfMeasure = "MVA"
	UnitOfMeasureMwh UnitOfMeasure = "MWH"
	UnitOfMeasureNar UnitOfMeasure = "NAR"
	UnitOfMeasureNbb UnitOfMeasure = "NBB"
	UnitOfMeasureNcl UnitOfMeasure = "NCL"
	UnitOfMeasureNew UnitOfMeasure = "NEW"
	UnitOfMeasureNiu UnitOfMeasure = "NIU"
	UnitOfMeasureNmb UnitOfMeasure = "NMB"
	UnitOfMeasureNmi UnitOfMeasure = "NMI"
	UnitOfMeasureNmp UnitOfMeasure = "NMP"
	UnitOfMeasureNmr UnitOfMeasure = "NMR"
	UnitOfMeasureNpl UnitOfMeasure = "NPL"
	UnitOfMeasureNpt UnitOfMeasure = "NPT"
	UnitOfMeasureNrl UnitOfMeasure = "NRL"
	UnitOfMeasureNtt UnitOfMeasure = "NTT"
	UnitOfMeasureOhm UnitOfMeasure = "OHM"
	UnitOfMeasureOnz UnitOfMeasure = "ONZ"
	UnitOfMeasureOza UnitOfMeasure = "OZA"
	UnitOfMeasureOzi UnitOfMeasure = "OZI"
	UnitOfMeasurePal UnitOfMeasure = "PAL"
	UnitOfMeasurePcb UnitOfMeasure = "PCB"
	UnitOfMeasurePce UnitOfMeasure = "PCE"
	UnitOfMeasurePgl UnitOfMeasure = "PGL"
	UnitOfMeasurePk  UnitOfMeasure = "PK"
	UnitOfMeasurePsc UnitOfMeasure = "PSC"
	UnitOfMeasurePtd UnitOfMeasure = "PTD"
	UnitOfMeasurePti UnitOfMeasure = "PTI"
	UnitOfMeasurePtl UnitOfMeasure = "PTL"
	UnitOfMeasureQan UnitOfMeasure = "QAN"
	UnitOfMeasureQtd UnitOfMeasure = "QTD"
	UnitOfMeasureQti UnitOfMeasure = "QTI"
	UnitOfMeasureQtl UnitOfMeasure = "QTL"
	UnitOfMeasureQtr UnitOfMeasure = "QTR"
	UnitOfMeasureRpm UnitOfMeasure = "RPM"
	UnitOfMeasureRps UnitOfMeasure = "RPS"
	UnitOfMeasureSan UnitOfMeasure = "SAN"
	UnitOfMeasureSco UnitOfMeasure = "SCO"
	UnitOfMeasureScr UnitOfMeasure = "SCR"
	UnitOfMeasureSec UnitOfMeasure = "SEC"
	UnitOfMeasureSet UnitOfMeasure = "SET"
	UnitOfMeasureSht UnitOfMeasure = "SHT"
	UnitOfMeasureSie UnitOfMeasure = "SIE"
	UnitOfMeasureSmi UnitOfMeasure = "SMI"
	UnitOfMeasureSst UnitOfMeasure = "SST"
	UnitOfMeasureSt  UnitOfMeasure = "ST"
	UnitOfMeasureSti UnitOfMeasure = "STI"
	UnitOfMeasureTah UnitOfMeasure = "TAH"
	UnitOfMeasureTne UnitOfMeasure = "TNE"
	UnitOfMeasureTpr UnitOfMeasure = "TPR"
	UnitOfMeasureTqd UnitOfMeasure = "TQD"
	UnitOfMeasureTrl UnitOfMeasure = "TRL"
	UnitOfMeasureTsd UnitOfMeasure = "TSD"
	UnitOfMeasureTsh UnitOfMeasure = "TSH"
	UnitOfMeasureVlt UnitOfMeasure = "VLT"
	UnitOfMeasureWcd UnitOfMeasure = "WCD"
	UnitOfMeasureWeb UnitOfMeasure = "WEB"
	UnitOfMeasureWee UnitOfMeasure = "WEE"
	UnitOfMeasureWhr UnitOfMeasure = "WHR"
	UnitOfMeasureWsd UnitOfMeasure = "WSD"
	UnitOfMeasureWtt UnitOfMeasure = "WTT"
	UnitOfMeasureYdk UnitOfMeasure = "YDK"
	UnitOfMeasureYdq UnitOfMeasure = "YDQ"
)

func NewUnitOfMeasureFromString(s string) (UnitOfMeasure, error) {
	switch s {
	case "ACR":
		return UnitOfMeasureAcr, nil
	case "AMH":
		return UnitOfMeasureAmh, nil
	case "AMP":
		return UnitOfMeasureAmp, nil
	case "APZ":
		return UnitOfMeasureApz, nil
	case "ARE":
		return UnitOfMeasureAre, nil
	case "ASM":
		return UnitOfMeasureAsm, nil
	case "ASV":
		return UnitOfMeasureAsv, nil
	case "ATM":
		return UnitOfMeasureAtm, nil
	case "ATT":
		return UnitOfMeasureAtt, nil
	case "BAR":
		return UnitOfMeasureBar, nil
	case "BFT":
		return UnitOfMeasureBft, nil
	case "BHP":
		return UnitOfMeasureBhp, nil
	case "BHX":
		return UnitOfMeasureBhx, nil
	case "BIL":
		return UnitOfMeasureBil, nil
	case "BLD":
		return UnitOfMeasureBld, nil
	case "BLL":
		return UnitOfMeasureBll, nil
	case "BQL":
		return UnitOfMeasureBql, nil
	case "BTU":
		return UnitOfMeasureBtu, nil
	case "BUA":
		return UnitOfMeasureBua, nil
	case "BUI":
		return UnitOfMeasureBui, nil
	case "BX":
		return UnitOfMeasureBx, nil
	case "CCT":
		return UnitOfMeasureCct, nil
	case "CDL":
		return UnitOfMeasureCdl, nil
	case "CEL":
		return UnitOfMeasureCel, nil
	case "CEN":
		return UnitOfMeasureCen, nil
	case "CGM":
		return UnitOfMeasureCgm, nil
	case "CKG":
		return UnitOfMeasureCkg, nil
	case "CLF":
		return UnitOfMeasureClf, nil
	case "CLT":
		return UnitOfMeasureClt, nil
	case "CMK":
		return UnitOfMeasureCmk, nil
	case "CMT":
		return UnitOfMeasureCmt, nil
	case "CNP":
		return UnitOfMeasureCnp, nil
	case "CNT":
		return UnitOfMeasureCnt, nil
	case "COU":
		return UnitOfMeasureCou, nil
	case "CS":
		return UnitOfMeasureCs, nil
	case "CTM":
		return UnitOfMeasureCtm, nil
	case "CUR":
		return UnitOfMeasureCur, nil
	case "CWA":
		return UnitOfMeasureCwa, nil
	case "DAA":
		return UnitOfMeasureDaa, nil
	case "DAD":
		return UnitOfMeasureDad, nil
	case "DAY":
		return UnitOfMeasureDay, nil
	case "DEC":
		return UnitOfMeasureDec, nil
	case "DLT":
		return UnitOfMeasureDlt, nil
	case "DMK":
		return UnitOfMeasureDmk, nil
	case "DMQ":
		return UnitOfMeasureDmq, nil
	case "DMT":
		return UnitOfMeasureDmt, nil
	case "DPC":
		return UnitOfMeasureDpc, nil
	case "DPT":
		return UnitOfMeasureDpt, nil
	case "DRA":
		return UnitOfMeasureDra, nil
	case "DRI":
		return UnitOfMeasureDri, nil
	case "DRL":
		return UnitOfMeasureDrl, nil
	case "DRM":
		return UnitOfMeasureDrm, nil
	case "DTH":
		return UnitOfMeasureDth, nil
	case "DTN":
		return UnitOfMeasureDtn, nil
	case "DWT":
		return UnitOfMeasureDwt, nil
	case "DZN":
		return UnitOfMeasureDzn, nil
	case "DZP":
		return UnitOfMeasureDzp, nil
	case "DZR":
		return UnitOfMeasureDzr, nil
	case "EA":
		return UnitOfMeasureEa, nil
	case "EAC":
		return UnitOfMeasureEac, nil
	case "FAH":
		return UnitOfMeasureFah, nil
	case "FAR":
		return UnitOfMeasureFar, nil
	case "FOT":
		return UnitOfMeasureFot, nil
	case "FTK":
		return UnitOfMeasureFtk, nil
	case "FTQ":
		return UnitOfMeasureFtq, nil
	case "GBQ":
		return UnitOfMeasureGbq, nil
	case "GFI":
		return UnitOfMeasureGfi, nil
	case "GGR":
		return UnitOfMeasureGgr, nil
	case "GII":
		return UnitOfMeasureGii, nil
	case "GLD":
		return UnitOfMeasureGld, nil
	case "GLI":
		return UnitOfMeasureGli, nil
	case "GLL":
		return UnitOfMeasureGll, nil
	case "GRM":
		return UnitOfMeasureGrm, nil
	case "GRN":
		return UnitOfMeasureGrn, nil
	case "GRO":
		return UnitOfMeasureGro, nil
	case "GRT":
		return UnitOfMeasureGrt, nil
	case "GWH":
		return UnitOfMeasureGwh, nil
	case "HAR":
		return UnitOfMeasureHar, nil
	case "HBA":
		return UnitOfMeasureHba, nil
	case "HGM":
		return UnitOfMeasureHgm, nil
	case "HIU":
		return UnitOfMeasureHiu, nil
	case "HLT":
		return UnitOfMeasureHlt, nil
	case "HMQ":
		return UnitOfMeasureHmq, nil
	case "HMT":
		return UnitOfMeasureHmt, nil
	case "HPA":
		return UnitOfMeasureHpa, nil
	case "HTZ":
		return UnitOfMeasureHtz, nil
	case "HUR":
		return UnitOfMeasureHur, nil
	case "INH":
		return UnitOfMeasureInh, nil
	case "INK":
		return UnitOfMeasureInk, nil
	case "INQ":
		return UnitOfMeasureInq, nil
	case "ITM":
		return UnitOfMeasureItm, nil
	case "JOU":
		return UnitOfMeasureJou, nil
	case "KBA":
		return UnitOfMeasureKba, nil
	case "KEL":
		return UnitOfMeasureKel, nil
	case "KGM":
		return UnitOfMeasureKgm, nil
	case "KGS":
		return UnitOfMeasureKgs, nil
	case "KHZ":
		return UnitOfMeasureKhz, nil
	case "KJO":
		return UnitOfMeasureKjo, nil
	case "KMH":
		return UnitOfMeasureKmh, nil
	case "KMK":
		return UnitOfMeasureKmk, nil
	case "KMQ":
		return UnitOfMeasureKmq, nil
	case "KMT":
		return UnitOfMeasureKmt, nil
	case "KNI":
		return UnitOfMeasureKni, nil
	case "KNS":
		return UnitOfMeasureKns, nil
	case "KNT":
		return UnitOfMeasureKnt, nil
	case "KPA":
		return UnitOfMeasureKpa, nil
	case "KPH":
		return UnitOfMeasureKph, nil
	case "KPO":
		return UnitOfMeasureKpo, nil
	case "KPP":
		return UnitOfMeasureKpp, nil
	case "KSD":
		return UnitOfMeasureKsd, nil
	case "KSH":
		return UnitOfMeasureKsh, nil
	case "KTN":
		return UnitOfMeasureKtn, nil
	case "KUR":
		return UnitOfMeasureKur, nil
	case "KVA":
		return UnitOfMeasureKva, nil
	case "KVR":
		return UnitOfMeasureKvr, nil
	case "KVT":
		return UnitOfMeasureKvt, nil
	case "KWH":
		return UnitOfMeasureKwh, nil
	case "KWT":
		return UnitOfMeasureKwt, nil
	case "LBR":
		return UnitOfMeasureLbr, nil
	case "LBS":
		return UnitOfMeasureLbs, nil
	case "LEF":
		return UnitOfMeasureLef, nil
	case "LPA":
		return UnitOfMeasureLpa, nil
	case "LTN":
		return UnitOfMeasureLtn, nil
	case "LTR":
		return UnitOfMeasureLtr, nil
	case "LUM":
		return UnitOfMeasureLum, nil
	case "LUX":
		return UnitOfMeasureLux, nil
	case "MAL":
		return UnitOfMeasureMal, nil
	case "MAM":
		return UnitOfMeasureMam, nil
	case "MAW":
		return UnitOfMeasureMaw, nil
	case "MBE":
		return UnitOfMeasureMbe, nil
	case "MBF":
		return UnitOfMeasureMbf, nil
	case "MBR":
		return UnitOfMeasureMbr, nil
	case "MCU":
		return UnitOfMeasureMcu, nil
	case "MGM":
		return UnitOfMeasureMgm, nil
	case "MHZ":
		return UnitOfMeasureMhz, nil
	case "MIK":
		return UnitOfMeasureMik, nil
	case "MIL":
		return UnitOfMeasureMil, nil
	case "MIN":
		return UnitOfMeasureMin, nil
	case "MIO":
		return UnitOfMeasureMio, nil
	case "MIU":
		return UnitOfMeasureMiu, nil
	case "MLD":
		return UnitOfMeasureMld, nil
	case "MLT":
		return UnitOfMeasureMlt, nil
	case "MMK":
		return UnitOfMeasureMmk, nil
	case "MMQ":
		return UnitOfMeasureMmq, nil
	case "MMT":
		return UnitOfMeasureMmt, nil
	case "MON":
		return UnitOfMeasureMon, nil
	case "MPA":
		return UnitOfMeasureMpa, nil
	case "MQH":
		return UnitOfMeasureMqh, nil
	case "MQS":
		return UnitOfMeasureMqs, nil
	case "MSK":
		return UnitOfMeasureMsk, nil
	case "MTK":
		return UnitOfMeasureMtk, nil
	case "MTQ":
		return UnitOfMeasureMtq, nil
	case "MTR":
		return UnitOfMeasureMtr, nil
	case "MTS":
		return UnitOfMeasureMts, nil
	case "MVA":
		return UnitOfMeasureMva, nil
	case "MWH":
		return UnitOfMeasureMwh, nil
	case "NAR":
		return UnitOfMeasureNar, nil
	case "NBB":
		return UnitOfMeasureNbb, nil
	case "NCL":
		return UnitOfMeasureNcl, nil
	case "NEW":
		return UnitOfMeasureNew, nil
	case "NIU":
		return UnitOfMeasureNiu, nil
	case "NMB":
		return UnitOfMeasureNmb, nil
	case "NMI":
		return UnitOfMeasureNmi, nil
	case "NMP":
		return UnitOfMeasureNmp, nil
	case "NMR":
		return UnitOfMeasureNmr, nil
	case "NPL":
		return UnitOfMeasureNpl, nil
	case "NPT":
		return UnitOfMeasureNpt, nil
	case "NRL":
		return UnitOfMeasureNrl, nil
	case "NTT":
		return UnitOfMeasureNtt, nil
	case "OHM":
		return UnitOfMeasureOhm, nil
	case "ONZ":
		return UnitOfMeasureOnz, nil
	case "OZA":
		return UnitOfMeasureOza, nil
	case "OZI":
		return UnitOfMeasureOzi, nil
	case "PAL":
		return UnitOfMeasurePal, nil
	case "PCB":
		return UnitOfMeasurePcb, nil
	case "PCE":
		return UnitOfMeasurePce, nil
	case "PGL":
		return UnitOfMeasurePgl, nil
	case "PK":
		return UnitOfMeasurePk, nil
	case "PSC":
		return UnitOfMeasurePsc, nil
	case "PTD":
		return UnitOfMeasurePtd, nil
	case "PTI":
		return UnitOfMeasurePti, nil
	case "PTL":
		return UnitOfMeasurePtl, nil
	case "QAN":
		return UnitOfMeasureQan, nil
	case "QTD":
		return UnitOfMeasureQtd, nil
	case "QTI":
		return UnitOfMeasureQti, nil
	case "QTL":
		return UnitOfMeasureQtl, nil
	case "QTR":
		return UnitOfMeasureQtr, nil
	case "RPM":
		return UnitOfMeasureRpm, nil
	case "RPS":
		return UnitOfMeasureRps, nil
	case "SAN":
		return UnitOfMeasureSan, nil
	case "SCO":
		return UnitOfMeasureSco, nil
	case "SCR":
		return UnitOfMeasureScr, nil
	case "SEC":
		return UnitOfMeasureSec, nil
	case "SET":
		return UnitOfMeasureSet, nil
	case "SHT":
		return UnitOfMeasureSht, nil
	case "SIE":
		return UnitOfMeasureSie, nil
	case "SMI":
		return UnitOfMeasureSmi, nil
	case "SST":
		return UnitOfMeasureSst, nil
	case "ST":
		return UnitOfMeasureSt, nil
	case "STI":
		return UnitOfMeasureSti, nil
	case "TAH":
		return UnitOfMeasureTah, nil
	case "TNE":
		return UnitOfMeasureTne, nil
	case "TPR":
		return UnitOfMeasureTpr, nil
	case "TQD":
		return UnitOfMeasureTqd, nil
	case "TRL":
		return UnitOfMeasureTrl, nil
	case "TSD":
		return UnitOfMeasureTsd, nil
	case "TSH":
		return UnitOfMeasureTsh, nil
	case "VLT":
		return UnitOfMeasureVlt, nil
	case "WCD":
		return UnitOfMeasureWcd, nil
	case "WEB":
		return UnitOfMeasureWeb, nil
	case "WEE":
		return UnitOfMeasureWee, nil
	case "WHR":
		return UnitOfMeasureWhr, nil
	case "WSD":
		return UnitOfMeasureWsd, nil
	case "WTT":
		return UnitOfMeasureWtt, nil
	case "YDK":
		return UnitOfMeasureYdk, nil
	case "YDQ":
		return UnitOfMeasureYdq, nil
	}
	var t UnitOfMeasure
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UnitOfMeasure) Ptr() *UnitOfMeasure {
	return &u
}

// Object that contains information about the EBT voucher.
//
// **Note:** Vouchers are available only for EBT SNAP payments.
var (
	voucherFieldApprovalCode = big.NewInt(1 << 0)
	voucherFieldSerialNumber = big.NewInt(1 << 1)
)

type Voucher struct {
	// Authorization code that the processor issued for the transaction.
	ApprovalCode string `json:"approvalCode" url:"approvalCode"`
	// Serial number of the voucher.
	SerialNumber string `json:"serialNumber" url:"serialNumber"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *Voucher) GetApprovalCode() string {
	if v == nil {
		return ""
	}
	return v.ApprovalCode
}

func (v *Voucher) GetSerialNumber() string {
	if v == nil {
		return ""
	}
	return v.SerialNumber
}

func (v *Voucher) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *Voucher) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetApprovalCode sets the ApprovalCode field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Voucher) SetApprovalCode(approvalCode string) {
	v.ApprovalCode = approvalCode
	v.require(voucherFieldApprovalCode)
}

// SetSerialNumber sets the SerialNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *Voucher) SetSerialNumber(serialNumber string) {
	v.SerialNumber = serialNumber
	v.require(voucherFieldSerialNumber)
}

func (v *Voucher) UnmarshalJSON(data []byte) error {
	type unmarshaler Voucher
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = Voucher(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *Voucher) MarshalJSON() ([]byte, error) {
	type embed Voucher
	var marshaler = struct {
		embed
	}{
		embed: embed(*v),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, v.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (v *Voucher) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

var (
	webhookFieldUri                 = big.NewInt(1 << 0)
	webhookFieldSecret              = big.NewInt(1 << 1)
	webhookFieldSupportEmailAddress = big.NewInt(1 << 2)
)

type Webhook struct {
	// Public endpoint that we send notifications to.
	Uri string `json:"uri" url:"uri"`
	// String that we send with a notification so that you can ensure it is a valid notification from our gateway. We include the value in the Payroc-Secret header parameter in the webhook call.
	// **Note:** In the response, we truncate the secret to the last 16 characters and mask the first 10 characters.
	Secret string `json:"secret" url:"secret"`
	// Email address of the person or team that we contact if we can't deliver notifications.
	SupportEmailAddress string `json:"supportEmailAddress" url:"supportEmailAddress"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *Webhook) GetUri() string {
	if w == nil {
		return ""
	}
	return w.Uri
}

func (w *Webhook) GetSecret() string {
	if w == nil {
		return ""
	}
	return w.Secret
}

func (w *Webhook) GetSupportEmailAddress() string {
	if w == nil {
		return ""
	}
	return w.SupportEmailAddress
}

func (w *Webhook) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *Webhook) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUri sets the Uri field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetUri(uri string) {
	w.Uri = uri
	w.require(webhookFieldUri)
}

// SetSecret sets the Secret field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetSecret(secret string) {
	w.Secret = secret
	w.require(webhookFieldSecret)
}

// SetSupportEmailAddress sets the SupportEmailAddress field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *Webhook) SetSupportEmailAddress(supportEmailAddress string) {
	w.SupportEmailAddress = supportEmailAddress
	w.require(webhookFieldSupportEmailAddress)
}

func (w *Webhook) UnmarshalJSON(data []byte) error {
	type unmarshaler Webhook
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = Webhook(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *Webhook) MarshalJSON() ([]byte, error) {
	type embed Webhook
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *Webhook) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

var (
	fiveHundredFieldType   = big.NewInt(1 << 0)
	fiveHundredFieldTitle  = big.NewInt(1 << 1)
	fiveHundredFieldStatus = big.NewInt(1 << 2)
	fiveHundredFieldDetail = big.NewInt(1 << 3)
	fiveHundredFieldErrors = big.NewInt(1 << 4)
)

type FiveHundred struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string                   `json:"detail" url:"detail"`
	Errors []*FiveHundredErrorsItem `json:"errors,omitempty" url:"errors,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FiveHundred) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FiveHundred) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FiveHundred) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FiveHundred) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FiveHundred) GetErrors() []*FiveHundredErrorsItem {
	if f == nil {
		return nil
	}
	return f.Errors
}

func (f *FiveHundred) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FiveHundred) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FiveHundred) SetType(type_ string) {
	f.Type = type_
	f.require(fiveHundredFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FiveHundred) SetTitle(title string) {
	f.Title = title
	f.require(fiveHundredFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FiveHundred) SetStatus(status int) {
	f.Status = status
	f.require(fiveHundredFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FiveHundred) SetDetail(detail string) {
	f.Detail = detail
	f.require(fiveHundredFieldDetail)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FiveHundred) SetErrors(errors []*FiveHundredErrorsItem) {
	f.Errors = errors
	f.require(fiveHundredFieldErrors)
}

func (f *FiveHundred) UnmarshalJSON(data []byte) error {
	type unmarshaler FiveHundred
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FiveHundred(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FiveHundred) MarshalJSON() ([]byte, error) {
	type embed FiveHundred
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FiveHundred) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fiveHundredErrorsItemFieldMessage = big.NewInt(1 << 0)
)

type FiveHundredErrorsItem struct {
	// Error message
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FiveHundredErrorsItem) GetMessage() *string {
	if f == nil {
		return nil
	}
	return f.Message
}

func (f *FiveHundredErrorsItem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FiveHundredErrorsItem) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FiveHundredErrorsItem) SetMessage(message *string) {
	f.Message = message
	f.require(fiveHundredErrorsItemFieldMessage)
}

func (f *FiveHundredErrorsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler FiveHundredErrorsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FiveHundredErrorsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FiveHundredErrorsItem) MarshalJSON() ([]byte, error) {
	type embed FiveHundredErrorsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FiveHundredErrorsItem) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredFieldType   = big.NewInt(1 << 0)
	fourHundredFieldTitle  = big.NewInt(1 << 1)
	fourHundredFieldStatus = big.NewInt(1 << 2)
	fourHundredFieldDetail = big.NewInt(1 << 3)
	fourHundredFieldErrors = big.NewInt(1 << 4)
)

type FourHundred struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string                   `json:"detail" url:"detail"`
	Errors []*FourHundredErrorsItem `json:"errors,omitempty" url:"errors,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundred) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundred) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundred) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundred) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundred) GetErrors() []*FourHundredErrorsItem {
	if f == nil {
		return nil
	}
	return f.Errors
}

func (f *FourHundred) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundred) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundred) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundred) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundred) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundred) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredFieldDetail)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundred) SetErrors(errors []*FourHundredErrorsItem) {
	f.Errors = errors
	f.require(fourHundredFieldErrors)
}

func (f *FourHundred) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundred
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundred(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundred) MarshalJSON() ([]byte, error) {
	type embed FourHundred
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundred) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredErrorsItemFieldParameter = big.NewInt(1 << 0)
	fourHundredErrorsItemFieldDetail    = big.NewInt(1 << 1)
	fourHundredErrorsItemFieldMessage   = big.NewInt(1 << 2)
)

type FourHundredErrorsItem struct {
	// The parameter or field causing the issues
	Parameter *string `json:"parameter,omitempty" url:"parameter,omitempty"`
	// Short detail of the validation errors
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// Error message
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredErrorsItem) GetParameter() *string {
	if f == nil {
		return nil
	}
	return f.Parameter
}

func (f *FourHundredErrorsItem) GetDetail() *string {
	if f == nil {
		return nil
	}
	return f.Detail
}

func (f *FourHundredErrorsItem) GetMessage() *string {
	if f == nil {
		return nil
	}
	return f.Message
}

func (f *FourHundredErrorsItem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredErrorsItem) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetParameter sets the Parameter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredErrorsItem) SetParameter(parameter *string) {
	f.Parameter = parameter
	f.require(fourHundredErrorsItemFieldParameter)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredErrorsItem) SetDetail(detail *string) {
	f.Detail = detail
	f.require(fourHundredErrorsItemFieldDetail)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredErrorsItem) SetMessage(message *string) {
	f.Message = message
	f.require(fourHundredErrorsItemFieldMessage)
}

func (f *FourHundredErrorsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredErrorsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredErrorsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredErrorsItem) MarshalJSON() ([]byte, error) {
	type embed FourHundredErrorsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredErrorsItem) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredFifteenFieldType   = big.NewInt(1 << 0)
	fourHundredFifteenFieldTitle  = big.NewInt(1 << 1)
	fourHundredFifteenFieldStatus = big.NewInt(1 << 2)
	fourHundredFifteenFieldDetail = big.NewInt(1 << 3)
)

type FourHundredFifteen struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string `json:"detail" url:"detail"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredFifteen) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundredFifteen) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundredFifteen) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundredFifteen) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundredFifteen) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredFifteen) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFifteen) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredFifteenFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFifteen) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredFifteenFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFifteen) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredFifteenFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFifteen) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredFifteenFieldDetail)
}

func (f *FourHundredFifteen) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredFifteen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredFifteen(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredFifteen) MarshalJSON() ([]byte, error) {
	type embed FourHundredFifteen
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredFifteen) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredFourFieldType     = big.NewInt(1 << 0)
	fourHundredFourFieldTitle    = big.NewInt(1 << 1)
	fourHundredFourFieldStatus   = big.NewInt(1 << 2)
	fourHundredFourFieldDetail   = big.NewInt(1 << 3)
	fourHundredFourFieldResource = big.NewInt(1 << 4)
)

type FourHundredFour struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string `json:"detail" url:"detail"`
	// Resource that was not found
	Resource *string `json:"resource,omitempty" url:"resource,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredFour) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundredFour) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundredFour) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundredFour) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundredFour) GetResource() *string {
	if f == nil {
		return nil
	}
	return f.Resource
}

func (f *FourHundredFour) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredFour) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFour) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredFourFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFour) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredFourFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFour) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredFourFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFour) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredFourFieldDetail)
}

// SetResource sets the Resource field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredFour) SetResource(resource *string) {
	f.Resource = resource
	f.require(fourHundredFourFieldResource)
}

func (f *FourHundredFour) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredFour
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredFour(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredFour) MarshalJSON() ([]byte, error) {
	type embed FourHundredFour
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredFour) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredNineFieldType     = big.NewInt(1 << 0)
	fourHundredNineFieldTitle    = big.NewInt(1 << 1)
	fourHundredNineFieldStatus   = big.NewInt(1 << 2)
	fourHundredNineFieldDetail   = big.NewInt(1 << 3)
	fourHundredNineFieldInstance = big.NewInt(1 << 4)
	fourHundredNineFieldErrors   = big.NewInt(1 << 5)
	fourHundredNineFieldLink     = big.NewInt(1 << 6)
)

type FourHundredNine struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string `json:"detail" url:"detail"`
	// Resource path to the existing resource
	Instance *string                      `json:"instance,omitempty" url:"instance,omitempty"`
	Errors   []*FourHundredNineErrorsItem `json:"errors,omitempty" url:"errors,omitempty"`
	Link     *Link                        `json:"link,omitempty" url:"link,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredNine) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundredNine) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundredNine) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundredNine) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundredNine) GetInstance() *string {
	if f == nil {
		return nil
	}
	return f.Instance
}

func (f *FourHundredNine) GetErrors() []*FourHundredNineErrorsItem {
	if f == nil {
		return nil
	}
	return f.Errors
}

func (f *FourHundredNine) GetLink() *Link {
	if f == nil {
		return nil
	}
	return f.Link
}

func (f *FourHundredNine) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredNine) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNine) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredNineFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNine) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredNineFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNine) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredNineFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNine) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredNineFieldDetail)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNine) SetInstance(instance *string) {
	f.Instance = instance
	f.require(fourHundredNineFieldInstance)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNine) SetErrors(errors []*FourHundredNineErrorsItem) {
	f.Errors = errors
	f.require(fourHundredNineFieldErrors)
}

// SetLink sets the Link field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNine) SetLink(link *Link) {
	f.Link = link
	f.require(fourHundredNineFieldLink)
}

func (f *FourHundredNine) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredNine
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredNine(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredNine) MarshalJSON() ([]byte, error) {
	type embed FourHundredNine
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredNine) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredNineErrorsItemFieldParameter = big.NewInt(1 << 0)
	fourHundredNineErrorsItemFieldDetail    = big.NewInt(1 << 1)
	fourHundredNineErrorsItemFieldMessage   = big.NewInt(1 << 2)
)

type FourHundredNineErrorsItem struct {
	// The parameter or field causing the issues
	Parameter *string `json:"parameter,omitempty" url:"parameter,omitempty"`
	// Short detail of the validation errors
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// Error message
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredNineErrorsItem) GetParameter() *string {
	if f == nil {
		return nil
	}
	return f.Parameter
}

func (f *FourHundredNineErrorsItem) GetDetail() *string {
	if f == nil {
		return nil
	}
	return f.Detail
}

func (f *FourHundredNineErrorsItem) GetMessage() *string {
	if f == nil {
		return nil
	}
	return f.Message
}

func (f *FourHundredNineErrorsItem) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredNineErrorsItem) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetParameter sets the Parameter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNineErrorsItem) SetParameter(parameter *string) {
	f.Parameter = parameter
	f.require(fourHundredNineErrorsItemFieldParameter)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNineErrorsItem) SetDetail(detail *string) {
	f.Detail = detail
	f.require(fourHundredNineErrorsItemFieldDetail)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredNineErrorsItem) SetMessage(message *string) {
	f.Message = message
	f.require(fourHundredNineErrorsItemFieldMessage)
}

func (f *FourHundredNineErrorsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredNineErrorsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredNineErrorsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredNineErrorsItem) MarshalJSON() ([]byte, error) {
	type embed FourHundredNineErrorsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredNineErrorsItem) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredOneFieldType   = big.NewInt(1 << 0)
	fourHundredOneFieldTitle  = big.NewInt(1 << 1)
	fourHundredOneFieldStatus = big.NewInt(1 << 2)
	fourHundredOneFieldDetail = big.NewInt(1 << 3)
)

type FourHundredOne struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string `json:"detail" url:"detail"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredOne) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundredOne) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundredOne) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundredOne) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundredOne) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredOne) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredOne) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredOneFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredOne) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredOneFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredOne) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredOneFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredOne) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredOneFieldDetail)
}

func (f *FourHundredOne) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredOne
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredOne(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredOne) MarshalJSON() ([]byte, error) {
	type embed FourHundredOne
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredOne) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredSixFieldType   = big.NewInt(1 << 0)
	fourHundredSixFieldTitle  = big.NewInt(1 << 1)
	fourHundredSixFieldStatus = big.NewInt(1 << 2)
	fourHundredSixFieldDetail = big.NewInt(1 << 3)
)

type FourHundredSix struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string `json:"detail" url:"detail"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredSix) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundredSix) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundredSix) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundredSix) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundredSix) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredSix) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredSix) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredSixFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredSix) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredSixFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredSix) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredSixFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredSix) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredSixFieldDetail)
}

func (f *FourHundredSix) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredSix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredSix(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredSix) MarshalJSON() ([]byte, error) {
	type embed FourHundredSix
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredSix) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredThirteenFieldType   = big.NewInt(1 << 0)
	fourHundredThirteenFieldTitle  = big.NewInt(1 << 1)
	fourHundredThirteenFieldStatus = big.NewInt(1 << 2)
	fourHundredThirteenFieldDetail = big.NewInt(1 << 3)
)

type FourHundredThirteen struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string `json:"detail" url:"detail"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredThirteen) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundredThirteen) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundredThirteen) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundredThirteen) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundredThirteen) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredThirteen) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThirteen) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredThirteenFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThirteen) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredThirteenFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThirteen) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredThirteenFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThirteen) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredThirteenFieldDetail)
}

func (f *FourHundredThirteen) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredThirteen
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredThirteen(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredThirteen) MarshalJSON() ([]byte, error) {
	type embed FourHundredThirteen
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredThirteen) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	fourHundredThreeFieldType     = big.NewInt(1 << 0)
	fourHundredThreeFieldTitle    = big.NewInt(1 << 1)
	fourHundredThreeFieldStatus   = big.NewInt(1 << 2)
	fourHundredThreeFieldDetail   = big.NewInt(1 << 3)
	fourHundredThreeFieldInstance = big.NewInt(1 << 4)
	fourHundredThreeFieldResource = big.NewInt(1 << 5)
)

type FourHundredThree struct {
	// URI reference identifying the problem type
	Type string `json:"type" url:"type"`
	// Short description of the issue.
	Title string `json:"title" url:"title"`
	// Http status code
	Status int `json:"status" url:"status"`
	// Explanation of the problem
	Detail string `json:"detail" url:"detail"`
	// Resource path the action was attempted on
	Instance *string `json:"instance,omitempty" url:"instance,omitempty"`
	// Resource the action was attempted on
	Resource *string `json:"resource,omitempty" url:"resource,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FourHundredThree) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FourHundredThree) GetTitle() string {
	if f == nil {
		return ""
	}
	return f.Title
}

func (f *FourHundredThree) GetStatus() int {
	if f == nil {
		return 0
	}
	return f.Status
}

func (f *FourHundredThree) GetDetail() string {
	if f == nil {
		return ""
	}
	return f.Detail
}

func (f *FourHundredThree) GetInstance() *string {
	if f == nil {
		return nil
	}
	return f.Instance
}

func (f *FourHundredThree) GetResource() *string {
	if f == nil {
		return nil
	}
	return f.Resource
}

func (f *FourHundredThree) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FourHundredThree) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThree) SetType(type_ string) {
	f.Type = type_
	f.require(fourHundredThreeFieldType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThree) SetTitle(title string) {
	f.Title = title
	f.require(fourHundredThreeFieldTitle)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThree) SetStatus(status int) {
	f.Status = status
	f.require(fourHundredThreeFieldStatus)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThree) SetDetail(detail string) {
	f.Detail = detail
	f.require(fourHundredThreeFieldDetail)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThree) SetInstance(instance *string) {
	f.Instance = instance
	f.require(fourHundredThreeFieldInstance)
}

// SetResource sets the Resource field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FourHundredThree) SetResource(resource *string) {
	f.Resource = resource
	f.require(fourHundredThreeFieldResource)
}

func (f *FourHundredThree) UnmarshalJSON(data []byte) error {
	type unmarshaler FourHundredThree
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FourHundredThree(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FourHundredThree) MarshalJSON() ([]byte, error) {
	type embed FourHundredThree
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FourHundredThree) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}
