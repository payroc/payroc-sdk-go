// Code generated by Fern. DO NOT EDIT.

package banktransferpayments

import (
	json "encoding/json"
	fmt "fmt"
	papisdkgo "github.com/payroc/payroc-sdk-go"
	internal "github.com/payroc/payroc-sdk-go/internal"
	big "math/big"
	time "time"
)

var (
	bankTransferPaymentRequestFieldIdempotencyKey       = big.NewInt(1 << 0)
	bankTransferPaymentRequestFieldProcessingTerminalId = big.NewInt(1 << 1)
	bankTransferPaymentRequestFieldOrder                = big.NewInt(1 << 2)
	bankTransferPaymentRequestFieldCustomer             = big.NewInt(1 << 3)
	bankTransferPaymentRequestFieldCredentialOnFile     = big.NewInt(1 << 4)
	bankTransferPaymentRequestFieldPaymentMethod        = big.NewInt(1 << 5)
	bankTransferPaymentRequestFieldCustomFields         = big.NewInt(1 << 6)
)

type BankTransferPaymentRequest struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that we assigned to the terminal.
	ProcessingTerminalId string                                     `json:"processingTerminalId" url:"-"`
	Order                *papisdkgo.BankTransferPaymentRequestOrder `json:"order" url:"-"`
	Customer             *papisdkgo.BankTransferCustomer            `json:"customer,omitempty" url:"-"`
	CredentialOnFile     *papisdkgo.SchemasCredentialOnFile         `json:"credentialOnFile,omitempty" url:"-"`
	// Polymorphic object that contains payment detail information.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`pad` - Pre-authorized debit (PAD) details
	// -	`secureToken` - Secure token details
	// -	`singleUseToken` - Single-use token details
	PaymentMethod *BankTransferPaymentRequestPaymentMethod `json:"paymentMethod" url:"-"`
	// Array of customField objects.
	CustomFields []*papisdkgo.CustomField `json:"customFields,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BankTransferPaymentRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequest) SetIdempotencyKey(idempotencyKey string) {
	b.IdempotencyKey = idempotencyKey
	b.require(bankTransferPaymentRequestFieldIdempotencyKey)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequest) SetProcessingTerminalId(processingTerminalId string) {
	b.ProcessingTerminalId = processingTerminalId
	b.require(bankTransferPaymentRequestFieldProcessingTerminalId)
}

// SetOrder sets the Order field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequest) SetOrder(order *papisdkgo.BankTransferPaymentRequestOrder) {
	b.Order = order
	b.require(bankTransferPaymentRequestFieldOrder)
}

// SetCustomer sets the Customer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequest) SetCustomer(customer *papisdkgo.BankTransferCustomer) {
	b.Customer = customer
	b.require(bankTransferPaymentRequestFieldCustomer)
}

// SetCredentialOnFile sets the CredentialOnFile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequest) SetCredentialOnFile(credentialOnFile *papisdkgo.SchemasCredentialOnFile) {
	b.CredentialOnFile = credentialOnFile
	b.require(bankTransferPaymentRequestFieldCredentialOnFile)
}

// SetPaymentMethod sets the PaymentMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequest) SetPaymentMethod(paymentMethod *BankTransferPaymentRequestPaymentMethod) {
	b.PaymentMethod = paymentMethod
	b.require(bankTransferPaymentRequestFieldPaymentMethod)
}

// SetCustomFields sets the CustomFields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankTransferPaymentRequest) SetCustomFields(customFields []*papisdkgo.CustomField) {
	b.CustomFields = customFields
	b.require(bankTransferPaymentRequestFieldCustomFields)
}

func (b *BankTransferPaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BankTransferPaymentRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*b = BankTransferPaymentRequest(body)
	return nil
}

func (b *BankTransferPaymentRequest) MarshalJSON() ([]byte, error) {
	type embed BankTransferPaymentRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	listPaymentsRequestFieldProcessingTerminalId = big.NewInt(1 << 0)
	listPaymentsRequestFieldOrderId              = big.NewInt(1 << 1)
	listPaymentsRequestFieldNameOnAccount        = big.NewInt(1 << 2)
	listPaymentsRequestFieldLast4                = big.NewInt(1 << 3)
	listPaymentsRequestFieldType                 = big.NewInt(1 << 4)
	listPaymentsRequestFieldStatus               = big.NewInt(1 << 5)
	listPaymentsRequestFieldDateFrom             = big.NewInt(1 << 6)
	listPaymentsRequestFieldDateTo               = big.NewInt(1 << 7)
	listPaymentsRequestFieldSettlementState      = big.NewInt(1 << 8)
	listPaymentsRequestFieldSettlementDate       = big.NewInt(1 << 9)
	listPaymentsRequestFieldPaymentLinkId        = big.NewInt(1 << 10)
	listPaymentsRequestFieldBefore               = big.NewInt(1 << 11)
	listPaymentsRequestFieldAfter                = big.NewInt(1 << 12)
	listPaymentsRequestFieldLimit                = big.NewInt(1 << 13)
)

type ListPaymentsRequest struct {
	// Filter results by the unique identifier that we assigned to the terminal.
	ProcessingTerminalId string `json:"-" url:"processingTerminalId"`
	// Filter results by the order ID of the payment.
	OrderId *string `json:"-" url:"orderId,omitempty"`
	// Filter results by the account holder's name.
	NameOnAccount *string `json:"-" url:"nameOnAccount,omitempty"`
	// Filter results by the last four digits of the account number.
	Last4 *string `json:"-" url:"last4,omitempty"`
	// Filter results by transaction type.
	Type []*ListPaymentsRequestTypeItem `json:"-" url:"type,omitempty"`
	// Filter results by the status of the payment.
	Status []*ListPaymentsRequestStatusItem `json:"-" url:"status,omitempty"`
	// Filter results by payments that the merchant ran after a specific date. The value follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.
	DateFrom *time.Time `json:"-" url:"dateFrom,omitempty"`
	// Filter results by payments that the merchant ran before a specific date. The value follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard.
	DateTo *time.Time `json:"-" url:"dateTo,omitempty"`
	// Filter results by the settlement status.
	SettlementState *ListPaymentsRequestSettlementState `json:"-" url:"settlementState,omitempty"`
	// Filter results by the settlement date. Send a value in **YYYY-MM-DD** format.
	SettlementDate *time.Time `json:"-" url:"settlementDate,omitempty" format:"date"`
	// Filter results by the paymentLinkId.
	PaymentLinkId *string `json:"-" url:"paymentLinkId,omitempty"`
	// Return the previous page of results before the value that you specify.
	//
	// You can’t send the before parameter in the same request as the after parameter.
	Before *string `json:"-" url:"before,omitempty"`
	// Return the next page of results after the value that you specify.
	//
	// You can’t send the after parameter in the same request as the before parameter.
	After *string `json:"-" url:"after,omitempty"`
	// Limit the maximum number of results that we return for each page.
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListPaymentsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetProcessingTerminalId sets the ProcessingTerminalId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetProcessingTerminalId(processingTerminalId string) {
	l.ProcessingTerminalId = processingTerminalId
	l.require(listPaymentsRequestFieldProcessingTerminalId)
}

// SetOrderId sets the OrderId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetOrderId(orderId *string) {
	l.OrderId = orderId
	l.require(listPaymentsRequestFieldOrderId)
}

// SetNameOnAccount sets the NameOnAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetNameOnAccount(nameOnAccount *string) {
	l.NameOnAccount = nameOnAccount
	l.require(listPaymentsRequestFieldNameOnAccount)
}

// SetLast4 sets the Last4 field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetLast4(last4 *string) {
	l.Last4 = last4
	l.require(listPaymentsRequestFieldLast4)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetType(type_ []*ListPaymentsRequestTypeItem) {
	l.Type = type_
	l.require(listPaymentsRequestFieldType)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetStatus(status []*ListPaymentsRequestStatusItem) {
	l.Status = status
	l.require(listPaymentsRequestFieldStatus)
}

// SetDateFrom sets the DateFrom field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetDateFrom(dateFrom *time.Time) {
	l.DateFrom = dateFrom
	l.require(listPaymentsRequestFieldDateFrom)
}

// SetDateTo sets the DateTo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetDateTo(dateTo *time.Time) {
	l.DateTo = dateTo
	l.require(listPaymentsRequestFieldDateTo)
}

// SetSettlementState sets the SettlementState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetSettlementState(settlementState *ListPaymentsRequestSettlementState) {
	l.SettlementState = settlementState
	l.require(listPaymentsRequestFieldSettlementState)
}

// SetSettlementDate sets the SettlementDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetSettlementDate(settlementDate *time.Time) {
	l.SettlementDate = settlementDate
	l.require(listPaymentsRequestFieldSettlementDate)
}

// SetPaymentLinkId sets the PaymentLinkId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetPaymentLinkId(paymentLinkId *string) {
	l.PaymentLinkId = paymentLinkId
	l.require(listPaymentsRequestFieldPaymentLinkId)
}

// SetBefore sets the Before field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetBefore(before *string) {
	l.Before = before
	l.require(listPaymentsRequestFieldBefore)
}

// SetAfter sets the After field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetAfter(after *string) {
	l.After = after
	l.require(listPaymentsRequestFieldAfter)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListPaymentsRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listPaymentsRequestFieldLimit)
}

var (
	representmentFieldIdempotencyKey = big.NewInt(1 << 0)
	representmentFieldPaymentId      = big.NewInt(1 << 1)
	representmentFieldPaymentMethod  = big.NewInt(1 << 2)
)

type Representment struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that our gateway assigned to the payment.
	PaymentId string `json:"-" url:"-"`
	// Polymorphic object that contains the customer's updated payment details.
	//
	// The value of the type parameter determines which variant you should use:
	// -	`ach` - Automated Clearing House (ACH) details
	// -	`secureToken` - Secure token details
	PaymentMethod *RepresentmentPaymentMethod `json:"paymentMethod,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *Representment) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Representment) SetIdempotencyKey(idempotencyKey string) {
	r.IdempotencyKey = idempotencyKey
	r.require(representmentFieldIdempotencyKey)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Representment) SetPaymentId(paymentId string) {
	r.PaymentId = paymentId
	r.require(representmentFieldPaymentId)
}

// SetPaymentMethod sets the PaymentMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Representment) SetPaymentMethod(paymentMethod *RepresentmentPaymentMethod) {
	r.PaymentMethod = paymentMethod
	r.require(representmentFieldPaymentMethod)
}

func (r *Representment) UnmarshalJSON(data []byte) error {
	type unmarshaler Representment
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*r = Representment(body)
	return nil
}

func (r *Representment) MarshalJSON() ([]byte, error) {
	type embed Representment
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	retrievePaymentsRequestFieldPaymentId = big.NewInt(1 << 0)
)

type RetrievePaymentsRequest struct {
	// Unique identifier that our gateway assigned to the payment.
	PaymentId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *RetrievePaymentsRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetPaymentId sets the PaymentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RetrievePaymentsRequest) SetPaymentId(paymentId string) {
	r.PaymentId = paymentId
	r.require(retrievePaymentsRequestFieldPaymentId)
}

// Polymorphic object that contains payment detail information.
//
// The value of the type parameter determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`pad` - Pre-authorized debit (PAD) details
// -	`secureToken` - Secure token details
// -	`singleUseToken` - Single-use token details
type BankTransferPaymentRequestPaymentMethod struct {
	Type           string
	Ach            *papisdkgo.AchPayload
	Pad            *papisdkgo.PadPayload
	SecureToken    *papisdkgo.SecureTokenPayload
	SingleUseToken *papisdkgo.SingleUseTokenPayload
}

func (b *BankTransferPaymentRequestPaymentMethod) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BankTransferPaymentRequestPaymentMethod) GetAch() *papisdkgo.AchPayload {
	if b == nil {
		return nil
	}
	return b.Ach
}

func (b *BankTransferPaymentRequestPaymentMethod) GetPad() *papisdkgo.PadPayload {
	if b == nil {
		return nil
	}
	return b.Pad
}

func (b *BankTransferPaymentRequestPaymentMethod) GetSecureToken() *papisdkgo.SecureTokenPayload {
	if b == nil {
		return nil
	}
	return b.SecureToken
}

func (b *BankTransferPaymentRequestPaymentMethod) GetSingleUseToken() *papisdkgo.SingleUseTokenPayload {
	if b == nil {
		return nil
	}
	return b.SingleUseToken
}

func (b *BankTransferPaymentRequestPaymentMethod) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(papisdkgo.AchPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Ach = value
	case "pad":
		value := new(papisdkgo.PadPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Pad = value
	case "secureToken":
		value := new(papisdkgo.SecureTokenPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.SecureToken = value
	case "singleUseToken":
		value := new(papisdkgo.SingleUseTokenPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.SingleUseToken = value
	}
	return nil
}

func (b BankTransferPaymentRequestPaymentMethod) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(b.Ach, "type", "ach")
	}
	if b.Pad != nil {
		return internal.MarshalJSONWithExtraProperty(b.Pad, "type", "pad")
	}
	if b.SecureToken != nil {
		return internal.MarshalJSONWithExtraProperty(b.SecureToken, "type", "secureToken")
	}
	if b.SingleUseToken != nil {
		return internal.MarshalJSONWithExtraProperty(b.SingleUseToken, "type", "singleUseToken")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BankTransferPaymentRequestPaymentMethodVisitor interface {
	VisitAch(*papisdkgo.AchPayload) error
	VisitPad(*papisdkgo.PadPayload) error
	VisitSecureToken(*papisdkgo.SecureTokenPayload) error
	VisitSingleUseToken(*papisdkgo.SingleUseTokenPayload) error
}

func (b *BankTransferPaymentRequestPaymentMethod) Accept(visitor BankTransferPaymentRequestPaymentMethodVisitor) error {
	if b.Ach != nil {
		return visitor.VisitAch(b.Ach)
	}
	if b.Pad != nil {
		return visitor.VisitPad(b.Pad)
	}
	if b.SecureToken != nil {
		return visitor.VisitSecureToken(b.SecureToken)
	}
	if b.SingleUseToken != nil {
		return visitor.VisitSingleUseToken(b.SingleUseToken)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BankTransferPaymentRequestPaymentMethod) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Ach != nil {
		fields = append(fields, "ach")
	}
	if b.Pad != nil {
		fields = append(fields, "pad")
	}
	if b.SecureToken != nil {
		fields = append(fields, "secureToken")
	}
	if b.SingleUseToken != nil {
		fields = append(fields, "singleUseToken")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

type ListPaymentsRequestSettlementState string

const (
	ListPaymentsRequestSettlementStateSettled   ListPaymentsRequestSettlementState = "settled"
	ListPaymentsRequestSettlementStateUnsettled ListPaymentsRequestSettlementState = "unsettled"
)

func NewListPaymentsRequestSettlementStateFromString(s string) (ListPaymentsRequestSettlementState, error) {
	switch s {
	case "settled":
		return ListPaymentsRequestSettlementStateSettled, nil
	case "unsettled":
		return ListPaymentsRequestSettlementStateUnsettled, nil
	}
	var t ListPaymentsRequestSettlementState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestSettlementState) Ptr() *ListPaymentsRequestSettlementState {
	return &l
}

type ListPaymentsRequestStatusItem string

const (
	ListPaymentsRequestStatusItemReady    ListPaymentsRequestStatusItem = "ready"
	ListPaymentsRequestStatusItemPending  ListPaymentsRequestStatusItem = "pending"
	ListPaymentsRequestStatusItemDeclined ListPaymentsRequestStatusItem = "declined"
	ListPaymentsRequestStatusItemComplete ListPaymentsRequestStatusItem = "complete"
	ListPaymentsRequestStatusItemAdmin    ListPaymentsRequestStatusItem = "admin"
	ListPaymentsRequestStatusItemReversal ListPaymentsRequestStatusItem = "reversal"
	ListPaymentsRequestStatusItemReturned ListPaymentsRequestStatusItem = "returned"
)

func NewListPaymentsRequestStatusItemFromString(s string) (ListPaymentsRequestStatusItem, error) {
	switch s {
	case "ready":
		return ListPaymentsRequestStatusItemReady, nil
	case "pending":
		return ListPaymentsRequestStatusItemPending, nil
	case "declined":
		return ListPaymentsRequestStatusItemDeclined, nil
	case "complete":
		return ListPaymentsRequestStatusItemComplete, nil
	case "admin":
		return ListPaymentsRequestStatusItemAdmin, nil
	case "reversal":
		return ListPaymentsRequestStatusItemReversal, nil
	case "returned":
		return ListPaymentsRequestStatusItemReturned, nil
	}
	var t ListPaymentsRequestStatusItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestStatusItem) Ptr() *ListPaymentsRequestStatusItem {
	return &l
}

type ListPaymentsRequestTypeItem string

const (
	ListPaymentsRequestTypeItemPayment             ListPaymentsRequestTypeItem = "payment"
	ListPaymentsRequestTypeItemAccountVerification ListPaymentsRequestTypeItem = "accountVerification"
)

func NewListPaymentsRequestTypeItemFromString(s string) (ListPaymentsRequestTypeItem, error) {
	switch s {
	case "payment":
		return ListPaymentsRequestTypeItemPayment, nil
	case "accountVerification":
		return ListPaymentsRequestTypeItemAccountVerification, nil
	}
	var t ListPaymentsRequestTypeItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListPaymentsRequestTypeItem) Ptr() *ListPaymentsRequestTypeItem {
	return &l
}

// Polymorphic object that contains the customer's updated payment details.
//
// The value of the type parameter determines which variant you should use:
// -	`ach` - Automated Clearing House (ACH) details
// -	`secureToken` - Secure token details
type RepresentmentPaymentMethod struct {
	Type        string
	Ach         *papisdkgo.AchPayload
	SecureToken *papisdkgo.SecureTokenPayload
}

func (r *RepresentmentPaymentMethod) GetType() string {
	if r == nil {
		return ""
	}
	return r.Type
}

func (r *RepresentmentPaymentMethod) GetAch() *papisdkgo.AchPayload {
	if r == nil {
		return nil
	}
	return r.Ach
}

func (r *RepresentmentPaymentMethod) GetSecureToken() *papisdkgo.SecureTokenPayload {
	if r == nil {
		return nil
	}
	return r.SecureToken
}

func (r *RepresentmentPaymentMethod) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", r)
	}
	switch unmarshaler.Type {
	case "ach":
		value := new(papisdkgo.AchPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Ach = value
	case "secureToken":
		value := new(papisdkgo.SecureTokenPayload)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.SecureToken = value
	}
	return nil
}

func (r RepresentmentPaymentMethod) MarshalJSON() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	if r.Ach != nil {
		return internal.MarshalJSONWithExtraProperty(r.Ach, "type", "ach")
	}
	if r.SecureToken != nil {
		return internal.MarshalJSONWithExtraProperty(r.SecureToken, "type", "secureToken")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", r)
}

type RepresentmentPaymentMethodVisitor interface {
	VisitAch(*papisdkgo.AchPayload) error
	VisitSecureToken(*papisdkgo.SecureTokenPayload) error
}

func (r *RepresentmentPaymentMethod) Accept(visitor RepresentmentPaymentMethodVisitor) error {
	if r.Ach != nil {
		return visitor.VisitAch(r.Ach)
	}
	if r.SecureToken != nil {
		return visitor.VisitSecureToken(r.SecureToken)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", r)
}

func (r *RepresentmentPaymentMethod) validate() error {
	if r == nil {
		return fmt.Errorf("type %T is nil", r)
	}
	var fields []string
	if r.Ach != nil {
		fields = append(fields, "ach")
	}
	if r.SecureToken != nil {
		fields = append(fields, "secureToken")
	}
	if len(fields) == 0 {
		if r.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", r, r.Type)
		}
		return fmt.Errorf("type %T is empty", r)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", r, fields)
	}
	if r.Type != "" {
		field := fields[0]
		if r.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				r,
				r.Type,
				r,
			)
		}
	}
	return nil
}
