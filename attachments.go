// Code generated by Fern. DO NOT EDIT.

package payroc

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/payroc/payroc-sdk-go/internal"
	io "io"
	big "math/big"
	time "time"
)

var (
	getAttachmentRequestFieldAttachmentId = big.NewInt(1 << 0)
)

type GetAttachmentRequest struct {
	// Unique identifier of the attachment
	AttachmentId string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetAttachmentRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetAttachmentId sets the AttachmentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetAttachmentRequest) SetAttachmentId(attachmentId string) {
	g.AttachmentId = attachmentId
	g.require(getAttachmentRequestFieldAttachmentId)
}

var (
	attachmentFieldAttachmentId     = big.NewInt(1 << 0)
	attachmentFieldType             = big.NewInt(1 << 1)
	attachmentFieldUploadStatus     = big.NewInt(1 << 2)
	attachmentFieldFileName         = big.NewInt(1 << 3)
	attachmentFieldContentType      = big.NewInt(1 << 4)
	attachmentFieldDescription      = big.NewInt(1 << 5)
	attachmentFieldEntity           = big.NewInt(1 << 6)
	attachmentFieldCreatedDate      = big.NewInt(1 << 7)
	attachmentFieldLastModifiedDate = big.NewInt(1 << 8)
	attachmentFieldMetadata         = big.NewInt(1 << 9)
)

type Attachment struct {
	// Unique identifier that our gateway assigned to the attachment.
	AttachmentId string `json:"attachmentId" url:"attachmentId"`
	// Type of attachment.
	Type AttachmentType `json:"type" url:"type"`
	// Upload status of the attachment. The value is one of the following:
	// - `pending` - We have not yet uploaded the attachment.
	// - `accepted` - We have uploaded the attachment.
	// - `rejected` - We rejected the attachment.
	UploadStatus AttachmentUploadStatus `json:"uploadStatus" url:"uploadStatus"`
	// Name of the file.
	FileName string `json:"fileName" url:"fileName"`
	// Content type of the file.
	ContentType string `json:"contentType" url:"contentType"`
	// Short description of the attachment.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Object that contains information about the entity that the attachment is linked to.
	Entity *AttachmentEntity `json:"entity" url:"entity"`
	// Date and time that we received your request to upload the attachment.
	CreatedDate time.Time `json:"createdDate" url:"createdDate"`
	// Date and time the attachment was last modified.
	LastModifiedDate time.Time `json:"lastModifiedDate" url:"lastModifiedDate"`
	// Object that you can send to include custom metadata in the request.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Attachment) GetAttachmentId() string {
	if a == nil {
		return ""
	}
	return a.AttachmentId
}

func (a *Attachment) GetType() AttachmentType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *Attachment) GetUploadStatus() AttachmentUploadStatus {
	if a == nil {
		return ""
	}
	return a.UploadStatus
}

func (a *Attachment) GetFileName() string {
	if a == nil {
		return ""
	}
	return a.FileName
}

func (a *Attachment) GetContentType() string {
	if a == nil {
		return ""
	}
	return a.ContentType
}

func (a *Attachment) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *Attachment) GetEntity() *AttachmentEntity {
	if a == nil {
		return nil
	}
	return a.Entity
}

func (a *Attachment) GetCreatedDate() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.CreatedDate
}

func (a *Attachment) GetLastModifiedDate() time.Time {
	if a == nil {
		return time.Time{}
	}
	return a.LastModifiedDate
}

func (a *Attachment) GetMetadata() map[string]string {
	if a == nil {
		return nil
	}
	return a.Metadata
}

func (a *Attachment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Attachment) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAttachmentId sets the AttachmentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetAttachmentId(attachmentId string) {
	a.AttachmentId = attachmentId
	a.require(attachmentFieldAttachmentId)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetType(type_ AttachmentType) {
	a.Type = type_
	a.require(attachmentFieldType)
}

// SetUploadStatus sets the UploadStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetUploadStatus(uploadStatus AttachmentUploadStatus) {
	a.UploadStatus = uploadStatus
	a.require(attachmentFieldUploadStatus)
}

// SetFileName sets the FileName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetFileName(fileName string) {
	a.FileName = fileName
	a.require(attachmentFieldFileName)
}

// SetContentType sets the ContentType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetContentType(contentType string) {
	a.ContentType = contentType
	a.require(attachmentFieldContentType)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetDescription(description *string) {
	a.Description = description
	a.require(attachmentFieldDescription)
}

// SetEntity sets the Entity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetEntity(entity *AttachmentEntity) {
	a.Entity = entity
	a.require(attachmentFieldEntity)
}

// SetCreatedDate sets the CreatedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetCreatedDate(createdDate time.Time) {
	a.CreatedDate = createdDate
	a.require(attachmentFieldCreatedDate)
}

// SetLastModifiedDate sets the LastModifiedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetLastModifiedDate(lastModifiedDate time.Time) {
	a.LastModifiedDate = lastModifiedDate
	a.require(attachmentFieldLastModifiedDate)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *Attachment) SetMetadata(metadata map[string]string) {
	a.Metadata = metadata
	a.require(attachmentFieldMetadata)
}

func (a *Attachment) UnmarshalJSON(data []byte) error {
	type embed Attachment
	var unmarshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = Attachment(unmarshaler.embed)
	a.CreatedDate = unmarshaler.CreatedDate.Time()
	a.LastModifiedDate = unmarshaler.LastModifiedDate.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Attachment) MarshalJSON() ([]byte, error) {
	type embed Attachment
	var marshaler = struct {
		embed
		CreatedDate      *internal.DateTime `json:"createdDate"`
		LastModifiedDate *internal.DateTime `json:"lastModifiedDate"`
	}{
		embed:            embed(*a),
		CreatedDate:      internal.NewDateTime(a.CreatedDate),
		LastModifiedDate: internal.NewDateTime(a.LastModifiedDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *Attachment) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Object that contains information about the entity that the attachment is linked to.
var (
	attachmentEntityFieldType = big.NewInt(1 << 0)
	attachmentEntityFieldId   = big.NewInt(1 << 1)
)

type AttachmentEntity struct {
	// Type of entity that the attachment is linked to.
	Type AttachmentEntityType `json:"type" url:"type"`
	// Unique identifier of the entity that the attachment is linked to.
	Id string `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttachmentEntity) GetType() AttachmentEntityType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AttachmentEntity) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AttachmentEntity) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttachmentEntity) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentEntity) SetType(type_ AttachmentEntityType) {
	a.Type = type_
	a.require(attachmentEntityFieldType)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentEntity) SetId(id string) {
	a.Id = id
	a.require(attachmentEntityFieldId)
}

func (a *AttachmentEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler AttachmentEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttachmentEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttachmentEntity) MarshalJSON() ([]byte, error) {
	type embed AttachmentEntity
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AttachmentEntity) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Type of entity that the attachment is linked to.
type AttachmentEntityType string

const (
	AttachmentEntityTypeProcessingAccount AttachmentEntityType = "processingAccount"
)

func NewAttachmentEntityTypeFromString(s string) (AttachmentEntityType, error) {
	switch s {
	case "processingAccount":
		return AttachmentEntityTypeProcessingAccount, nil
	}
	var t AttachmentEntityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttachmentEntityType) Ptr() *AttachmentEntityType {
	return &a
}

// Type of attachment.
type AttachmentType string

const (
	AttachmentTypeBankingEvidence           AttachmentType = "bankingEvidence"
	AttachmentTypeQuestionnairesAndLicenses AttachmentType = "questionnairesAndLicenses"
	AttachmentTypeMerchantStatements        AttachmentType = "merchantStatements"
	AttachmentTypeTaxDocuments              AttachmentType = "taxDocuments"
	AttachmentTypeMpaOrAmendment            AttachmentType = "mpaOrAmendment"
	AttachmentTypeProofOfBusiness           AttachmentType = "proofOfBusiness"
	AttachmentTypeFinancialStatements       AttachmentType = "financialStatements"
	AttachmentTypePersonalIdentification    AttachmentType = "personalIdentification"
	AttachmentTypeOther                     AttachmentType = "other"
)

func NewAttachmentTypeFromString(s string) (AttachmentType, error) {
	switch s {
	case "bankingEvidence":
		return AttachmentTypeBankingEvidence, nil
	case "questionnairesAndLicenses":
		return AttachmentTypeQuestionnairesAndLicenses, nil
	case "merchantStatements":
		return AttachmentTypeMerchantStatements, nil
	case "taxDocuments":
		return AttachmentTypeTaxDocuments, nil
	case "mpaOrAmendment":
		return AttachmentTypeMpaOrAmendment, nil
	case "proofOfBusiness":
		return AttachmentTypeProofOfBusiness, nil
	case "financialStatements":
		return AttachmentTypeFinancialStatements, nil
	case "personalIdentification":
		return AttachmentTypePersonalIdentification, nil
	case "other":
		return AttachmentTypeOther, nil
	}
	var t AttachmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttachmentType) Ptr() *AttachmentType {
	return &a
}

// Upload status of the attachment. The value is one of the following:
// - `pending` - We have not yet uploaded the attachment.
// - `accepted` - We have uploaded the attachment.
// - `rejected` - We rejected the attachment.
type AttachmentUploadStatus string

const (
	AttachmentUploadStatusPending  AttachmentUploadStatus = "pending"
	AttachmentUploadStatusAccepted AttachmentUploadStatus = "accepted"
	AttachmentUploadStatusRejected AttachmentUploadStatus = "rejected"
)

func NewAttachmentUploadStatusFromString(s string) (AttachmentUploadStatus, error) {
	switch s {
	case "pending":
		return AttachmentUploadStatusPending, nil
	case "accepted":
		return AttachmentUploadStatusAccepted, nil
	case "rejected":
		return AttachmentUploadStatusRejected, nil
	}
	var t AttachmentUploadStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttachmentUploadStatus) Ptr() *AttachmentUploadStatus {
	return &a
}

// Object that contains details about the attachment.
var (
	uploadToProcessingAccountAttachmentsRequestAttachmentFieldType        = big.NewInt(1 << 0)
	uploadToProcessingAccountAttachmentsRequestAttachmentFieldDescription = big.NewInt(1 << 1)
	uploadToProcessingAccountAttachmentsRequestAttachmentFieldMetadata    = big.NewInt(1 << 2)
)

type UploadToProcessingAccountAttachmentsRequestAttachment struct {
	// Type of attachment.
	Type UploadToProcessingAccountAttachmentsRequestAttachmentType `json:"type" url:"type"`
	// Short description of the attachment.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Object that you can send to include custom metadata in the request.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) GetType() UploadToProcessingAccountAttachmentsRequestAttachmentType {
	if u == nil {
		return ""
	}
	return u.Type
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) GetDescription() *string {
	if u == nil {
		return nil
	}
	return u.Description
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) GetMetadata() map[string]string {
	if u == nil {
		return nil
	}
	return u.Metadata
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UploadToProcessingAccountAttachmentsRequestAttachment) SetType(type_ UploadToProcessingAccountAttachmentsRequestAttachmentType) {
	u.Type = type_
	u.require(uploadToProcessingAccountAttachmentsRequestAttachmentFieldType)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UploadToProcessingAccountAttachmentsRequestAttachment) SetDescription(description *string) {
	u.Description = description
	u.require(uploadToProcessingAccountAttachmentsRequestAttachmentFieldDescription)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UploadToProcessingAccountAttachmentsRequestAttachment) SetMetadata(metadata map[string]string) {
	u.Metadata = metadata
	u.require(uploadToProcessingAccountAttachmentsRequestAttachmentFieldMetadata)
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler UploadToProcessingAccountAttachmentsRequestAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UploadToProcessingAccountAttachmentsRequestAttachment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) MarshalJSON() ([]byte, error) {
	type embed UploadToProcessingAccountAttachmentsRequestAttachment
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UploadToProcessingAccountAttachmentsRequestAttachment) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Type of attachment.
type UploadToProcessingAccountAttachmentsRequestAttachmentType string

const (
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeBankingEvidence           UploadToProcessingAccountAttachmentsRequestAttachmentType = "bankingEvidence"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeQuestionnairesAndLicenses UploadToProcessingAccountAttachmentsRequestAttachmentType = "questionnairesAndLicenses"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeMerchantStatements        UploadToProcessingAccountAttachmentsRequestAttachmentType = "merchantStatements"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeTaxDocuments              UploadToProcessingAccountAttachmentsRequestAttachmentType = "taxDocuments"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeMpaOrAmendment            UploadToProcessingAccountAttachmentsRequestAttachmentType = "mpaOrAmendment"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeProofOfBusiness           UploadToProcessingAccountAttachmentsRequestAttachmentType = "proofOfBusiness"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeFinancialStatements       UploadToProcessingAccountAttachmentsRequestAttachmentType = "financialStatements"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypePersonalIdentification    UploadToProcessingAccountAttachmentsRequestAttachmentType = "personalIdentification"
	UploadToProcessingAccountAttachmentsRequestAttachmentTypeOther                     UploadToProcessingAccountAttachmentsRequestAttachmentType = "other"
)

func NewUploadToProcessingAccountAttachmentsRequestAttachmentTypeFromString(s string) (UploadToProcessingAccountAttachmentsRequestAttachmentType, error) {
	switch s {
	case "bankingEvidence":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeBankingEvidence, nil
	case "questionnairesAndLicenses":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeQuestionnairesAndLicenses, nil
	case "merchantStatements":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeMerchantStatements, nil
	case "taxDocuments":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeTaxDocuments, nil
	case "mpaOrAmendment":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeMpaOrAmendment, nil
	case "proofOfBusiness":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeProofOfBusiness, nil
	case "financialStatements":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeFinancialStatements, nil
	case "personalIdentification":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypePersonalIdentification, nil
	case "other":
		return UploadToProcessingAccountAttachmentsRequestAttachmentTypeOther, nil
	}
	var t UploadToProcessingAccountAttachmentsRequestAttachmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UploadToProcessingAccountAttachmentsRequestAttachmentType) Ptr() *UploadToProcessingAccountAttachmentsRequestAttachmentType {
	return &u
}

var (
	uploadAttachmentFieldIdempotencyKey      = big.NewInt(1 << 0)
	uploadAttachmentFieldProcessingAccountId = big.NewInt(1 << 1)
)

type UploadAttachment struct {
	// Unique identifier that you generate for each request. You must use the [UUID v4 format](https://www.rfc-editor.org/rfc/rfc4122) for the identifier. For more information about the idempotency key, go to [Idempotency](https://docs.payroc.com/api/idempotency).
	IdempotencyKey string `json:"-" url:"-"`
	// Unique identifier that we assigned to the processing account.
	ProcessingAccountId string    `json:"-" url:"-"`
	File                io.Reader `json:"-" url:"-"`
	// Object that contains details about the attachment.
	Attachment *UploadToProcessingAccountAttachmentsRequestAttachment `json:"attachment" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UploadAttachment) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UploadAttachment) SetIdempotencyKey(idempotencyKey string) {
	u.IdempotencyKey = idempotencyKey
	u.require(uploadAttachmentFieldIdempotencyKey)
}

// SetProcessingAccountId sets the ProcessingAccountId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UploadAttachment) SetProcessingAccountId(processingAccountId string) {
	u.ProcessingAccountId = processingAccountId
	u.require(uploadAttachmentFieldProcessingAccountId)
}

func (u *UploadAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler UploadAttachment
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*u = UploadAttachment(body)
	return nil
}

func (u *UploadAttachment) MarshalJSON() ([]byte, error) {
	type embed UploadAttachment
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}
